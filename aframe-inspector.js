(function(modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = (installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    });
    modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );
    module.l = true;
    return module.exports;
  }
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.i = function(value) {
    return value;
  };
  __webpack_require__.d = function(exports, name, getter) {
    if (!__webpack_require__.o(exports, name)) {
      Object.defineProperty(exports, name, {
        configurable: false,
        enumerable: true,
        get: getter
      });
    }
  };
  __webpack_require__.n = function(module) {
    var getter =
      module && module.__esModule
        ? function getDefault() {
            return module["default"];
          }
        : function getModuleExports() {
            return module;
          };
    __webpack_require__.d(getter, "a", getter);
    return getter;
  };
  __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  __webpack_require__.p = "/dist/";
  return __webpack_require__((__webpack_require__.s = 255));
})([
  function(module, exports, __webpack_require__) {
    "use strict";
    var validateFormat = function validateFormat(format) {};
    if (false) {
      validateFormat = function validateFormat(format) {
        if (format === undefined) {
          throw new Error("invariant requires an error message argument");
        }
      };
    }
    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment " +
              "for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    module.exports = invariant;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = __webpack_require__(21);
  },
  function(module, exports, __webpack_require__) {
    if (false) {
      var REACT_ELEMENT_TYPE =
        (typeof Symbol === "function" &&
          Symbol.for &&
          Symbol.for("react.element")) ||
        0xeac7;
      var isValidElement = function(object) {
        return (
          typeof object === "object" &&
          object !== null &&
          object.$$typeof === REACT_ELEMENT_TYPE
        );
      };
      var throwOnDirectAccess = true;
      module.exports = require("./factoryWithTypeCheckers")(
        isValidElement,
        throwOnDirectAccess
      );
    } else {
      module.exports = __webpack_require__(167)();
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function reactProdInvariant(code) {
      var argCount = arguments.length - 1;
      var message =
        "Minified React error #" +
        code +
        "; visit " +
        "http://facebook.github.io/react/docs/error-decoder.html?invariant=" +
        code;
      for (var argIdx = 0; argIdx < argCount; argIdx++) {
        message += "&args[]=" + encodeURIComponent(arguments[argIdx + 1]);
      }
      message +=
        " for the full message or use the non-minified dev environment" +
        " for full errors and additional helpful warnings.";
      var error = new Error(message);
      error.name = "Invariant Violation";
      error.framesToPop = 1;
      throw error;
    }
    module.exports = reactProdInvariant;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var emptyFunction = __webpack_require__(10);
    var warning = emptyFunction;
    if (false) {
      var printWarning = function printWarning(format) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }
        var argIndex = 0;
        var message =
          "Warning: " +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };
      warning = function warning(condition, format) {
        if (format === undefined) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning " +
              "message argument"
          );
        }
        if (format.indexOf("Failed Composite propType: ") === 0) {
          return;
        }
        if (!condition) {
          for (
            var _len2 = arguments.length,
              args = Array(_len2 > 2 ? _len2 - 2 : 0),
              _key2 = 2;
            _key2 < _len2;
            _key2++
          ) {
            args[_key2 - 2] = arguments[_key2];
          }
          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    module.exports = warning;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventEmitter = __webpack_require__(149).EventEmitter;
    var emitter = new EventEmitter();
    emitter.setMaxListeners(0);
    function Events() {}
    Events.prototype.on = function() {
      emitter.on.apply(emitter, arguments);
      return this;
    };
    Events.prototype.emit = function() {
      emitter.emit.apply(emitter, arguments);
      return this;
    };
    Events.prototype.removeListener = function() {
      emitter.removeListener.apply(emitter, arguments);
      return this;
    };
    module.exports = new Events();
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError(
          "Object.assign cannot be called with null or undefined"
        );
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (
          Object.keys(Object.assign({}, test3)).join("") !==
          "abcdefghijklmnopqrst"
        ) {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative()
      ? Object.assign
      : function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }
          return to;
        };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var DOMProperty = __webpack_require__(19);
    var ReactDOMComponentFlags = __webpack_require__(78);
    var invariant = __webpack_require__(0);
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var Flags = ReactDOMComponentFlags;
    var internalInstanceKey =
      "__reactInternalInstance$" +
      Math.random()
        .toString(36)
        .slice(2);
    function shouldPrecacheNode(node, nodeID) {
      return (
        (node.nodeType === 1 &&
          node.getAttribute(ATTR_NAME) === String(nodeID)) ||
        (node.nodeType === 8 &&
          node.nodeValue === " react-text: " + nodeID + " ") ||
        (node.nodeType === 8 &&
          node.nodeValue === " react-empty: " + nodeID + " ")
      );
    }
    function getRenderedHostOrTextFromComponent(component) {
      var rendered;
      while ((rendered = component._renderedComponent)) {
        component = rendered;
      }
      return component;
    }
    function precacheNode(inst, node) {
      var hostInst = getRenderedHostOrTextFromComponent(inst);
      hostInst._hostNode = node;
      node[internalInstanceKey] = hostInst;
    }
    function uncacheNode(inst) {
      var node = inst._hostNode;
      if (node) {
        delete node[internalInstanceKey];
        inst._hostNode = null;
      }
    }
    function precacheChildNodes(inst, node) {
      if (inst._flags & Flags.hasCachedChildNodes) {
        return;
      }
      var children = inst._renderedChildren;
      var childNode = node.firstChild;
      outer: for (var name in children) {
        if (!children.hasOwnProperty(name)) {
          continue;
        }
        var childInst = children[name];
        var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
        if (childID === 0) {
          continue;
        }
        for (; childNode !== null; childNode = childNode.nextSibling) {
          if (shouldPrecacheNode(childNode, childID)) {
            precacheNode(childInst, childNode);
            continue outer;
          }
        }
        true
          ? false
            ? invariant(false, "Unable to find element with ID %s.", childID)
            : _prodInvariant("32", childID)
          : void 0;
      }
      inst._flags |= Flags.hasCachedChildNodes;
    }
    function getClosestInstanceFromNode(node) {
      if (node[internalInstanceKey]) {
        return node[internalInstanceKey];
      }
      var parents = [];
      while (!node[internalInstanceKey]) {
        parents.push(node);
        if (node.parentNode) {
          node = node.parentNode;
        } else {
          return null;
        }
      }
      var closest;
      var inst;
      for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
        closest = inst;
        if (parents.length) {
          precacheChildNodes(inst, node);
        }
      }
      return closest;
    }
    function getInstanceFromNode(node) {
      var inst = getClosestInstanceFromNode(node);
      if (inst != null && inst._hostNode === node) {
        return inst;
      } else {
        return null;
      }
    }
    function getNodeFromInstance(inst) {
      !(inst._hostNode !== undefined)
        ? false
          ? invariant(false, "getNodeFromInstance: Invalid argument.")
          : _prodInvariant("33")
        : void 0;
      if (inst._hostNode) {
        return inst._hostNode;
      }
      var parents = [];
      while (!inst._hostNode) {
        parents.push(inst);
        !inst._hostParent
          ? false
            ? invariant(
                false,
                "React DOM tree root should always have a node reference."
              )
            : _prodInvariant("34")
          : void 0;
        inst = inst._hostParent;
      }
      for (; parents.length; inst = parents.pop()) {
        precacheChildNodes(inst, inst._hostNode);
      }
      return inst._hostNode;
    }
    var ReactDOMComponentTree = {
      getClosestInstanceFromNode: getClosestInstanceFromNode,
      getInstanceFromNode: getInstanceFromNode,
      getNodeFromInstance: getNodeFromInstance,
      precacheChildNodes: precacheChildNodes,
      precacheNode: precacheNode,
      uncacheNode: uncacheNode
    };
    module.exports = ReactDOMComponentTree;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var canUseDOM = !!(
      typeof window !== "undefined" &&
      window.document &&
      window.document.createElement
    );
    var ExecutionEnvironment = {
      canUseDOM: canUseDOM,
      canUseWorkers: typeof Worker !== "undefined",
      canUseEventListeners:
        canUseDOM && !!(window.addEventListener || window.attachEvent),
      canUseViewport: canUseDOM && !!window.screen,
      isInWorker: !canUseDOM
    };
    module.exports = ExecutionEnvironment;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var debugTool = null;
    if (false) {
      var ReactDebugTool = require("./ReactDebugTool");
      debugTool = ReactDebugTool;
    }
    module.exports = { debugTool: debugTool };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function makeEmptyFunction(arg) {
      return function() {
        return arg;
      };
    }
    var emptyFunction = function emptyFunction() {};
    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function() {
      return this;
    };
    emptyFunction.thatReturnsArgument = function(arg) {
      return arg;
    };
    module.exports = emptyFunction;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var CallbackQueue = __webpack_require__(76);
    var PooledClass = __webpack_require__(17);
    var ReactFeatureFlags = __webpack_require__(81);
    var ReactReconciler = __webpack_require__(20);
    var Transaction = __webpack_require__(34);
    var invariant = __webpack_require__(0);
    var dirtyComponents = [];
    var updateBatchNumber = 0;
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      !(ReactUpdates.ReactReconcileTransaction && batchingStrategy)
        ? false
          ? invariant(
              false,
              "ReactUpdates: must inject a reconcile transaction class and batching strategy"
            )
          : _prodInvariant("123")
        : void 0;
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
        true
      );
    }
    _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(
          this.reconcileTransaction
        );
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.perform.call(
          this,
          this.reconcileTransaction.perform,
          this.reconcileTransaction,
          method,
          scope,
          a
        );
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
      ensureInjected();
      return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      !(len === dirtyComponents.length)
        ? false
          ? invariant(
              false,
              "Expected flush transaction's stored dirty-components length (%s) to match dirty-components array length (%s).",
              len,
              dirtyComponents.length
            )
          : _prodInvariant("124", len, dirtyComponents.length)
        : void 0;
      dirtyComponents.sort(mountOrderComparator);
      updateBatchNumber++;
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        var markerName;
        if (ReactFeatureFlags.logTopLevelRenders) {
          var namedComponent = component;
          if (component._currentElement.type.isReactTopLevelWrapper) {
            namedComponent = component._renderedComponent;
          }
          markerName = "React update: " + namedComponent.getName();
          console.time(markerName);
        }
        ReactReconciler.performUpdateIfNecessary(
          component,
          transaction.reconcileTransaction,
          updateBatchNumber
        );
        if (markerName) {
          console.timeEnd(markerName);
        }
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(
              callbacks[j],
              component.getPublicInstance()
            );
          }
        }
      }
    }
    var flushBatchedUpdates = function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    function enqueueUpdate(component) {
      ensureInjected();
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
      }
      dirtyComponents.push(component);
      if (component._updateBatchNumber == null) {
        component._updateBatchNumber = updateBatchNumber + 1;
      }
    }
    function asap(callback, context) {
      invariant(
        batchingStrategy.isBatchingUpdates,
        "ReactUpdates.asap: Can't enqueue an asap callback in a context where" +
          "updates are not being batched."
      );
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        !ReconcileTransaction
          ? false
            ? invariant(
                false,
                "ReactUpdates: must provide a reconcile transaction class"
              )
            : _prodInvariant("126")
          : void 0;
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        !_batchingStrategy
          ? false
            ? invariant(false, "ReactUpdates: must provide a batching strategy")
            : _prodInvariant("127")
          : void 0;
        !(typeof _batchingStrategy.batchedUpdates === "function")
          ? false
            ? invariant(
                false,
                "ReactUpdates: must provide a batchedUpdates() function"
              )
            : _prodInvariant("128")
          : void 0;
        !(typeof _batchingStrategy.isBatchingUpdates === "boolean")
          ? false
            ? invariant(
                false,
                "ReactUpdates: must provide an isBatchingUpdates boolean attribute"
              )
            : _prodInvariant("129")
          : void 0;
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var PooledClass = __webpack_require__(17);
    var emptyFunction = __webpack_require__(10);
    var warning = __webpack_require__(4);
    var didWarnForAddedNewProperty = false;
    var isProxySupported = typeof Proxy === "function";
    var shouldBeReleasedProperties = [
      "dispatchConfig",
      "_targetInst",
      "nativeEvent",
      "isDefaultPrevented",
      "isPropagationStopped",
      "_dispatchListeners",
      "_dispatchInstances"
    ];
    var EventInterface = {
      type: null,
      target: null,
      currentTarget: emptyFunction.thatReturnsNull,
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };
    function SyntheticEvent(
      dispatchConfig,
      targetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      if (false) {
        delete this.nativeEvent;
        delete this.preventDefault;
        delete this.stopPropagation;
      }
      this.dispatchConfig = dispatchConfig;
      this._targetInst = targetInst;
      this.nativeEvent = nativeEvent;
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        if (false) {
          delete this[propName];
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          if (propName === "target") {
            this.target = nativeEventTarget;
          } else {
            this[propName] = nativeEvent[propName];
          }
        }
      }
      var defaultPrevented =
        nativeEvent.defaultPrevented != null
          ? nativeEvent.defaultPrevented
          : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      } else {
        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsFalse;
      return this;
    }
    _assign(SyntheticEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.preventDefault) {
          event.preventDefault();
        } else if (typeof event.returnValue !== "unknown") {
          event.returnValue = false;
        }
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.stopPropagation) {
          event.stopPropagation();
        } else if (typeof event.cancelBubble !== "unknown") {
          event.cancelBubble = true;
        }
        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
      },
      persist: function() {
        this.isPersistent = emptyFunction.thatReturnsTrue;
      },
      isPersistent: emptyFunction.thatReturnsFalse,
      destructor: function() {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          if (false) {
            Object.defineProperty(
              this,
              propName,
              getPooledWarningPropertyDefinition(propName, Interface[propName])
            );
          } else {
            this[propName] = null;
          }
        }
        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
          this[shouldBeReleasedProperties[i]] = null;
        }
        if (false) {
          Object.defineProperty(
            this,
            "nativeEvent",
            getPooledWarningPropertyDefinition("nativeEvent", null)
          );
          Object.defineProperty(
            this,
            "preventDefault",
            getPooledWarningPropertyDefinition("preventDefault", emptyFunction)
          );
          Object.defineProperty(
            this,
            "stopPropagation",
            getPooledWarningPropertyDefinition("stopPropagation", emptyFunction)
          );
        }
      }
    });
    SyntheticEvent.Interface = EventInterface;
    SyntheticEvent.augmentClass = function(Class, Interface) {
      var Super = this;
      var E = function() {};
      E.prototype = Super.prototype;
      var prototype = new E();
      _assign(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = _assign({}, Super.Interface, Interface);
      Class.augmentClass = Super.augmentClass;
      PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
    };
    if (false) {
      if (isProxySupported) {
        SyntheticEvent = new Proxy(SyntheticEvent, {
          construct: function(target, args) {
            return this.apply(target, Object.create(target.prototype), args);
          },
          apply: function(constructor, that, args) {
            return new Proxy(constructor.apply(that, args), {
              set: function(target, prop, value) {
                if (
                  prop !== "isPersistent" &&
                  !target.constructor.Interface.hasOwnProperty(prop) &&
                  shouldBeReleasedProperties.indexOf(prop) === -1
                ) {
                  process.env.NODE_ENV !== "production"
                    ? warning(
                        didWarnForAddedNewProperty || target.isPersistent(),
                        "This synthetic event is reused for performance reasons. If you're " +
                          "seeing this, you're adding a new property in the synthetic event object. " +
                          "The property is never released. See " +
                          "https://fb.me/react-event-pooling for more information."
                      )
                    : void 0;
                  didWarnForAddedNewProperty = true;
                }
                target[prop] = value;
                return true;
              }
            });
          }
        });
      }
    }
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
    module.exports = SyntheticEvent;
    function getPooledWarningPropertyDefinition(propName, getVal) {
      var isFunction = typeof getVal === "function";
      return { configurable: true, set: set, get: get };
      function set(val) {
        var action = isFunction ? "setting the method" : "setting the property";
        warn(action, "This is effectively a no-op");
        return val;
      }
      function get() {
        var action = isFunction
          ? "accessing the method"
          : "accessing the property";
        var result = isFunction
          ? "This is a no-op function"
          : "This is set to null";
        warn(action, result);
        return getVal;
      }
      function warn(action, result) {
        var warningCondition = false;
        false
          ? warning(
              warningCondition,
              "This synthetic event is reused for performance reasons. If you're seeing this, " +
                "you're %s `%s` on a released/nullified synthetic event. %s. " +
                "If you must keep the original synthetic event around, use event.persist(). " +
                "See https://fb.me/react-event-pooling for more information.",
              action,
              propName,
              result
            )
          : void 0;
      }
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactCurrentOwner = { current: null };
    module.exports = ReactCurrentOwner;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateEntity = updateEntity;
    exports.removeEntity = removeEntity;
    exports.removeSelectedEntity = removeSelectedEntity;
    exports.cloneEntity = cloneEntity;
    exports.cloneSelectedEntity = cloneSelectedEntity;
    exports.getEntityClipboardRepresentation = getEntityClipboardRepresentation;
    exports.getComponentClipboardRepresentation = getComponentClipboardRepresentation;
    exports.printEntity = printEntity;
    exports.createEntity = createEntity;
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _utils = __webpack_require__(15);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Events = __webpack_require__(5);
    function updateEntity(entity, propertyName, value) {
      var splitName;
      if (propertyName.indexOf(".") !== -1) {
        splitName = propertyName.split(".");
        if (value === null || value === undefined) {
          var parameters = entity.getAttribute(splitName[0]);
          delete parameters[splitName[1]];
          entity.setAttribute(splitName[0], parameters);
        } else {
          entity.setAttribute(splitName[0], splitName[1], value);
        }
      } else {
        if (value === null || value === undefined) {
          entity.removeAttribute(propertyName);
        } else {
          entity.setAttribute(propertyName, value);
        }
      }
      Events.emit("entityupdate", {
        component: splitName ? splitName[0] : propertyName,
        entity: entity,
        property: splitName ? splitName[1] : "",
        value: value
      });
    }
    function removeEntity(entity, force) {
      if (entity) {
        if (
          force === true ||
          confirm(
            "Do you really want to remove entity `" +
              (entity.id || entity.tagName) +
              "`?"
          )
        ) {
          var closest = findClosestEntity(entity);
          AFRAME.INSPECTOR.removeObject(entity.object3D);
          entity.parentNode.removeChild(entity);
          AFRAME.INSPECTOR.selectEntity(closest);
        }
      }
    }
    function findClosestEntity(entity) {
      var nextEntity = entity.nextElementSibling;
      while (nextEntity && (!nextEntity.isEntity || nextEntity.isInspector)) {
        nextEntity = nextEntity.nextElementSibling;
      }
      if (nextEntity && nextEntity.isEntity && !nextEntity.isInspector) {
        return nextEntity;
      }
      var prevEntity = entity.previousElementSibling;
      while (prevEntity && (!prevEntity.isEntity || prevEntity.isInspector)) {
        prevEntity = prevEntity.previousElementSibling;
      }
      if (prevEntity && prevEntity.isEntity && !prevEntity.isInspector) {
        return prevEntity;
      }
      return null;
    }
    function removeSelectedEntity(force) {
      if (AFRAME.INSPECTOR.selectedEntity) {
        removeEntity(AFRAME.INSPECTOR.selectedEntity, force);
      }
    }
    function insertAfter(newNode, referenceNode) {
      if (!referenceNode.parentNode) {
        referenceNode = AFRAME.INSPECTOR.selectedEntity;
      }
      if (!referenceNode) {
        AFRAME.INSPECTOR.sceneEl.appendChild(newNode);
      } else {
        referenceNode.parentNode.insertBefore(
          newNode,
          referenceNode.nextSibling
        );
      }
    }
    function cloneEntity(entity) {
      entity.flushToDOM();
      var clone = entity.cloneNode(true);
      clone.addEventListener("loaded", function(e) {
        AFRAME.INSPECTOR.selectEntity(clone);
        Events.emit("entityclone");
      });
      if (entity.id) {
        clone.id = getUniqueId(entity.id);
      }
      insertAfter(clone, entity);
    }
    function cloneSelectedEntity() {
      if (AFRAME.INSPECTOR.selectedEntity) {
        cloneEntity(AFRAME.INSPECTOR.selectedEntity);
      }
    }
    function getEntityClipboardRepresentation(entity) {
      var clone = prepareForSerialization(entity);
      return clone.outerHTML;
    }
    function prepareForSerialization(entity) {
      var clone = entity.cloneNode(false);
      var children = entity.childNodes;
      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        if (
          child.nodeType !== Node.ELEMENT_NODE ||
          (!child.hasAttribute("aframe-injected") &&
            !child.hasAttribute("data-aframe-inspector") &&
            !child.hasAttribute("data-aframe-canvas"))
        ) {
          clone.appendChild(prepareForSerialization(children[i]));
        }
      }
      optimizeComponents(clone, entity);
      return clone;
    }
    function optimizeComponents(copy, source) {
      var removeAttribute = HTMLElement.prototype.removeAttribute;
      var setAttribute = HTMLElement.prototype.setAttribute;
      var components = source.components || {};
      Object.keys(components).forEach(function(name) {
        var component = components[name];
        var result = getImplicitValue(component, source);
        var isInherited = result[1];
        var implicitValue = result[0];
        var currentValue = source.getAttribute(name);
        var optimalUpdate = getOptimalUpdate(
          component,
          implicitValue,
          currentValue
        );
        var doesNotNeedUpdate = optimalUpdate === null;
        if (isInherited && doesNotNeedUpdate) {
          removeAttribute.call(copy, name);
        } else {
          var schema = component.schema;
          var value = stringifyComponentValue(schema, optimalUpdate);
          setAttribute.call(copy, name, value);
        }
      });
    }
    function stringifyComponentValue(schema, data) {
      data = typeof data === "undefined" ? {} : data;
      if (data === null) {
        return "";
      }
      return (isSingleProperty(schema) ? _single : _multi)();
      function _single() {
        return schema.stringify(data);
      }
      function _multi() {
        var propertyBag = {};
        Object.keys(data).forEach(function(name) {
          if (schema[name]) {
            propertyBag[name] = schema[name].stringify(data[name]);
          }
        });
        return AFRAME.utils.styleParser.stringify(propertyBag);
      }
    }
    function getImplicitValue(component, source) {
      var isInherited = false;
      var value = (isSingleProperty(component.schema) ? _single : _multi)();
      return [value, isInherited];
      function _single() {
        var value = getMixedValue(component, null, source);
        if (value === undefined) {
          value = getInjectedValue(component, null, source);
        }
        if (value !== undefined) {
          isInherited = true;
        } else {
          value = getDefaultValue(component, null, source);
        }
        if (value !== undefined) {
          return component.schema.parse(value);
        }
        return value;
      }
      function _multi() {
        var value;
        Object.keys(component.schema).forEach(function(propertyName) {
          var propertyValue = getFromAttribute(component, propertyName, source);
          if (propertyValue === undefined) {
            propertyValue = getMixedValue(component, propertyName, source);
          }
          if (propertyValue === undefined) {
            propertyValue = getInjectedValue(component, propertyName, source);
          }
          if (propertyValue !== undefined) {
            isInherited = isInherited || true;
          } else {
            propertyValue = getDefaultValue(component, propertyName, source);
          }
          if (propertyValue !== undefined) {
            var parse = component.schema[propertyName].parse;
            value = value || {};
            value[propertyName] = parse(propertyValue);
          }
        });
        return value;
      }
    }
    function getFromAttribute(component, propertyName, source) {
      var value;
      var mappings = source.mappings || {};
      var route = component.name + "." + propertyName;
      var primitiveAttribute = findAttribute(mappings, route);
      if (primitiveAttribute && source.hasAttribute(primitiveAttribute)) {
        value = source.getAttribute(primitiveAttribute);
      }
      return value;
      function findAttribute(mappings, route) {
        var attributes = Object.keys(mappings);
        for (var i = 0, l = attributes.length; i < l; i++) {
          var attribute = attributes[i];
          if (mappings[attribute] === route) {
            return attribute;
          }
        }
        return undefined;
      }
    }
    function getMixedValue(component, propertyName, source) {
      var value;
      var reversedMixins = source.mixinEls.reverse();
      for (var i = 0; value === undefined && i < reversedMixins.length; i++) {
        var mixin = reversedMixins[i];
        if (mixin.attributes.hasOwnProperty(component.name)) {
          if (!propertyName) {
            value = mixin.getAttribute(component.name);
          } else {
            value = mixin.getAttribute(component.name)[propertyName];
          }
        }
      }
      return value;
    }
    function getInjectedValue(component, propertyName, source) {
      var value;
      var primitiveDefaults = source.defaultComponentsFromPrimitive || {};
      var aFrameDefaults = source.defaultComponents || {};
      var defaultSources = [primitiveDefaults, aFrameDefaults];
      for (var i = 0; value === undefined && i < defaultSources.length; i++) {
        var defaults = defaultSources[i];
        if (defaults.hasOwnProperty(component.name)) {
          if (!propertyName) {
            value = defaults[component.name];
          } else {
            value = defaults[component.name][propertyName];
          }
        }
      }
      return value;
    }
    function getDefaultValue(component, propertyName, source) {
      if (!propertyName) {
        return component.schema.default;
      }
      return component.schema[propertyName].default;
    }
    function getOptimalUpdate(component, implicit, reference) {
      if ((0, _utils.equal)(implicit, reference)) {
        return null;
      }
      if (isSingleProperty(component.schema)) {
        return reference;
      }
      var optimal = {};
      Object.keys(reference).forEach(function(key) {
        var needsUpdate = !(0, _utils.equal)(reference[key], implicit[key]);
        if (needsUpdate) {
          optimal[key] = reference[key];
        }
      });
      return optimal;
    }
    function isSingleProperty(schema) {
      return AFRAME.schema.isSingleProperty(schema);
    }
    function getUniqueId(baseId) {
      if (!document.getElementById(baseId)) {
        return baseId;
      }
      var i = 2;
      var groups = baseId.match(/(\w+)-(\d+)/);
      if (groups) {
        baseId = groups[1];
        i = groups[2];
      }
      while (document.getElementById(baseId + "-" + i)) {
        i++;
      }
      return baseId + "-" + i;
    }
    function getComponentClipboardRepresentation(entity, componentName) {
      function getModifiedProperties(entity, componentName) {
        var data = entity.components[componentName].data;
        var defaultData = entity.components[componentName].schema;
        var diff = {};
        for (var key in data) {
          if (!defaultData[key]) {
            continue;
          }
          var defaultValue = defaultData[key].default;
          var currentValue = data[key];
          if ((currentValue || defaultValue) && currentValue !== defaultValue) {
            diff[key] = data[key];
          }
        }
        return diff;
      }
      var diff = getModifiedProperties(entity, componentName);
      var attributes = AFRAME.utils.styleParser
        .stringify(diff)
        .replace(/;|:/g, "$& ");
      return componentName + '="' + attributes + '"';
    }
    function isEmpty(string) {
      return string === null || string === "";
    }
    var ICONS = {
      camera: "fa-camera",
      mesh: "fa-cube",
      light: "fa-lightbulb-o",
      text: "fa-font"
    };
    function printEntity(entity, onDoubleClick) {
      if (!entity) {
        return "";
      }
      var icons = "";
      for (var objType in ICONS) {
        if (!entity.getObject3D(objType)) {
          continue;
        }
        icons +=
          '&nbsp;<i class="fa ' +
          ICONS[objType] +
          '" title="' +
          objType +
          '"></i>';
      }
      var entityName = entity.id;
      var type = "id";
      if (!entity.isScene && !entityName && entity.getAttribute("class")) {
        entityName = entity.getAttribute("class").split(" ")[0];
        type = "class";
      } else if (
        !entity.isScene &&
        !entityName &&
        entity.getAttribute("mixin")
      ) {
        entityName = entity.getAttribute("mixin").split(" ")[0];
        type = "mixin";
      }
      return _react2.default.createElement(
        "span",
        { className: "entityPrint", onDoubleClick: onDoubleClick },
        _react2.default.createElement(
          "span",
          { className: "entityTagName" },
          "<" + entity.tagName.toLowerCase()
        ),
        entityName &&
          _react2.default.createElement(
            "span",
            { className: "entityName", "data-entity-name-type": type },
            "\xA0",
            entityName
          ),
        !!icons &&
          _react2.default.createElement("span", {
            className: "entityIcons",
            dangerouslySetInnerHTML: { __html: icons }
          }),
        _react2.default.createElement(
          "span",
          { className: "entityCloseTag" },
          ">"
        )
      );
    }
    function createEntity(definition, cb) {
      var entity = document.createElement(definition.element);
      for (var attr in definition.components) {
        entity.setAttribute(attr, definition.components[attr]);
      }
      entity.addEventListener("loaded", function() {
        Events.emit("entitycreated", entity);
        cb(entity);
      });
      AFRAME.scenes[0].appendChild(entity);
      return entity;
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof =
      typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
        ? function(obj) {
            return typeof obj;
          }
        : function(obj) {
            return obj &&
              typeof Symbol === "function" &&
              obj.constructor === Symbol &&
              obj !== Symbol.prototype
              ? "symbol"
              : typeof obj;
          };
    function getNumber(value) {
      return parseFloat(value.toFixed(3));
    }
    function getMajorVersion(version) {
      var major = version.split(".");
      var clean = false;
      for (var i = 0; i < major.length; i++) {
        if (clean) {
          major[i] = 0;
        } else if (major[i] !== "0") {
          clean = true;
        }
      }
      return major.join(".");
    }
    function equal(var1, var2) {
      var keys1;
      var keys2;
      var type1 = typeof var1 === "undefined" ? "undefined" : _typeof(var1);
      var type2 = typeof var2 === "undefined" ? "undefined" : _typeof(var2);
      if (type1 !== type2) {
        return false;
      }
      if (type1 !== "object" || var1 === null || var2 === null) {
        return var1 === var2;
      }
      keys1 = Object.keys(var1);
      keys2 = Object.keys(var2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (var i = 0; i < keys1.length; i++) {
        if (!equal(var1[keys1[i]], var2[keys2[i]])) {
          return false;
        }
      }
      return true;
    }
    function getOS() {
      var userAgent = window.navigator.userAgent;
      var platform = window.navigator.platform;
      var macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
      var windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"];
      var iosPlatforms = ["iPhone", "iPad", "iPod"];
      var os = null;
      if (macosPlatforms.indexOf(platform) !== -1) {
        os = "macos";
      } else if (iosPlatforms.indexOf(platform) !== -1) {
        os = "ios";
      } else if (windowsPlatforms.indexOf(platform) !== -1) {
        os = "windows";
      } else if (/Android/.test(userAgent)) {
        os = "android";
      } else if (!os && /Linux/.test(platform)) {
        os = "linux";
      }
      return os;
    }
    function injectCSS(url) {
      var link = document.createElement("link");
      link.href = url;
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      link.setAttribute("data-aframe-inspector", "style");
      document.head.appendChild(link);
    }
    function injectJS(url, onLoad, onError) {
      var link = document.createElement("script");
      link.src = url;
      link.charset = "utf-8";
      link.setAttribute("data-aframe-inspector", "style");
      if (onLoad) {
        link.addEventListener("load", onLoad);
      }
      if (onError) {
        link.addEventListener("error", onError);
      }
      document.head.appendChild(link);
    }
    function saveString(text, filename, mimeType) {
      saveBlob(new Blob([text], { type: mimeType }), filename);
    }
    function saveBlob(blob, filename) {
      var link = document.createElement("a");
      link.style.display = "none";
      document.body.appendChild(link);
      link.href = URL.createObjectURL(blob);
      link.download = filename || "ascene.html";
      link.click();
    }
    module.exports = {
      equal: equal,
      getNumber: getNumber,
      getMajorVersion: getMajorVersion,
      getOS: getOS,
      os: getOS(),
      injectCSS: injectCSS,
      injectJS: injectJS,
      saveString: saveString,
      saveBlob: saveBlob
    };
  },
  function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
Copyright (c) 2017 Jed Watson.
Licensed under the MIT License (MIT), see
http://jedwatson.github.io/classnames
*/ (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg) continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg) && arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          } else if (argType === "object") {
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (true) {
        !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
        (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
          return classNames;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {
        window.classNames = classNames;
      }
    })();
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function(a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      !(instance instanceof Klass)
        ? false
          ? invariant(
              false,
              "Trying to release an instance into a pool of a different type."
            )
          : _prodInvariant("25")
        : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMNamespaces = __webpack_require__(41);
    var setInnerHTML = __webpack_require__(36);
    var createMicrosoftUnsafeLocalFunction = __webpack_require__(49);
    var setTextContent = __webpack_require__(94);
    var ELEMENT_NODE_TYPE = 1;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var enableLazy =
      (typeof document !== "undefined" &&
        typeof document.documentMode === "number") ||
      (typeof navigator !== "undefined" &&
        typeof navigator.userAgent === "string" &&
        /\bEdge\/\d/.test(navigator.userAgent));
    function insertTreeChildren(tree) {
      if (!enableLazy) {
        return;
      }
      var node = tree.node;
      var children = tree.children;
      if (children.length) {
        for (var i = 0; i < children.length; i++) {
          insertTreeBefore(node, children[i], null);
        }
      } else if (tree.html != null) {
        setInnerHTML(node, tree.html);
      } else if (tree.text != null) {
        setTextContent(node, tree.text);
      }
    }
    var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function(
      parentNode,
      tree,
      referenceNode
    ) {
      if (
        tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE ||
        (tree.node.nodeType === ELEMENT_NODE_TYPE &&
          tree.node.nodeName.toLowerCase() === "object" &&
          (tree.node.namespaceURI == null ||
            tree.node.namespaceURI === DOMNamespaces.html))
      ) {
        insertTreeChildren(tree);
        parentNode.insertBefore(tree.node, referenceNode);
      } else {
        parentNode.insertBefore(tree.node, referenceNode);
        insertTreeChildren(tree);
      }
    });
    function replaceChildWithTree(oldNode, newTree) {
      oldNode.parentNode.replaceChild(newTree.node, oldNode);
      insertTreeChildren(newTree);
    }
    function queueChild(parentTree, childTree) {
      if (enableLazy) {
        parentTree.children.push(childTree);
      } else {
        parentTree.node.appendChild(childTree.node);
      }
    }
    function queueHTML(tree, html) {
      if (enableLazy) {
        tree.html = html;
      } else {
        setInnerHTML(tree.node, html);
      }
    }
    function queueText(tree, text) {
      if (enableLazy) {
        tree.text = text;
      } else {
        setTextContent(tree.node, text);
      }
    }
    function toString() {
      return this.node.nodeName;
    }
    function DOMLazyTree(node) {
      return {
        node: node,
        children: [],
        html: null,
        text: null,
        toString: toString
      };
    }
    DOMLazyTree.insertTreeBefore = insertTreeBefore;
    DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
    DOMLazyTree.queueChild = queueChild;
    DOMLazyTree.queueHTML = queueHTML;
    DOMLazyTree.queueText = queueText;
    module.exports = DOMLazyTree;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_PROPERTY: 0x1,
      HAS_BOOLEAN_VALUE: 0x4,
      HAS_NUMERIC_VALUE: 0x8,
      HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Injection = DOMPropertyInjection;
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNamespaces =
          domPropertyConfig.DOMAttributeNamespaces || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(
            domPropertyConfig.isCustomAttribute
          );
        }
        for (var propName in Properties) {
          !!DOMProperty.properties.hasOwnProperty(propName)
            ? false
              ? invariant(
                  false,
                  "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",
                  propName
                )
              : _prodInvariant("48", propName)
            : void 0;
          var lowerCased = propName.toLowerCase();
          var propConfig = Properties[propName];
          var propertyInfo = {
            attributeName: lowerCased,
            attributeNamespace: null,
            propertyName: propName,
            mutationMethod: null,
            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
            hasPositiveNumericValue: checkMask(
              propConfig,
              Injection.HAS_POSITIVE_NUMERIC_VALUE
            ),
            hasOverloadedBooleanValue: checkMask(
              propConfig,
              Injection.HAS_OVERLOADED_BOOLEAN_VALUE
            )
          };
          !(
            propertyInfo.hasBooleanValue +
              propertyInfo.hasNumericValue +
              propertyInfo.hasOverloadedBooleanValue <=
            1
          )
            ? false
              ? invariant(
                  false,
                  "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",
                  propName
                )
              : _prodInvariant("50", propName)
            : void 0;
          if (false) {
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
          }
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            propertyInfo.attributeName = attributeName;
            if (false) {
              DOMProperty.getPossibleStandardName[attributeName] = propName;
            }
          }
          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
          }
          if (DOMPropertyNames.hasOwnProperty(propName)) {
            propertyInfo.propertyName = DOMPropertyNames[propName];
          }
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            propertyInfo.mutationMethod = DOMMutationMethods[propName];
          }
          DOMProperty.properties[propName] = propertyInfo;
        }
      }
    };
    var ATTRIBUTE_NAME_START_CHAR =
      ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: "data-reactid",
      ROOT_ATTRIBUTE_NAME: "data-reactroot",
      ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
      ATTRIBUTE_NAME_CHAR:
        ATTRIBUTE_NAME_START_CHAR +
        "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
      properties: {},
      getPossibleStandardName: false ? { autofocus: "autoFocus" } : null,
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (
          var i = 0;
          i < DOMProperty._isCustomAttributeFunctions.length;
          i++
        ) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactRef = __webpack_require__(206);
    var ReactInstrumentation = __webpack_require__(9);
    var warning = __webpack_require__(4);
    function attachRefs() {
      ReactRef.attachRefs(this, this._currentElement);
    }
    var ReactReconciler = {
      mountComponent: function(
        internalInstance,
        transaction,
        hostParent,
        hostContainerInfo,
        context,
        parentDebugID
      ) {
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeMountComponent(
              internalInstance._debugID,
              internalInstance._currentElement,
              parentDebugID
            );
          }
        }
        var markup = internalInstance.mountComponent(
          transaction,
          hostParent,
          hostContainerInfo,
          context,
          parentDebugID
        );
        if (
          internalInstance._currentElement &&
          internalInstance._currentElement.ref != null
        ) {
          transaction
            .getReactMountReady()
            .enqueue(attachRefs, internalInstance);
        }
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onMountComponent(
              internalInstance._debugID
            );
          }
        }
        return markup;
      },
      getHostNode: function(internalInstance) {
        return internalInstance.getHostNode();
      },
      unmountComponent: function(internalInstance, safely) {
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUnmountComponent(
              internalInstance._debugID
            );
          }
        }
        ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
        internalInstance.unmountComponent(safely);
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUnmountComponent(
              internalInstance._debugID
            );
          }
        }
      },
      receiveComponent: function(
        internalInstance,
        nextElement,
        transaction,
        context
      ) {
        var prevElement = internalInstance._currentElement;
        if (
          nextElement === prevElement &&
          context === internalInstance._context
        ) {
          return;
        }
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(
              internalInstance._debugID,
              nextElement
            );
          }
        }
        var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
        if (refsChanged) {
          ReactRef.detachRefs(internalInstance, prevElement);
        }
        internalInstance.receiveComponent(nextElement, transaction, context);
        if (
          refsChanged &&
          internalInstance._currentElement &&
          internalInstance._currentElement.ref != null
        ) {
          transaction
            .getReactMountReady()
            .enqueue(attachRefs, internalInstance);
        }
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(
              internalInstance._debugID
            );
          }
        }
      },
      performUpdateIfNecessary: function(
        internalInstance,
        transaction,
        updateBatchNumber
      ) {
        if (internalInstance._updateBatchNumber !== updateBatchNumber) {
          false
            ? warning(
                internalInstance._updateBatchNumber == null ||
                  internalInstance._updateBatchNumber === updateBatchNumber + 1,
                "performUpdateIfNecessary: Unexpected batch number (current %s, " +
                  "pending %s)",
                updateBatchNumber,
                internalInstance._updateBatchNumber
              )
            : void 0;
          return;
        }
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(
              internalInstance._debugID,
              internalInstance._currentElement
            );
          }
        }
        internalInstance.performUpdateIfNecessary(transaction);
        if (false) {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(
              internalInstance._debugID
            );
          }
        }
      }
    };
    module.exports = ReactReconciler;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var ReactBaseClasses = __webpack_require__(100);
    var ReactChildren = __webpack_require__(240);
    var ReactDOMFactories = __webpack_require__(241);
    var ReactElement = __webpack_require__(22);
    var ReactPropTypes = __webpack_require__(242);
    var ReactVersion = __webpack_require__(243);
    var createReactClass = __webpack_require__(244);
    var onlyChild = __webpack_require__(248);
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if (false) {
      var lowPriorityWarning = require("./lowPriorityWarning");
      var canDefineProperty = require("./canDefineProperty");
      var ReactElementValidator = require("./ReactElementValidator");
      var didWarnPropTypesDeprecated = false;
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var __spread = _assign;
    var createMixin = function(mixin) {
      return mixin;
    };
    if (false) {
      var warnedForSpread = false;
      var warnedForCreateMixin = false;
      __spread = function() {
        lowPriorityWarning(
          warnedForSpread,
          "React.__spread is deprecated and should not be used. Use " +
            "Object.assign directly or another helper function with similar " +
            "semantics. You may be seeing this warning due to your compiler. " +
            "See https://fb.me/react-spread-deprecation for more details."
        );
        warnedForSpread = true;
        return _assign.apply(null, arguments);
      };
      createMixin = function(mixin) {
        lowPriorityWarning(
          warnedForCreateMixin,
          "React.createMixin is deprecated and should not be used. " +
            "In React v16.0, it will be removed. " +
            "You can use this mixin directly instead. " +
            "See https://fb.me/createmixin-was-never-implemented for more info."
        );
        warnedForCreateMixin = true;
        return mixin;
      };
    }
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        toArray: ReactChildren.toArray,
        only: onlyChild
      },
      Component: ReactBaseClasses.Component,
      PureComponent: ReactBaseClasses.PureComponent,
      createElement: createElement,
      cloneElement: cloneElement,
      isValidElement: ReactElement.isValidElement,
      PropTypes: ReactPropTypes,
      createClass: createReactClass,
      createFactory: createFactory,
      createMixin: createMixin,
      DOM: ReactDOMFactories,
      version: ReactVersion,
      __spread: __spread
    };
    if (false) {
      var warnedForCreateClass = false;
      if (canDefineProperty) {
        Object.defineProperty(React, "PropTypes", {
          get: function() {
            lowPriorityWarning(
              didWarnPropTypesDeprecated,
              "Accessing PropTypes via the main React package is deprecated," +
                " and will be removed in  React v16.0." +
                " Use the latest available v15.* prop-types package from npm instead." +
                " For info on usage, compatibility, migration and more, see " +
                "https://fb.me/prop-types-docs"
            );
            didWarnPropTypesDeprecated = true;
            return ReactPropTypes;
          }
        });
        Object.defineProperty(React, "createClass", {
          get: function() {
            lowPriorityWarning(
              warnedForCreateClass,
              "Accessing createClass via the main React package is deprecated," +
                " and will be removed in React v16.0." +
                " Use a plain JavaScript class instead. If you're not yet " +
                "ready to migrate, create-react-class v15.* is available " +
                "on npm as a temporary, drop-in replacement. " +
                "For more info see https://fb.me/react-create-class"
            );
            warnedForCreateClass = true;
            return createReactClass;
          }
        });
      }
      React.DOM = {};
      var warnedForFactories = false;
      Object.keys(ReactDOMFactories).forEach(function(factory) {
        React.DOM[factory] = function() {
          if (!warnedForFactories) {
            lowPriorityWarning(
              false,
              "Accessing factories like React.DOM.%s has been deprecated " +
                "and will be removed in v16.0+. Use the " +
                "react-dom-factories package instead. " +
                " Version 1.0 provides a drop-in replacement." +
                " For more info, see https://fb.me/react-dom-factories",
              factory
            );
            warnedForFactories = true;
          }
          return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
        };
      });
    }
    module.exports = React;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var ReactCurrentOwner = __webpack_require__(13);
    var warning = __webpack_require__(4);
    var canDefineProperty = __webpack_require__(104);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var REACT_ELEMENT_TYPE = __webpack_require__(102);
    var RESERVED_PROPS = { key: true, ref: true, __self: true, __source: true };
    var specialPropKeyWarningShown, specialPropRefWarningShown;
    function hasValidRef(config) {
      if (false) {
        if (hasOwnProperty.call(config, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      if (false) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          false
            ? warning(
                false,
                "%s: `key` is not a prop. Trying to access it will result " +
                  "in `undefined` being returned. If you need to access the same " +
                  "value within the child component, you should pass it as a different " +
                  "prop. (https://fb.me/react-special-props)",
                displayName
              )
            : void 0;
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          false
            ? warning(
                false,
                "%s: `ref` is not a prop. Trying to access it will result " +
                  "in `undefined` being returned. If you need to access the same " +
                  "value within the child component, you should pass it as a different " +
                  "prop. (https://fb.me/react-special-props)",
                displayName
              )
            : void 0;
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, "ref", {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    var ReactElement = function(type, key, ref, self, source, owner, props) {
      var element = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: ref,
        props: props,
        _owner: owner
      };
      if (false) {
        element._store = {};
        if (canDefineProperty) {
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
        } else {
          element._store.validated = false;
          element._self = self;
          element._source = source;
        }
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = "" + config.key;
        }
        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        for (propName in config) {
          if (
            hasOwnProperty.call(config, propName) &&
            !RESERVED_PROPS.hasOwnProperty(propName)
          ) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        if (false) {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      if (false) {
        if (key || ref) {
          if (
            typeof props.$$typeof === "undefined" ||
            props.$$typeof !== REACT_ELEMENT_TYPE
          ) {
            var displayName =
              typeof type === "function"
                ? type.displayName || type.name || "Unknown"
                : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(
        type,
        key,
        ref,
        self,
        source,
        ReactCurrentOwner.current,
        props
      );
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceKey = function(oldElement, newKey) {
      var newElement = ReactElement(
        oldElement.type,
        newKey,
        oldElement.ref,
        oldElement._self,
        oldElement._source,
        oldElement._owner,
        oldElement.props
      );
      return newElement;
    };
    ReactElement.cloneElement = function(element, config, children) {
      var propName;
      var props = _assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var self = element._self;
      var source = element._source;
      var owner = element._owner;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = "" + config.key;
        }
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (
            hasOwnProperty.call(config, propName) &&
            !RESERVED_PROPS.hasOwnProperty(propName)
          ) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return ReactElement(element.type, key, ref, self, source, owner, props);
    };
    ReactElement.isValidElement = function(object) {
      return (
        typeof object === "object" &&
        object !== null &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    };
    module.exports = ReactElement;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var NumberWidget = (function(_React$Component) {
      _inherits(NumberWidget, _React$Component);
      function NumberWidget(props) {
        _classCallCheck(this, NumberWidget);
        var _this = _possibleConstructorReturn(
          this,
          (NumberWidget.__proto__ || Object.getPrototypeOf(NumberWidget)).call(
            this,
            props
          )
        );
        _this.onMouseMove = function(event) {
          var currentValue = parseFloat(_this.state.value);
          var pointer = [event.clientX, event.clientY];
          var delta =
            pointer[0] -
            _this.prevPointer[0] -
            (pointer[1] - _this.prevPointer[1]);
          _this.distance += delta;
          var value =
            _this.onMouseDownValue +
            ((_this.distance / (event.shiftKey ? 5 : 50)) * _this.props.step) /
              2;
          value = Math.min(_this.props.max, Math.max(_this.props.min, value));
          if (currentValue !== value) {
            _this.setValue(value);
          }
          _this.prevPointer = [event.clientX, event.clientY];
        };
        _this.onMouseDown = function(event) {
          event.preventDefault();
          _this.distance = 0;
          _this.onMouseDownValue = _this.state.value;
          _this.prevPointer = [event.clientX, event.clientY];
          document.addEventListener("mousemove", _this.onMouseMove, false);
          document.addEventListener("mouseup", _this.onMouseUp, false);
        };
        _this.onMouseUp = function(event) {
          document.removeEventListener("mousemove", _this.onMouseMove, false);
          document.removeEventListener("mouseup", _this.onMouseUp, false);
          if (Math.abs(_this.distance) < 2) {
            _this.refs.input.focus();
            _this.refs.input.select();
          }
        };
        _this.onBlur = function() {
          _this.setValue(parseFloat(_this.refs.input.value));
          _this.setState({ class: "" });
        };
        _this.onChange = function(e) {
          _this.setState({
            value: e.target.value,
            displayValue: e.target.value
          });
        };
        _this.onKeyDown = function(event) {
          event.stopPropagation();
          if (event.keyCode === 13) {
            _this.setValue(parseFloat(_this.refs.input.value));
            _this.refs.input.blur();
            return;
          }
          if (event.keyCode === 38) {
            _this.setValue(parseFloat(_this.state.value) + 0.01);
            return;
          }
          if (event.keyCode === 40) {
            _this.setValue(parseFloat(_this.state.value) - 0.01);
            return;
          }
        };
        _this.state = {
          value: _this.props.value,
          displayValue:
            typeof _this.props.value === "number"
              ? _this.props.value.toFixed(_this.props.precision)
              : ""
        };
        return _this;
      }
      _createClass(NumberWidget, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.distance = 0;
            this.onMouseDownValue = 0;
            this.prevPointer = [0, 0];
            this.setValue(this.props.value);
            this.onBlur();
          }
        },
        {
          key: "setValue",
          value: function setValue(value) {
            if (value === this.state.value) return;
            if (value !== undefined) {
              if (this.props.precision === 0) {
                value = parseInt(value);
              } else {
                value = parseFloat(value);
              }
              if (value < this.props.min) {
                value = this.props.min;
              }
              if (value > this.props.max) {
                value = this.props.max;
              }
              this.setState({
                value: value,
                displayValue: value.toFixed(this.props.precision)
              });
              if (this.props.onChange) {
                this.props.onChange(
                  this.props.name,
                  parseFloat(value.toFixed(5))
                );
              }
            }
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (newProps.value !== this.state.value) {
              this.setState({
                value: newProps.value,
                displayValue: newProps.value.toFixed(this.props.precision)
              });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            return _react2.default.createElement("input", {
              ref: "input",
              className: "number",
              type: "text",
              value: this.state.displayValue,
              onKeyDown: this.onKeyDown,
              onChange: this.onChange,
              onMouseDown: this.onMouseDown,
              onFocus: this.onFocus,
              onBlur: this.onBlur
            });
          }
        }
      ]);
      return NumberWidget;
    })(_react2.default.Component);
    NumberWidget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      max: _propTypes2.default.number,
      min: _propTypes2.default.number,
      name: _propTypes2.default.string,
      onChange: _propTypes2.default.func,
      precision: _propTypes2.default.number,
      step: _propTypes2.default.number,
      value: _propTypes2.default.number
    };
    NumberWidget.defaultProps = {
      min: -Infinity,
      max: Infinity,
      value: 0,
      precision: 3,
      step: 1
    };
    exports.default = NumberWidget;
  },
  function(module, exports, __webpack_require__) {
    (function(global) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal =
        typeof global == "object" &&
        global &&
        global.Object === Object &&
        global;
      var freeSelf =
        typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max,
        nativeMin = Math.min;
      var now = function() {
        return root.Date.now();
      };
      function debounce(func, wait, options) {
        var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing
            ? nativeMax(toNumber(options.maxWait) || 0, wait)
            : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs,
            thisArg = lastThis;
          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;
          return maxing
            ? nativeMin(result, maxWait - timeSinceLastInvoke)
            : result;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;
          return (
            lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && timeSinceLastInvoke >= maxWait)
          );
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }
        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }
        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(),
            isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return (
          typeof value == "symbol" ||
          (isObjectLike(value) && objectToString.call(value) == symbolTag)
        );
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other =
            typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
          ? NAN
          : +value;
      }
      module.exports = debounce;
    }.call(exports, __webpack_require__(56)));
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var EventPluginRegistry = __webpack_require__(42);
    var EventPluginUtils = __webpack_require__(43);
    var ReactErrorUtils = __webpack_require__(47);
    var accumulateInto = __webpack_require__(87);
    var forEachAccumulated = __webpack_require__(88);
    var invariant = __webpack_require__(0);
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event, simulated) {
      if (event) {
        EventPluginUtils.executeDispatchesInOrder(event, simulated);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function(e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function(e) {
      return executeDispatchesAndRelease(e, false);
    };
    var getDictionaryKey = function(inst) {
      return "." + inst._rootNodeID;
    };
    function isInteractive(tag) {
      return (
        tag === "button" ||
        tag === "input" ||
        tag === "select" ||
        tag === "textarea"
      );
    }
    function shouldPreventMouseEvent(name, type, props) {
      switch (name) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
          return !!(props.disabled && isInteractive(type));
        default:
          return false;
      }
    }
    var EventPluginHub = {
      injection: {
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      putListener: function(inst, registrationName, listener) {
        !(typeof listener === "function")
          ? false
            ? invariant(
                false,
                "Expected %s listener to be a function, instead got type %s",
                registrationName,
                typeof listener
              )
            : _prodInvariant("94", registrationName, typeof listener)
          : void 0;
        var key = getDictionaryKey(inst);
        var bankForRegistrationName =
          listenerBank[registrationName] ||
          (listenerBank[registrationName] = {});
        bankForRegistrationName[key] = listener;
        var PluginModule =
          EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.didPutListener) {
          PluginModule.didPutListener(inst, registrationName, listener);
        }
      },
      getListener: function(inst, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (
          shouldPreventMouseEvent(
            registrationName,
            inst._currentElement.type,
            inst._currentElement.props
          )
        ) {
          return null;
        }
        var key = getDictionaryKey(inst);
        return bankForRegistrationName && bankForRegistrationName[key];
      },
      deleteListener: function(inst, registrationName) {
        var PluginModule =
          EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(inst, registrationName);
        }
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          var key = getDictionaryKey(inst);
          delete bankForRegistrationName[key];
        }
      },
      deleteAllListeners: function(inst) {
        var key = getDictionaryKey(inst);
        for (var registrationName in listenerBank) {
          if (!listenerBank.hasOwnProperty(registrationName)) {
            continue;
          }
          if (!listenerBank[registrationName][key]) {
            continue;
          }
          var PluginModule =
            EventPluginRegistry.registrationNameModules[registrationName];
          if (PluginModule && PluginModule.willDeleteListener) {
            PluginModule.willDeleteListener(inst, registrationName);
          }
          delete listenerBank[registrationName][key];
        }
      },
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function(simulated) {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        if (simulated) {
          forEachAccumulated(
            processingEventQueue,
            executeDispatchesAndReleaseSimulated
          );
        } else {
          forEachAccumulated(
            processingEventQueue,
            executeDispatchesAndReleaseTopLevel
          );
        }
        !!eventQueue
          ? false
            ? invariant(
                false,
                "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
              )
            : _prodInvariant("95")
          : void 0;
        ReactErrorUtils.rethrowCaughtError();
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPluginHub = __webpack_require__(25);
    var EventPluginUtils = __webpack_require__(43);
    var accumulateInto = __webpack_require__(87);
    var forEachAccumulated = __webpack_require__(88);
    var warning = __webpack_require__(4);
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName =
        event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(inst, registrationName);
    }
    function accumulateDirectionalDispatches(inst, phase, event) {
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(inst, "Dispatching inst must not be null")
          : void 0;
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(
          event._dispatchListeners,
          listener
        );
        event._dispatchInstances = accumulateInto(
          event._dispatchInstances,
          inst
        );
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginUtils.traverseTwoPhase(
          event._targetInst,
          accumulateDirectionalDispatches,
          event
        );
      }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        var targetInst = event._targetInst;
        var parentInst = targetInst
          ? EventPluginUtils.getParentInstance(targetInst)
          : null;
        EventPluginUtils.traverseTwoPhase(
          parentInst,
          accumulateDirectionalDispatches,
          event
        );
      }
    }
    function accumulateDispatches(inst, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(
            event._dispatchListeners,
            listener
          );
          event._dispatchInstances = accumulateInto(
            event._dispatchInstances,
            inst
          );
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, from, to) {
      EventPluginUtils.traverseEnterLeave(
        from,
        to,
        accumulateDispatches,
        leave,
        enter
      );
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactInstanceMap = {
      remove: function(key) {
        key._reactInternalInstance = undefined;
      },
      get: function(key) {
        return key._reactInternalInstance;
      },
      has: function(key) {
        return key._reactInternalInstance !== undefined;
      },
      set: function(key, value) {
        key._reactInternalInstance = value;
      }
    };
    module.exports = ReactInstanceMap;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var getEventTarget = __webpack_require__(52);
    var UIEventInterface = {
      view: function(event) {
        if (event.view) {
          return event.view;
        }
        var target = getEventTarget(event);
        if (target.window === target) {
          return target;
        }
        var doc = target.ownerDocument;
        if (doc) {
          return doc.defaultView || doc.parentWindow;
        } else {
          return window;
        }
      },
      detail: function(event) {
        return event.detail || 0;
      }
    };
    function SyntheticUIEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
    module.exports = SyntheticUIEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function reactProdInvariant(code) {
      var argCount = arguments.length - 1;
      var message =
        "Minified React error #" +
        code +
        "; visit " +
        "http://facebook.github.io/react/docs/error-decoder.html?invariant=" +
        code;
      for (var argIdx = 0; argIdx < argCount; argIdx++) {
        message += "&args[]=" + encodeURIComponent(arguments[argIdx + 1]);
      }
      message +=
        " for the full message or use the non-minified dev environment" +
        " for full errors and additional helpful warnings.";
      var error = new Error(message);
      error.name = "Invariant Violation";
      error.framesToPop = 1;
      throw error;
    }
    module.exports = reactProdInvariant;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var emptyObject = {};
    if (false) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = __webpack_require__(183);
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var EventPluginRegistry = __webpack_require__(42);
    var ReactEventEmitterMixin = __webpack_require__(198);
    var ViewportMetrics = __webpack_require__(86);
    var getVendorPrefixedEventName = __webpack_require__(230);
    var isEventSupported = __webpack_require__(53);
    var hasEventPageXY;
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topAbort: "abort",
      topAnimationEnd:
        getVendorPrefixedEventName("animationend") || "animationend",
      topAnimationIteration:
        getVendorPrefixedEventName("animationiteration") ||
        "animationiteration",
      topAnimationStart:
        getVendorPrefixedEventName("animationstart") || "animationstart",
      topBlur: "blur",
      topCanPlay: "canplay",
      topCanPlayThrough: "canplaythrough",
      topChange: "change",
      topClick: "click",
      topCompositionEnd: "compositionend",
      topCompositionStart: "compositionstart",
      topCompositionUpdate: "compositionupdate",
      topContextMenu: "contextmenu",
      topCopy: "copy",
      topCut: "cut",
      topDoubleClick: "dblclick",
      topDrag: "drag",
      topDragEnd: "dragend",
      topDragEnter: "dragenter",
      topDragExit: "dragexit",
      topDragLeave: "dragleave",
      topDragOver: "dragover",
      topDragStart: "dragstart",
      topDrop: "drop",
      topDurationChange: "durationchange",
      topEmptied: "emptied",
      topEncrypted: "encrypted",
      topEnded: "ended",
      topError: "error",
      topFocus: "focus",
      topInput: "input",
      topKeyDown: "keydown",
      topKeyPress: "keypress",
      topKeyUp: "keyup",
      topLoadedData: "loadeddata",
      topLoadedMetadata: "loadedmetadata",
      topLoadStart: "loadstart",
      topMouseDown: "mousedown",
      topMouseMove: "mousemove",
      topMouseOut: "mouseout",
      topMouseOver: "mouseover",
      topMouseUp: "mouseup",
      topPaste: "paste",
      topPause: "pause",
      topPlay: "play",
      topPlaying: "playing",
      topProgress: "progress",
      topRateChange: "ratechange",
      topScroll: "scroll",
      topSeeked: "seeked",
      topSeeking: "seeking",
      topSelectionChange: "selectionchange",
      topStalled: "stalled",
      topSuspend: "suspend",
      topTextInput: "textInput",
      topTimeUpdate: "timeupdate",
      topTouchCancel: "touchcancel",
      topTouchEnd: "touchend",
      topTouchMove: "touchmove",
      topTouchStart: "touchstart",
      topTransitionEnd:
        getVendorPrefixedEventName("transitionend") || "transitionend",
      topVolumeChange: "volumechange",
      topWaiting: "waiting",
      topWheel: "wheel"
    };
    var topListenersIDKey =
      "_reactListenersID" + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {
        injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(
            ReactBrowserEventEmitter.handleTopLevel
          );
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }
      },
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(
          ReactBrowserEventEmitter.ReactEventListener &&
          ReactBrowserEventEmitter.ReactEventListener.isEnabled()
        );
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies =
          EventPluginRegistry.registrationNameDependencies[registrationName];
        for (var i = 0; i < dependencies.length; i++) {
          var dependency = dependencies[i];
          if (
            !(isListening.hasOwnProperty(dependency) && isListening[dependency])
          ) {
            if (dependency === "topWheel") {
              if (isEventSupported("wheel")) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topWheel",
                  "wheel",
                  mountAt
                );
              } else if (isEventSupported("mousewheel")) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topWheel",
                  "mousewheel",
                  mountAt
                );
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topWheel",
                  "DOMMouseScroll",
                  mountAt
                );
              }
            } else if (dependency === "topScroll") {
              if (isEventSupported("scroll", true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
                  "topScroll",
                  "scroll",
                  mountAt
                );
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topScroll",
                  "scroll",
                  ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
                );
              }
            } else if (dependency === "topFocus" || dependency === "topBlur") {
              if (isEventSupported("focus", true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
                  "topFocus",
                  "focus",
                  mountAt
                );
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
                  "topBlur",
                  "blur",
                  mountAt
                );
              } else if (isEventSupported("focusin")) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topFocus",
                  "focusin",
                  mountAt
                );
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                  "topBlur",
                  "focusout",
                  mountAt
                );
              }
              isListening.topBlur = true;
              isListening.topFocus = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
                dependency,
                topEventMapping[dependency],
                mountAt
              );
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
          topLevelType,
          handlerBaseName,
          handle
        );
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
          topLevelType,
          handlerBaseName,
          handle
        );
      },
      supportsEventPageXY: function() {
        if (!document.createEvent) {
          return false;
        }
        var ev = document.createEvent("MouseEvent");
        return ev != null && "pageX" in ev;
      },
      ensureScrollValueMonitoring: function() {
        if (hasEventPageXY === undefined) {
          hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
        }
        if (!hasEventPageXY && !isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(
            refresh
          );
          isMonitoringScrollValue = true;
        }
      }
    });
    module.exports = ReactBrowserEventEmitter;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticUIEvent = __webpack_require__(28);
    var ViewportMetrics = __webpack_require__(86);
    var getEventModifierState = __webpack_require__(51);
    var MouseEventInterface = {
      screenX: null,
      screenY: null,
      clientX: null,
      clientY: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      getModifierState: getEventModifierState,
      button: function(event) {
        var button = event.button;
        if ("which" in event) {
          return button;
        }
        return button === 2 ? 2 : button === 4 ? 1 : 0;
      },
      buttons: null,
      relatedTarget: function(event) {
        return (
          event.relatedTarget ||
          (event.fromElement === event.srcElement
            ? event.toElement
            : event.fromElement)
        );
      },
      pageX: function(event) {
        return "pageX" in event
          ? event.pageX
          : event.clientX + ViewportMetrics.currentScrollLeft;
      },
      pageY: function(event) {
        return "pageY" in event
          ? event.pageY
          : event.clientY + ViewportMetrics.currentScrollTop;
      }
    };
    function SyntheticMouseEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticUIEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
    module.exports = SyntheticMouseEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    var OBSERVED_ERROR = {};
    var TransactionImpl = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (this.wrapperInitData) {
          this.wrapperInitData.length = 0;
        } else {
          this.wrapperInitData = [];
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        !!this.isInTransaction()
          ? false
            ? invariant(
                false,
                "Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction."
              )
            : _prodInvariant("27")
          : void 0;
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize
              ? wrapper.initialize.call(this)
              : null;
          } finally {
            if (this.wrapperInitData[i] === OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        !this.isInTransaction()
          ? false
            ? invariant(
                false,
                "Transaction.closeAll(): Cannot close transaction when none are open."
              )
            : _prodInvariant("28")
          : void 0;
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    module.exports = TransactionImpl;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&#x27;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
      }
      return lastIndex !== index
        ? html + str.substring(lastIndex, index)
        : html;
    }
    function escapeTextContentForBrowser(text) {
      if (typeof text === "boolean" || typeof text === "number") {
        return "" + text;
      }
      return escapeHtml(text);
    }
    module.exports = escapeTextContentForBrowser;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var DOMNamespaces = __webpack_require__(41);
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var createMicrosoftUnsafeLocalFunction = __webpack_require__(49);
    var reusableSVGContainer;
    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
      if (node.namespaceURI === DOMNamespaces.svg && !("innerHTML" in node)) {
        reusableSVGContainer =
          reusableSVGContainer || document.createElement("div");
        reusableSVGContainer.innerHTML = "<svg>" + html + "</svg>";
        var svgNode = reusableSVGContainer.firstChild;
        while (svgNode.firstChild) {
          node.appendChild(svgNode.firstChild);
        }
      } else {
        node.innerHTML = html;
      }
    });
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement("div");
      testElement.innerHTML = " ";
      if (testElement.innerHTML === "") {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (
            WHITESPACE_TEST.test(html) ||
            (html[0] === "<" && NONVISIBLE_TEST.test(html))
          ) {
            node.innerHTML = String.fromCharCode(0xfeff) + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
      testElement = null;
    }
    module.exports = setInnerHTML;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
    var __WEBPACK_IMPORTED_MODULE_0_raf__ = __webpack_require__(169);
    var __WEBPACK_IMPORTED_MODULE_0_raf___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_0_raf__
    );
    var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(1);
    var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_1_react__
    );
    var __WEBPACK_IMPORTED_MODULE_2_emotion__ = __webpack_require__(148);
    var __WEBPACK_IMPORTED_MODULE_3_react_dom__ = __webpack_require__(31);
    var __WEBPACK_IMPORTED_MODULE_3_react_dom___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_3_react_dom__
    );
    var __WEBPACK_IMPORTED_MODULE_4_prop_types__ = __webpack_require__(2);
    var __WEBPACK_IMPORTED_MODULE_4_prop_types___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_4_prop_types__
    );
    var __WEBPACK_IMPORTED_MODULE_5_react_input_autosize__ = __webpack_require__(
      233
    );
    var __WEBPACK_IMPORTED_MODULE_5_react_input_autosize___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_5_react_input_autosize__
    );
    var __WEBPACK_IMPORTED_MODULE_6_memoize_one__ = __webpack_require__(164);
    var __WEBPACK_IMPORTED_MODULE_7_react_transition_group__ = __webpack_require__(
      236
    );
    var __WEBPACK_IMPORTED_MODULE_7_react_transition_group___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_7_react_transition_group__
    );
    __webpack_require__.d(__webpack_exports__, "SelectBase", function() {
      return Select;
    });
    __webpack_require__.d(__webpack_exports__, "Async", function() {
      return Async;
    });
    __webpack_require__.d(__webpack_exports__, "AsyncCreatable", function() {
      return AsyncCreatable;
    });
    __webpack_require__.d(__webpack_exports__, "Creatable", function() {
      return Creatable;
    });
    __webpack_require__.d(__webpack_exports__, "createFilter", function() {
      return createFilter;
    });
    __webpack_require__.d(__webpack_exports__, "makeAnimated", function() {
      return index;
    });
    __webpack_require__.d(__webpack_exports__, "components", function() {
      return components;
    });
    __webpack_require__.d(__webpack_exports__, "mergeStyles", function() {
      return mergeStyles;
    });
    __webpack_require__.d(__webpack_exports__, "defaultTheme", function() {
      return defaultTheme;
    });
    var _typeof =
      typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
        ? function(obj) {
            return typeof obj;
          }
        : function(obj) {
            return obj &&
              typeof Symbol === "function" &&
              obj.constructor === Symbol &&
              obj !== Symbol.prototype
              ? "symbol"
              : typeof obj;
          };
    var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var defineProperty = function(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var inherits = function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    };
    var objectWithoutProperties = function(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    };
    var possibleConstructorReturn = function(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    };
    var slicedToArray = (function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;
        try {
          for (
            var _i = arr[Symbol.iterator](), _s;
            !(_n = (_s = _i.next()).done);
            _n = true
          ) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance"
          );
        }
      };
    })();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var noop = function noop() {};
    function applyPrefixToName(prefix, name) {
      if (!name) {
        return prefix;
      } else if (name[0] === "-") {
        return prefix + name;
      } else {
        return prefix + "__" + name;
      }
    }
    function classNames(prefix, cssKey, state, className) {
      var arr = [cssKey, className];
      if (state && prefix) {
        for (var key in state) {
          if (state.hasOwnProperty(key) && state[key]) {
            arr.push("" + applyPrefixToName(prefix, key));
          }
        }
      }
      return arr
        .filter(function(i) {
          return i;
        })
        .map(function(i) {
          return String(i).trim();
        })
        .join(" ");
    }
    var cleanValue = function cleanValue(value) {
      if (Array.isArray(value)) return value.filter(Boolean);
      if (
        (typeof value === "undefined" ? "undefined" : _typeof(value)) ===
          "object" &&
        value !== null
      )
        return [value];
      return [];
    };
    function handleInputChange(inputValue, actionMeta, onInputChange) {
      if (onInputChange) {
        var newValue = onInputChange(inputValue, actionMeta);
        if (typeof newValue === "string") return newValue;
      }
      return inputValue;
    }
    function isDocumentElement(el) {
      return [document.documentElement, document.body, window].indexOf(el) > -1;
    }
    function getScrollTop(el) {
      if (isDocumentElement(el)) {
        return window.pageYOffset;
      }
      return el.scrollTop;
    }
    function scrollTo(el, top) {
      if (isDocumentElement(el)) {
        window.scrollTo(0, top);
        return;
      }
      el.scrollTop = top;
    }
    function getScrollParent(element) {
      var style = getComputedStyle(element);
      var excludeStaticParent = style.position === "absolute";
      var overflowRx = /(auto|scroll)/;
      var docEl = document.documentElement;
      if (style.position === "fixed") return docEl;
      for (var parent = element; (parent = parent.parentElement); ) {
        style = getComputedStyle(parent);
        if (excludeStaticParent && style.position === "static") {
          continue;
        }
        if (
          overflowRx.test(style.overflow + style.overflowY + style.overflowX)
        ) {
          return parent;
        }
      }
      return docEl;
    }
    function easeOutCubic(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    }
    function animatedScrollTo(element, to) {
      var duration =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
      var callback =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : noop;
      var start = getScrollTop(element);
      var change = to - start;
      var increment = 10;
      var currentTime = 0;
      function animateScroll() {
        currentTime += increment;
        var val = easeOutCubic(currentTime, start, change, duration);
        scrollTo(element, val);
        if (currentTime < duration) {
          __WEBPACK_IMPORTED_MODULE_0_raf___default()(animateScroll);
        } else {
          callback(element);
        }
      }
      animateScroll();
    }
    function scrollIntoView(menuEl, focusedEl) {
      var menuRect = menuEl.getBoundingClientRect();
      var focusedRect = focusedEl.getBoundingClientRect();
      var overScroll = focusedEl.offsetHeight / 3;
      if (focusedRect.bottom + overScroll > menuRect.bottom) {
        scrollTo(
          menuEl,
          Math.min(
            focusedEl.offsetTop +
              focusedEl.clientHeight -
              menuEl.offsetHeight +
              overScroll,
            menuEl.scrollHeight
          )
        );
      } else if (focusedRect.top - overScroll < menuRect.top) {
        scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
      }
    }
    function getBoundingClientObj(element) {
      var rect = element.getBoundingClientRect();
      return {
        bottom: rect.bottom,
        height: rect.height,
        left: rect.left,
        right: rect.right,
        top: rect.top,
        width: rect.width
      };
    }
    function isTouchCapable() {
      try {
        document.createEvent("TouchEvent");
        return true;
      } catch (e) {
        return false;
      }
    }
    function isMobileDevice() {
      try {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      } catch (e) {
        return false;
      }
    }
    function getMenuPlacement(_ref) {
      var maxHeight = _ref.maxHeight,
        menuEl = _ref.menuEl,
        minHeight = _ref.minHeight,
        placement = _ref.placement,
        shouldScroll = _ref.shouldScroll,
        isFixedPosition = _ref.isFixedPosition,
        theme = _ref.theme;
      var spacing = theme.spacing;
      var scrollParent = getScrollParent(menuEl);
      var defaultState = { placement: "bottom", maxHeight: maxHeight };
      if (!menuEl || !menuEl.offsetParent) return defaultState;
      var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
        scrollHeight = _scrollParent$getBoun.height;
      var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
        menuBottom = _menuEl$getBoundingCl.bottom,
        menuHeight = _menuEl$getBoundingCl.height,
        menuTop = _menuEl$getBoundingCl.top;
      var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
        containerTop = _menuEl$offsetParent$.top;
      var viewHeight = window.innerHeight;
      var scrollTop = getScrollTop(scrollParent);
      var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
      var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
      var viewSpaceAbove = containerTop - marginTop;
      var viewSpaceBelow = viewHeight - menuTop;
      var scrollSpaceAbove = viewSpaceAbove + scrollTop;
      var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
      var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
      var scrollUp = scrollTop + menuTop - marginTop;
      var scrollDuration = 160;
      switch (placement) {
        case "auto":
        case "bottom":
          if (viewSpaceBelow >= menuHeight) {
            return { placement: "bottom", maxHeight: maxHeight };
          }
          if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
            if (shouldScroll) {
              animatedScrollTo(scrollParent, scrollDown, scrollDuration);
            }
            return { placement: "bottom", maxHeight: maxHeight };
          }
          if (
            (!isFixedPosition && scrollSpaceBelow >= minHeight) ||
            (isFixedPosition && viewSpaceBelow >= minHeight)
          ) {
            if (shouldScroll) {
              animatedScrollTo(scrollParent, scrollDown, scrollDuration);
            }
            var constrainedHeight = isFixedPosition
              ? viewSpaceBelow - marginBottom
              : scrollSpaceBelow - marginBottom;
            return { placement: "bottom", maxHeight: constrainedHeight };
          }
          if (placement === "auto" || isFixedPosition) {
            var _constrainedHeight = maxHeight;
            if (
              (!isFixedPosition && scrollSpaceAbove >= minHeight) ||
              (isFixedPosition && viewSpaceAbove >= minHeight)
            ) {
              _constrainedHeight = isFixedPosition
                ? viewSpaceAbove - marginBottom - spacing.controlHeight
                : scrollSpaceAbove - marginBottom - spacing.controlHeight;
            }
            return { placement: "top", maxHeight: _constrainedHeight };
          }
          if (placement === "bottom") {
            scrollTo(scrollParent, scrollDown);
            return { placement: "bottom", maxHeight: maxHeight };
          }
          break;
        case "top":
          if (viewSpaceAbove >= menuHeight) {
            return { placement: "top", maxHeight: maxHeight };
          }
          if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
            if (shouldScroll) {
              animatedScrollTo(scrollParent, scrollUp, scrollDuration);
            }
            return { placement: "top", maxHeight: maxHeight };
          }
          if (
            (!isFixedPosition && scrollSpaceAbove >= minHeight) ||
            (isFixedPosition && viewSpaceAbove >= minHeight)
          ) {
            var _constrainedHeight2 = maxHeight;
            if (
              (!isFixedPosition && scrollSpaceAbove >= minHeight) ||
              (isFixedPosition && viewSpaceAbove >= minHeight)
            ) {
              _constrainedHeight2 = isFixedPosition
                ? viewSpaceAbove - marginTop
                : scrollSpaceAbove - marginTop;
            }
            if (shouldScroll) {
              animatedScrollTo(scrollParent, scrollUp, scrollDuration);
            }
            return { placement: "top", maxHeight: _constrainedHeight2 };
          }
          return { placement: "bottom", maxHeight: maxHeight };
        default:
          throw new Error('Invalid placement provided "' + placement + '".');
      }
      return defaultState;
    }
    function alignToControl(placement) {
      var placementToCSSProp = { bottom: "top", top: "bottom" };
      return placement ? placementToCSSProp[placement] : "bottom";
    }
    var coercePlacement = function coercePlacement(p) {
      return p === "auto" ? "bottom" : p;
    };
    var menuCSS = function menuCSS(_ref2) {
      var _ref3;
      var placement = _ref2.placement,
        _ref2$theme = _ref2.theme,
        borderRadius = _ref2$theme.borderRadius,
        spacing = _ref2$theme.spacing,
        colors = _ref2$theme.colors;
      return (
        (_ref3 = {}),
        defineProperty(_ref3, alignToControl(placement), "100%"),
        defineProperty(_ref3, "backgroundColor", colors.neutral0),
        defineProperty(_ref3, "borderRadius", borderRadius),
        defineProperty(
          _ref3,
          "boxShadow",
          "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)"
        ),
        defineProperty(_ref3, "marginBottom", spacing.menuGutter),
        defineProperty(_ref3, "marginTop", spacing.menuGutter),
        defineProperty(_ref3, "position", "absolute"),
        defineProperty(_ref3, "width", "100%"),
        defineProperty(_ref3, "zIndex", 1),
        _ref3
      );
    };
    var MenuPlacer = (function(_Component) {
      inherits(MenuPlacer, _Component);
      function MenuPlacer() {
        var _ref4;
        var _temp, _this, _ret;
        classCallCheck(this, MenuPlacer);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = possibleConstructorReturn(
                this,
                (_ref4 =
                  MenuPlacer.__proto__ ||
                  Object.getPrototypeOf(MenuPlacer)).call.apply(
                  _ref4,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.state = {
              maxHeight: _this.props.maxMenuHeight,
              placement: null
            }),
            (_this.getPlacement = function(ref) {
              var _this$props = _this.props,
                minMenuHeight = _this$props.minMenuHeight,
                maxMenuHeight = _this$props.maxMenuHeight,
                menuPlacement = _this$props.menuPlacement,
                menuPosition = _this$props.menuPosition,
                menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView,
                theme = _this$props.theme;
              var getPortalPlacement = _this.context.getPortalPlacement;
              if (!ref) return;
              var isFixedPosition = menuPosition === "fixed";
              var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
              var state = getMenuPlacement({
                maxHeight: maxMenuHeight,
                menuEl: ref,
                minHeight: minMenuHeight,
                placement: menuPlacement,
                shouldScroll: shouldScroll,
                isFixedPosition: isFixedPosition,
                theme: theme
              });
              if (getPortalPlacement) getPortalPlacement(state);
              _this.setState(state);
            }),
            (_this.getUpdatedProps = function() {
              var menuPlacement = _this.props.menuPlacement;
              var placement =
                _this.state.placement || coercePlacement(menuPlacement);
              return _extends({}, _this.props, {
                placement: placement,
                maxHeight: _this.state.maxHeight
              });
            }),
            _temp)),
          possibleConstructorReturn(_this, _ret)
        );
      }
      createClass(MenuPlacer, [
        {
          key: "render",
          value: function render() {
            var children = this.props.children;
            return children({
              ref: this.getPlacement,
              placerProps: this.getUpdatedProps()
            });
          }
        }
      ]);
      return MenuPlacer;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    MenuPlacer.contextTypes = {
      getPortalPlacement:
        __WEBPACK_IMPORTED_MODULE_4_prop_types___default.a.func
    };
    var Menu = function Menu(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerRef = props.innerRef,
        innerProps = props.innerProps;
      var cn = cx(
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
          getStyles("menu", props)
        ),
        { menu: true },
        className
      );
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends({ className: cn }, innerProps, { ref: innerRef }),
        children
      );
    };
    var menuListCSS = function menuListCSS(_ref5) {
      var maxHeight = _ref5.maxHeight,
        baseUnit = _ref5.theme.spacing.baseUnit;
      return {
        maxHeight: maxHeight,
        overflowY: "auto",
        paddingBottom: baseUnit,
        paddingTop: baseUnit,
        position: "relative",
        WebkitOverflowScrolling: "touch"
      };
    };
    var MenuList = function MenuList(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        isMulti = props.isMulti,
        innerRef = props.innerRef;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("menuList", props)
            ),
            { "menu-list": true, "menu-list--is-multi": isMulti },
            className
          ),
          ref: innerRef
        },
        children
      );
    };
    var noticeCSS = function noticeCSS(_ref6) {
      var _ref6$theme = _ref6.theme,
        baseUnit = _ref6$theme.spacing.baseUnit,
        colors = _ref6$theme.colors;
      return {
        color: colors.neutral40,
        padding: baseUnit * 2 + "px " + baseUnit * 3 + "px",
        textAlign: "center"
      };
    };
    var noOptionsMessageCSS = noticeCSS;
    var loadingMessageCSS = noticeCSS;
    var NoOptionsMessage = function NoOptionsMessage(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("noOptionsMessage", props)
              ),
              { "menu-notice": true, "menu-notice--no-options": true },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    NoOptionsMessage.defaultProps = { children: "No options" };
    var LoadingMessage = function LoadingMessage(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("loadingMessage", props)
              ),
              { "menu-notice": true, "menu-notice--loading": true },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    LoadingMessage.defaultProps = { children: "Loading..." };
    var menuPortalCSS = function menuPortalCSS(_ref7) {
      var rect = _ref7.rect,
        offset = _ref7.offset,
        position = _ref7.position;
      return {
        left: rect.left,
        position: position,
        top: offset,
        width: rect.width,
        zIndex: 1
      };
    };
    var MenuPortal = (function(_Component2) {
      inherits(MenuPortal, _Component2);
      function MenuPortal() {
        var _ref8;
        var _temp2, _this2, _ret2;
        classCallCheck(this, MenuPortal);
        for (
          var _len2 = arguments.length, args = Array(_len2), _key2 = 0;
          _key2 < _len2;
          _key2++
        ) {
          args[_key2] = arguments[_key2];
        }
        return (
          (_ret2 =
            ((_temp2 =
              ((_this2 = possibleConstructorReturn(
                this,
                (_ref8 =
                  MenuPortal.__proto__ ||
                  Object.getPrototypeOf(MenuPortal)).call.apply(
                  _ref8,
                  [this].concat(args)
                )
              )),
              _this2)),
            (_this2.state = { placement: null }),
            (_this2.getPortalPlacement = function(_ref9) {
              var placement = _ref9.placement;
              var initialPlacement = coercePlacement(
                _this2.props.menuPlacement
              );
              if (placement !== initialPlacement) {
                _this2.setState({ placement: placement });
              }
            }),
            _temp2)),
          possibleConstructorReturn(_this2, _ret2)
        );
      }
      createClass(MenuPortal, [
        {
          key: "getChildContext",
          value: function getChildContext() {
            return { getPortalPlacement: this.getPortalPlacement };
          }
        },
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              appendTo = _props.appendTo,
              children = _props.children,
              controlElement = _props.controlElement,
              menuPlacement = _props.menuPlacement,
              position = _props.menuPosition,
              getStyles = _props.getStyles;
            var isFixed = position === "fixed";
            if ((!appendTo && !isFixed) || !controlElement) {
              return null;
            }
            var placement =
              this.state.placement || coercePlacement(menuPlacement);
            var rect = getBoundingClientObj(controlElement);
            var scrollDistance = isFixed ? 0 : window.pageYOffset;
            var offset = rect[placement] + scrollDistance;
            var state = { offset: offset, position: position, rect: rect };
            var menuWrapper = __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              "div",
              {
                className: __webpack_require__.i(
                  __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                )(getStyles("menuPortal", state))
              },
              children
            );
            return appendTo
              ? __webpack_require__.i(
                  __WEBPACK_IMPORTED_MODULE_3_react_dom__["createPortal"]
                )(menuWrapper, appendTo)
              : menuWrapper;
          }
        }
      ]);
      return MenuPortal;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    MenuPortal.childContextTypes = {
      getPortalPlacement:
        __WEBPACK_IMPORTED_MODULE_4_prop_types___default.a.func
    };
    var isArray = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    function equal(a, b) {
      if (a === b) return true;
      if (
        a &&
        b &&
        (typeof a === "undefined" ? "undefined" : _typeof(a)) == "object" &&
        (typeof b === "undefined" ? "undefined" : _typeof(b)) == "object"
      ) {
        var arrA = isArray(a),
          arrB = isArray(b),
          i,
          length,
          key;
        if (arrA && arrB) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; ) {
            if (!equal(a[i], b[i])) return false;
          }
          return true;
        }
        if (arrA != arrB) return false;
        var dateA = a instanceof Date,
          dateB = b instanceof Date;
        if (dateA != dateB) return false;
        if (dateA && dateB) return a.getTime() == b.getTime();
        var regexpA = a instanceof RegExp,
          regexpB = b instanceof RegExp;
        if (regexpA != regexpB) return false;
        if (regexpA && regexpB) return a.toString() == b.toString();
        var keys = keyList(a);
        length = keys.length;
        if (length !== keyList(b).length) {
          return false;
        }
        for (i = length; i-- !== 0; ) {
          if (!hasProp.call(b, keys[i])) return false;
        }
        for (i = length; i-- !== 0; ) {
          key = keys[i];
          if (key === "_owner" && a.$$typeof) {
            continue;
          } else {
            if (!equal(a[key], b[key])) return false;
          }
        }
        return true;
      }
      return a !== a && b !== b;
    }
    function exportedEqual(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if (error.message && error.message.match(/stack|recursion/i)) {
          console.warn(
            "Warning: react-fast-compare does not handle circular references.",
            error.name,
            error.message
          );
          return false;
        }
        throw error;
      }
    }
    var diacritics = [
      {
        base: "A",
        letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
      },
      { base: "AA", letters: /[\uA732]/g },
      { base: "AE", letters: /[\u00C6\u01FC\u01E2]/g },
      { base: "AO", letters: /[\uA734]/g },
      { base: "AU", letters: /[\uA736]/g },
      { base: "AV", letters: /[\uA738\uA73A]/g },
      { base: "AY", letters: /[\uA73C]/g },
      {
        base: "B",
        letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
      },
      {
        base: "C",
        letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
      },
      {
        base: "D",
        letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
      },
      { base: "DZ", letters: /[\u01F1\u01C4]/g },
      { base: "Dz", letters: /[\u01F2\u01C5]/g },
      {
        base: "E",
        letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
      },
      { base: "F", letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g },
      {
        base: "G",
        letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
      },
      {
        base: "H",
        letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
      },
      {
        base: "I",
        letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
      },
      { base: "J", letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g },
      {
        base: "K",
        letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
      },
      {
        base: "L",
        letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
      },
      { base: "LJ", letters: /[\u01C7]/g },
      { base: "Lj", letters: /[\u01C8]/g },
      {
        base: "M",
        letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
      },
      {
        base: "N",
        letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
      },
      { base: "NJ", letters: /[\u01CA]/g },
      { base: "Nj", letters: /[\u01CB]/g },
      {
        base: "O",
        letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
      },
      { base: "OI", letters: /[\u01A2]/g },
      { base: "OO", letters: /[\uA74E]/g },
      { base: "OU", letters: /[\u0222]/g },
      {
        base: "P",
        letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
      },
      { base: "Q", letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g },
      {
        base: "R",
        letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
      },
      {
        base: "S",
        letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
      },
      {
        base: "T",
        letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
      },
      { base: "TZ", letters: /[\uA728]/g },
      {
        base: "U",
        letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
      },
      {
        base: "V",
        letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
      },
      { base: "VY", letters: /[\uA760]/g },
      {
        base: "W",
        letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
      },
      { base: "X", letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g },
      {
        base: "Y",
        letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
      },
      {
        base: "Z",
        letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
      },
      {
        base: "a",
        letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
      },
      { base: "aa", letters: /[\uA733]/g },
      { base: "ae", letters: /[\u00E6\u01FD\u01E3]/g },
      { base: "ao", letters: /[\uA735]/g },
      { base: "au", letters: /[\uA737]/g },
      { base: "av", letters: /[\uA739\uA73B]/g },
      { base: "ay", letters: /[\uA73D]/g },
      {
        base: "b",
        letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
      },
      {
        base: "c",
        letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
      },
      {
        base: "d",
        letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
      },
      { base: "dz", letters: /[\u01F3\u01C6]/g },
      {
        base: "e",
        letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
      },
      { base: "f", letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g },
      {
        base: "g",
        letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
      },
      {
        base: "h",
        letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
      },
      { base: "hv", letters: /[\u0195]/g },
      {
        base: "i",
        letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
      },
      { base: "j", letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g },
      {
        base: "k",
        letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
      },
      {
        base: "l",
        letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
      },
      { base: "lj", letters: /[\u01C9]/g },
      {
        base: "m",
        letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
      },
      {
        base: "n",
        letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
      },
      { base: "nj", letters: /[\u01CC]/g },
      {
        base: "o",
        letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
      },
      { base: "oi", letters: /[\u01A3]/g },
      { base: "ou", letters: /[\u0223]/g },
      { base: "oo", letters: /[\uA74F]/g },
      {
        base: "p",
        letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
      },
      { base: "q", letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g },
      {
        base: "r",
        letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
      },
      {
        base: "s",
        letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
      },
      {
        base: "t",
        letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
      },
      { base: "tz", letters: /[\uA729]/g },
      {
        base: "u",
        letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
      },
      {
        base: "v",
        letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
      },
      { base: "vy", letters: /[\uA761]/g },
      {
        base: "w",
        letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
      },
      { base: "x", letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g },
      {
        base: "y",
        letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
      },
      {
        base: "z",
        letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
      }
    ];
    var stripDiacritics = function stripDiacritics(str) {
      for (var i = 0; i < diacritics.length; i++) {
        str = str.replace(diacritics[i].letters, diacritics[i].base);
      }
      return str;
    };
    var trimString = function trimString(str) {
      return str.replace(/^\s+|\s+$/g, "");
    };
    var defaultStringify = function defaultStringify(option) {
      return option.label + " " + option.value;
    };
    var createFilter = function createFilter(config) {
      return function(option, rawInput) {
        var _ignoreCase$ignoreAcc = _extends(
            {
              ignoreCase: true,
              ignoreAccents: true,
              stringify: defaultStringify,
              trim: true,
              matchFrom: "any"
            },
            config
          ),
          ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
          ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
          stringify = _ignoreCase$ignoreAcc.stringify,
          trim = _ignoreCase$ignoreAcc.trim,
          matchFrom = _ignoreCase$ignoreAcc.matchFrom;
        var input = trim ? trimString(rawInput) : rawInput;
        var candidate = trim
          ? trimString(stringify(option))
          : stringify(option);
        if (ignoreCase) {
          input = input.toLowerCase();
          candidate = candidate.toLowerCase();
        }
        if (ignoreAccents) {
          input = stripDiacritics(input);
          candidate = stripDiacritics(candidate);
        }
        return matchFrom === "start"
          ? candidate.substr(0, input.length) === input
          : candidate.indexOf(input) > -1;
      };
    };
    var A11yText = function A11yText(props) {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "span",
        _extends(
          {
            className: __webpack_require__.i(
              __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
            )({
              zIndex: 9999,
              border: 0,
              clip: "rect(1px, 1px, 1px, 1px)",
              height: 1,
              width: 1,
              position: "absolute",
              overflow: "hidden",
              padding: 0,
              whiteSpace: "nowrap",
              backgroundColor: "red",
              color: "blue"
            })
          },
          props
        )
      );
    };
    var DummyInput = (function(_Component) {
      inherits(DummyInput, _Component);
      function DummyInput() {
        classCallCheck(this, DummyInput);
        return possibleConstructorReturn(
          this,
          (DummyInput.__proto__ || Object.getPrototypeOf(DummyInput)).apply(
            this,
            arguments
          )
        );
      }
      createClass(DummyInput, [
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              inProp = _props.in,
              out = _props.out,
              onExited = _props.onExited,
              appear = _props.appear,
              enter = _props.enter,
              exit = _props.exit,
              innerRef = _props.innerRef,
              props = objectWithoutProperties(_props, [
                "in",
                "out",
                "onExited",
                "appear",
                "enter",
                "exit",
                "innerRef"
              ]);
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              "input",
              _extends({ ref: innerRef }, props, {
                className: __webpack_require__.i(
                  __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                )({
                  background: 0,
                  border: 0,
                  fontSize: "inherit",
                  outline: 0,
                  padding: 0,
                  width: 1,
                  color: "transparent",
                  left: -100,
                  opacity: 0,
                  position: "relative",
                  transform: "scale(0)"
                })
              })
            );
          }
        }
      ]);
      return DummyInput;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    var NodeResolver = (function(_Component) {
      inherits(NodeResolver, _Component);
      function NodeResolver() {
        classCallCheck(this, NodeResolver);
        return possibleConstructorReturn(
          this,
          (NodeResolver.__proto__ || Object.getPrototypeOf(NodeResolver)).apply(
            this,
            arguments
          )
        );
      }
      createClass(NodeResolver, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.props.innerRef(
              __webpack_require__.i(
                __WEBPACK_IMPORTED_MODULE_3_react_dom__["findDOMNode"]
              )(this)
            );
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.props.innerRef(null);
          }
        },
        {
          key: "render",
          value: function render() {
            return this.props.children;
          }
        }
      ]);
      return NodeResolver;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    var STYLE_KEYS = [
      "boxSizing",
      "height",
      "overflow",
      "paddingRight",
      "position"
    ];
    var LOCK_STYLES = {
      boxSizing: "border-box",
      overflow: "hidden",
      position: "relative",
      height: "100%"
    };
    function preventTouchMove(e) {
      e.preventDefault();
    }
    function allowTouchMove(e) {
      e.stopPropagation();
    }
    function preventInertiaScroll() {
      var top = this.scrollTop;
      var totalScroll = this.scrollHeight;
      var currentScroll = top + this.offsetHeight;
      if (top === 0) {
        this.scrollTop = 1;
      } else if (currentScroll === totalScroll) {
        this.scrollTop = top - 1;
      }
    }
    function isTouchDevice() {
      return "ontouchstart" in window || navigator.maxTouchPoints;
    }
    var canUseDOM = !!(
      typeof window !== "undefined" &&
      window.document &&
      window.document.createElement
    );
    var activeScrollLocks = 0;
    var ScrollLock = (function(_Component) {
      inherits(ScrollLock, _Component);
      function ScrollLock() {
        var _ref;
        var _temp, _this, _ret;
        classCallCheck(this, ScrollLock);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = possibleConstructorReturn(
                this,
                (_ref =
                  ScrollLock.__proto__ ||
                  Object.getPrototypeOf(ScrollLock)).call.apply(
                  _ref,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.originalStyles = {}),
            (_this.listenerOptions = { capture: false, passive: false }),
            _temp)),
          possibleConstructorReturn(_this, _ret)
        );
      }
      createClass(ScrollLock, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            if (!canUseDOM) return;
            var _props = this.props,
              accountForScrollbars = _props.accountForScrollbars,
              touchScrollTarget = _props.touchScrollTarget;
            var target = document.body;
            var targetStyle = target && target.style;
            if (accountForScrollbars) {
              STYLE_KEYS.forEach(function(key) {
                var val = targetStyle && targetStyle[key];
                _this2.originalStyles[key] = val;
              });
            }
            if (accountForScrollbars && activeScrollLocks < 1) {
              var currentPadding =
                parseInt(this.originalStyles.paddingRight, 10) || 0;
              var clientWidth = document.body ? document.body.clientWidth : 0;
              var adjustedPadding =
                window.innerWidth - clientWidth + currentPadding || 0;
              Object.keys(LOCK_STYLES).forEach(function(key) {
                var val = LOCK_STYLES[key];
                if (targetStyle) {
                  targetStyle[key] = val;
                }
              });
              if (targetStyle) {
                targetStyle.paddingRight = adjustedPadding + "px";
              }
            }
            if (target && isTouchDevice()) {
              target.addEventListener(
                "touchmove",
                preventTouchMove,
                this.listenerOptions
              );
              if (touchScrollTarget) {
                touchScrollTarget.addEventListener(
                  "touchstart",
                  preventInertiaScroll,
                  this.listenerOptions
                );
                touchScrollTarget.addEventListener(
                  "touchmove",
                  allowTouchMove,
                  this.listenerOptions
                );
              }
            }
            activeScrollLocks += 1;
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            var _this3 = this;
            if (!canUseDOM) return;
            var _props2 = this.props,
              accountForScrollbars = _props2.accountForScrollbars,
              touchScrollTarget = _props2.touchScrollTarget;
            var target = document.body;
            var targetStyle = target && target.style;
            activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
            if (accountForScrollbars && activeScrollLocks < 1) {
              STYLE_KEYS.forEach(function(key) {
                var val = _this3.originalStyles[key];
                if (targetStyle) {
                  targetStyle[key] = val;
                }
              });
            }
            if (target && isTouchDevice()) {
              target.removeEventListener(
                "touchmove",
                preventTouchMove,
                this.listenerOptions
              );
              if (touchScrollTarget) {
                touchScrollTarget.removeEventListener(
                  "touchstart",
                  preventInertiaScroll,
                  this.listenerOptions
                );
                touchScrollTarget.removeEventListener(
                  "touchmove",
                  allowTouchMove,
                  this.listenerOptions
                );
              }
            }
          }
        },
        {
          key: "render",
          value: function render() {
            return null;
          }
        }
      ]);
      return ScrollLock;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    ScrollLock.defaultProps = { accountForScrollbars: true };
    var ScrollBlock = (function(_PureComponent) {
      inherits(ScrollBlock, _PureComponent);
      function ScrollBlock() {
        var _ref;
        var _temp, _this, _ret;
        classCallCheck(this, ScrollBlock);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = possibleConstructorReturn(
                this,
                (_ref =
                  ScrollBlock.__proto__ ||
                  Object.getPrototypeOf(ScrollBlock)).call.apply(
                  _ref,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.state = { touchScrollTarget: null }),
            (_this.getScrollTarget = function(ref) {
              if (ref === _this.state.touchScrollTarget) return;
              _this.setState({ touchScrollTarget: ref });
            }),
            (_this.blurSelectInput = function() {
              if (document.activeElement) {
                document.activeElement.blur();
              }
            }),
            _temp)),
          possibleConstructorReturn(_this, _ret)
        );
      }
      createClass(ScrollBlock, [
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              children = _props.children,
              isEnabled = _props.isEnabled;
            var touchScrollTarget = this.state.touchScrollTarget;
            if (!isEnabled) return children;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              "div",
              null,
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                "div",
                {
                  onClick: this.blurSelectInput,
                  className: __webpack_require__.i(
                    __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                  )({ position: "fixed", left: 0, bottom: 0, right: 0, top: 0 })
                }
              ),
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                NodeResolver,
                { innerRef: this.getScrollTarget },
                children
              ),
              touchScrollTarget
                ? __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                    ScrollLock,
                    { touchScrollTarget: touchScrollTarget }
                  )
                : null
            );
          }
        }
      ]);
      return ScrollBlock;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["PureComponent"]);
    var ScrollCaptor = (function(_Component) {
      inherits(ScrollCaptor, _Component);
      function ScrollCaptor() {
        var _ref;
        var _temp, _this, _ret;
        classCallCheck(this, ScrollCaptor);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = possibleConstructorReturn(
                this,
                (_ref =
                  ScrollCaptor.__proto__ ||
                  Object.getPrototypeOf(ScrollCaptor)).call.apply(
                  _ref,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.isBottom = false),
            (_this.isTop = false),
            (_this.cancelScroll = function(event) {
              event.preventDefault();
              event.stopPropagation();
            }),
            (_this.handleEventDelta = function(event, delta) {
              var _this$props = _this.props,
                onBottomArrive = _this$props.onBottomArrive,
                onBottomLeave = _this$props.onBottomLeave,
                onTopArrive = _this$props.onTopArrive,
                onTopLeave = _this$props.onTopLeave;
              var _this$scrollTarget = _this.scrollTarget,
                scrollTop = _this$scrollTarget.scrollTop,
                scrollHeight = _this$scrollTarget.scrollHeight,
                clientHeight = _this$scrollTarget.clientHeight;
              var target = _this.scrollTarget;
              var isDeltaPositive = delta > 0;
              var availableScroll = scrollHeight - clientHeight - scrollTop;
              var shouldCancelScroll = false;
              if (availableScroll > delta && _this.isBottom) {
                if (onBottomLeave) onBottomLeave(event);
                _this.isBottom = false;
              }
              if (isDeltaPositive && _this.isTop) {
                if (onTopLeave) onTopLeave(event);
                _this.isTop = false;
              }
              if (isDeltaPositive && delta > availableScroll) {
                if (onBottomArrive && !_this.isBottom) {
                  onBottomArrive(event);
                }
                target.scrollTop = scrollHeight;
                shouldCancelScroll = true;
                _this.isBottom = true;
              } else if (!isDeltaPositive && -delta > scrollTop) {
                if (onTopArrive && !_this.isTop) {
                  onTopArrive(event);
                }
                target.scrollTop = 0;
                shouldCancelScroll = true;
                _this.isTop = true;
              }
              if (shouldCancelScroll) {
                _this.cancelScroll(event);
              }
            }),
            (_this.onWheel = function(event) {
              _this.handleEventDelta(event, event.deltaY);
            }),
            (_this.onTouchStart = function(event) {
              _this.touchStart = event.changedTouches[0].clientY;
            }),
            (_this.onTouchMove = function(event) {
              var deltaY = _this.touchStart - event.changedTouches[0].clientY;
              _this.handleEventDelta(event, deltaY);
            }),
            (_this.getScrollTarget = function(ref) {
              _this.scrollTarget = ref;
            }),
            _temp)),
          possibleConstructorReturn(_this, _ret)
        );
      }
      createClass(ScrollCaptor, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.startListening(this.scrollTarget);
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.stopListening(this.scrollTarget);
          }
        },
        {
          key: "startListening",
          value: function startListening(el) {
            if (el.scrollHeight <= el.clientHeight) return;
            if (typeof el.addEventListener === "function") {
              el.addEventListener("wheel", this.onWheel, false);
            }
            if (typeof el.addEventListener === "function") {
              el.addEventListener("touchstart", this.onTouchStart, false);
            }
            if (typeof el.addEventListener === "function") {
              el.addEventListener("touchmove", this.onTouchMove, false);
            }
          }
        },
        {
          key: "stopListening",
          value: function stopListening(el) {
            if (el.scrollHeight <= el.clientHeight) return;
            if (typeof el.removeEventListener === "function") {
              el.removeEventListener("wheel", this.onWheel, false);
            }
            if (typeof el.removeEventListener === "function") {
              el.removeEventListener("touchstart", this.onTouchStart, false);
            }
            if (typeof el.removeEventListener === "function") {
              el.removeEventListener("touchmove", this.onTouchMove, false);
            }
          }
        },
        {
          key: "render",
          value: function render() {
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              NodeResolver,
              { innerRef: this.getScrollTarget },
              this.props.children
            );
          }
        }
      ]);
      return ScrollCaptor;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    var ScrollCaptorSwitch = (function(_Component2) {
      inherits(ScrollCaptorSwitch, _Component2);
      function ScrollCaptorSwitch() {
        classCallCheck(this, ScrollCaptorSwitch);
        return possibleConstructorReturn(
          this,
          (
            ScrollCaptorSwitch.__proto__ ||
            Object.getPrototypeOf(ScrollCaptorSwitch)
          ).apply(this, arguments)
        );
      }
      createClass(ScrollCaptorSwitch, [
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              isEnabled = _props.isEnabled,
              props = objectWithoutProperties(_props, ["isEnabled"]);
            return isEnabled
              ? __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  ScrollCaptor,
                  props
                )
              : this.props.children;
          }
        }
      ]);
      return ScrollCaptorSwitch;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    ScrollCaptorSwitch.defaultProps = { isEnabled: true };
    var instructionsAriaMessage = function instructionsAriaMessage(event) {
      var context =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var isSearchable = context.isSearchable,
        isMulti = context.isMulti,
        label = context.label;
      switch (event) {
        case "menu":
          return "Use Up and Down to choose options, press Backspace to select the currently focused option, press Escape to exit the menu, press Tab to select the option and exit the menu.";
        case "input":
          return (
            (label ? label : "Select") +
            " is focused " +
            (isSearchable ? ",type to refine list" : "") +
            ", press Down to open the menu, " +
            (isMulti ? " press left to focus selected values" : "")
          );
        case "value":
          return "Use left and right to toggle between focused values, press Enter to remove the currently focused value";
      }
    };
    var valueEventAriaMessage = function valueEventAriaMessage(event, context) {
      var value = context.value;
      if (!value) return;
      switch (event) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return "option " + value + ", deselected.";
        case "select-option":
          return "option " + value + ", selected.";
      }
    };
    var valueFocusAriaMessage = function valueFocusAriaMessage(_ref) {
      var focusedValue = _ref.focusedValue,
        getOptionLabel = _ref.getOptionLabel,
        selectValue = _ref.selectValue;
      return (
        "value " +
        getOptionLabel(focusedValue) +
        " focused, " +
        (selectValue.indexOf(focusedValue) + 1) +
        " of " +
        selectValue.length +
        "."
      );
    };
    var optionFocusAriaMessage = function optionFocusAriaMessage(_ref2) {
      var focusedOption = _ref2.focusedOption,
        getOptionLabel = _ref2.getOptionLabel,
        options = _ref2.options;
      return (
        "option " +
        getOptionLabel(focusedOption) +
        " focused, " +
        (options.indexOf(focusedOption) + 1) +
        " of " +
        options.length +
        "."
      );
    };
    var resultsAriaMessage = function resultsAriaMessage(_ref3) {
      var inputValue = _ref3.inputValue,
        screenReaderMessage = _ref3.screenReaderMessage;
      return (
        "" +
        screenReaderMessage +
        (inputValue ? " for search term " + inputValue : "") +
        "."
      );
    };
    var formatGroupLabel = function formatGroupLabel(group) {
      return group.label;
    };
    var getOptionLabel = function getOptionLabel(option) {
      return option.label;
    };
    var getOptionValue = function getOptionValue(option) {
      return option.value;
    };
    var isOptionDisabled = function isOptionDisabled(option) {
      return !!option.isDisabled;
    };
    var containerCSS = function containerCSS(_ref) {
      var isDisabled = _ref.isDisabled,
        isRtl = _ref.isRtl;
      return {
        direction: isRtl ? "rtl" : null,
        pointerEvents: isDisabled ? "none" : null,
        position: "relative"
      };
    };
    var SelectContainer = function SelectContainer(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps,
        isDisabled = props.isDisabled,
        isRtl = props.isRtl;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("container", props)
              ),
              { "--is-disabled": isDisabled, "--is-rtl": isRtl },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    var valueContainerCSS = function valueContainerCSS(_ref2) {
      var spacing = _ref2.theme.spacing;
      return {
        alignItems: "center",
        display: "flex",
        flex: 1,
        flexWrap: "wrap",
        padding: spacing.baseUnit / 2 + "px " + spacing.baseUnit * 2 + "px",
        WebkitOverflowScrolling: "touch",
        position: "relative",
        overflow: "hidden"
      };
    };
    var ValueContainer = (function(_Component) {
      inherits(ValueContainer, _Component);
      function ValueContainer() {
        classCallCheck(this, ValueContainer);
        return possibleConstructorReturn(
          this,
          (
            ValueContainer.__proto__ || Object.getPrototypeOf(ValueContainer)
          ).apply(this, arguments)
        );
      }
      createClass(ValueContainer, [
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              children = _props.children,
              className = _props.className,
              cx = _props.cx,
              isMulti = _props.isMulti,
              getStyles = _props.getStyles,
              hasValue = _props.hasValue;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              "div",
              {
                className: cx(
                  __webpack_require__.i(
                    __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                  )(getStyles("valueContainer", this.props)),
                  {
                    "value-container": true,
                    "value-container--is-multi": isMulti,
                    "value-container--has-value": hasValue
                  },
                  className
                )
              },
              children
            );
          }
        }
      ]);
      return ValueContainer;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    var indicatorsContainerCSS = function indicatorsContainerCSS() {
      return {
        alignItems: "center",
        alignSelf: "stretch",
        display: "flex",
        flexShrink: 0
      };
    };
    var IndicatorsContainer = function IndicatorsContainer(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("indicatorsContainer", props)
            ),
            { indicators: true },
            className
          )
        },
        children
      );
    };
    var Svg = function Svg(_ref) {
      var size = _ref.size,
        props = objectWithoutProperties(_ref, ["size"]);
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "svg",
        _extends(
          {
            height: size,
            width: size,
            viewBox: "0 0 20 20",
            "aria-hidden": "true",
            focusable: "false",
            className: __webpack_require__.i(
              __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
            )({
              display: "inline-block",
              fill: "currentColor",
              lineHeight: 1,
              stroke: "currentColor",
              strokeWidth: 0
            })
          },
          props
        )
      );
    };
    var CrossIcon = function CrossIcon(props) {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        Svg,
        _extends({ size: 20 }, props),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement("path", {
          d:
            "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
        })
      );
    };
    var DownChevron = function DownChevron(props) {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        Svg,
        _extends({ size: 20 }, props),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement("path", {
          d:
            "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
        })
      );
    };
    var baseCSS = function baseCSS(_ref2) {
      var isFocused = _ref2.isFocused,
        _ref2$theme = _ref2.theme,
        baseUnit = _ref2$theme.spacing.baseUnit,
        colors = _ref2$theme.colors;
      return {
        color: isFocused ? colors.neutral60 : colors.neutral20,
        display: "flex",
        padding: baseUnit * 2,
        transition: "color 150ms",
        ":hover": { color: isFocused ? colors.neutral80 : colors.neutral40 }
      };
    };
    var dropdownIndicatorCSS = baseCSS;
    var DropdownIndicator = function DropdownIndicator(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends({}, innerProps, {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("dropdownIndicator", props)
            ),
            { indicator: true, "dropdown-indicator": true },
            className
          )
        }),
        children
      );
    };
    DropdownIndicator.defaultProps = {
      children: __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        DownChevron,
        null
      )
    };
    var clearIndicatorCSS = baseCSS;
    var ClearIndicator = function ClearIndicator(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends({}, innerProps, {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("clearIndicator", props)
            ),
            { indicator: true, "clear-indicator": true },
            className
          )
        }),
        children
      );
    };
    ClearIndicator.defaultProps = {
      children: __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        CrossIcon,
        null
      )
    };
    var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref3) {
      var isDisabled = _ref3.isDisabled,
        _ref3$theme = _ref3.theme,
        baseUnit = _ref3$theme.spacing.baseUnit,
        colors = _ref3$theme.colors;
      return {
        alignSelf: "stretch",
        backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
        marginBottom: baseUnit * 2,
        marginTop: baseUnit * 2,
        width: 1
      };
    };
    var IndicatorSeparator = function IndicatorSeparator(props) {
      var className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "span",
        _extends({}, innerProps, {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("indicatorSeparator", props)
            ),
            { "indicator-separator": true },
            className
          )
        })
      );
    };
    var keyframesName = "react-select-loading-indicator";
    var loadingIndicatorCSS = function loadingIndicatorCSS(_ref4) {
      var isFocused = _ref4.isFocused,
        size = _ref4.size,
        _ref4$theme = _ref4.theme,
        colors = _ref4$theme.colors,
        baseUnit = _ref4$theme.spacing.baseUnit;
      return {
        color: isFocused ? colors.neutral60 : colors.neutral20,
        display: "flex",
        padding: baseUnit * 2,
        transition: "color 150ms",
        alignSelf: "center",
        fontSize: size,
        lineHeight: 1,
        marginRight: size,
        textAlign: "center",
        verticalAlign: "middle"
      };
    };
    var LoadingDot = function LoadingDot(_ref5) {
      var color = _ref5.color,
        delay = _ref5.delay,
        offset = _ref5.offset;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "span",
        {
          className: __webpack_require__.i(
            __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
          )({
            animationDuration: "1s",
            animationDelay: delay + "ms",
            animationIterationCount: "infinite",
            animationName: keyframesName,
            animationTimingFunction: "ease-in-out",
            backgroundColor: color,
            borderRadius: "1em",
            display: "inline-block",
            marginLeft: offset ? "1em" : null,
            height: "1em",
            verticalAlign: "top",
            width: "1em"
          })
        }
      );
    };
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["b"])(
      "@keyframes ",
      keyframesName,
      "{0%,80%,100%{opacity:0;}40%{opacity:1;}};"
    );
    var LoadingIndicator = function LoadingIndicator(props) {
      var className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps,
        isFocused = props.isFocused,
        isRtl = props.isRtl,
        colors = props.theme.colors;
      var color = isFocused ? colors.neutral80 : colors.neutral20;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends({}, innerProps, {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("loadingIndicator", props)
            ),
            { indicator: true, "loading-indicator": true },
            className
          )
        }),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          LoadingDot,
          { color: color, delay: 0, offset: isRtl }
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          LoadingDot,
          { color: color, delay: 160, offset: true }
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          LoadingDot,
          { color: color, delay: 320, offset: !isRtl }
        )
      );
    };
    LoadingIndicator.defaultProps = { size: 4 };
    var css$1 = function css$$1(_ref) {
      var isDisabled = _ref.isDisabled,
        isFocused = _ref.isFocused,
        _ref$theme = _ref.theme,
        colors = _ref$theme.colors,
        borderRadius = _ref$theme.borderRadius,
        spacing = _ref$theme.spacing;
      return {
        alignItems: "center",
        backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
        borderColor: isDisabled
          ? colors.neutral10
          : isFocused
          ? colors.primary
          : colors.neutral20,
        borderRadius: borderRadius,
        borderStyle: "solid",
        borderWidth: 1,
        boxShadow: isFocused ? "0 0 0 1px " + colors.primary : null,
        cursor: "default",
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-between",
        minHeight: spacing.controlHeight,
        outline: "0 !important",
        position: "relative",
        transition: "all 100ms",
        "&:hover": {
          borderColor: isFocused ? colors.primary : colors.neutral30
        }
      };
    };
    var Control = function Control(props) {
      var children = props.children,
        cx = props.cx,
        getStyles = props.getStyles,
        className = props.className,
        isDisabled = props.isDisabled,
        isFocused = props.isFocused,
        innerRef = props.innerRef,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            ref: innerRef,
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("control", props)
              ),
              {
                control: true,
                "control--is-disabled": isDisabled,
                "control--is-focused": isFocused
              },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    var groupCSS = function groupCSS(_ref) {
      var spacing = _ref.theme.spacing;
      return {
        paddingBottom: spacing.baseUnit * 2,
        paddingTop: spacing.baseUnit * 2
      };
    };
    var Group = function Group(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        Heading = props.Heading,
        headingProps = props.headingProps,
        label = props.label,
        theme = props.theme;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        {
          className: cx(
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
              getStyles("group", props)
            ),
            { group: true },
            className
          )
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          Heading,
          _extends({}, headingProps, {
            theme: theme,
            getStyles: getStyles,
            cx: cx
          }),
          label
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          "div",
          null,
          children
        )
      );
    };
    var groupHeadingCSS = function groupHeadingCSS(_ref2) {
      var spacing = _ref2.theme.spacing;
      return {
        color: "#999",
        cursor: "default",
        display: "block",
        fontSize: "75%",
        fontWeight: "500",
        marginBottom: "0.25em",
        paddingLeft: spacing.baseUnit * 3,
        paddingRight: spacing.baseUnit * 3,
        textTransform: "uppercase"
      };
    };
    var GroupHeading = function GroupHeading(props) {
      var className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        theme = props.theme,
        cleanProps = objectWithoutProperties(props, [
          "className",
          "cx",
          "getStyles",
          "theme"
        ]);
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles(
                  "groupHeading",
                  _extends({ theme: theme }, cleanProps)
                )
              ),
              { "group-heading": true },
              className
            )
          },
          cleanProps
        )
      );
    };
    var inputCSS = function inputCSS(_ref) {
      var isDisabled = _ref.isDisabled,
        _ref$theme = _ref.theme,
        spacing = _ref$theme.spacing,
        colors = _ref$theme.colors;
      return {
        margin: spacing.baseUnit / 2,
        paddingBottom: spacing.baseUnit / 2,
        paddingTop: spacing.baseUnit / 2,
        visibility: isDisabled ? "hidden" : "visible",
        color: colors.neutral80
      };
    };
    var inputStyle = function inputStyle(isHidden) {
      return {
        background: 0,
        border: 0,
        fontSize: "inherit",
        opacity: isHidden ? 0 : 1,
        outline: 0,
        padding: 0,
        color: "inherit"
      };
    };
    var Input = function Input(_ref2) {
      var className = _ref2.className,
        cx = _ref2.cx,
        getStyles = _ref2.getStyles,
        innerRef = _ref2.innerRef,
        isHidden = _ref2.isHidden,
        isDisabled = _ref2.isDisabled,
        theme = _ref2.theme,
        props = objectWithoutProperties(_ref2, [
          "className",
          "cx",
          "getStyles",
          "innerRef",
          "isHidden",
          "isDisabled",
          "theme"
        ]);
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        {
          className: __webpack_require__.i(
            __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
          )(getStyles("input", _extends({ theme: theme }, props)))
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          __WEBPACK_IMPORTED_MODULE_5_react_input_autosize___default.a,
          _extends(
            {
              className: cx(null, { input: true }, className),
              inputRef: innerRef,
              inputStyle: inputStyle(isHidden),
              disabled: isDisabled
            },
            props
          )
        )
      );
    };
    var multiValueCSS = function multiValueCSS(_ref) {
      var _ref$theme = _ref.theme,
        spacing = _ref$theme.spacing,
        borderRadius = _ref$theme.borderRadius,
        colors = _ref$theme.colors;
      return {
        backgroundColor: colors.neutral10,
        borderRadius: borderRadius / 2,
        display: "flex",
        margin: spacing.baseUnit / 2,
        minWidth: 0
      };
    };
    var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
      var _ref2$theme = _ref2.theme,
        borderRadius = _ref2$theme.borderRadius,
        colors = _ref2$theme.colors,
        cropWithEllipsis = _ref2.cropWithEllipsis;
      return {
        borderRadius: borderRadius / 2,
        color: colors.neutral80,
        fontSize: "85%",
        overflow: "hidden",
        padding: 3,
        paddingLeft: 6,
        textOverflow: cropWithEllipsis ? "ellipsis" : null,
        whiteSpace: "nowrap"
      };
    };
    var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
      var _ref3$theme = _ref3.theme,
        spacing = _ref3$theme.spacing,
        borderRadius = _ref3$theme.borderRadius,
        colors = _ref3$theme.colors,
        isFocused = _ref3.isFocused;
      return {
        alignItems: "center",
        borderRadius: borderRadius / 2,
        backgroundColor: isFocused && colors.dangerLight,
        display: "flex",
        paddingLeft: spacing.baseUnit,
        paddingRight: spacing.baseUnit,
        ":hover": { backgroundColor: colors.dangerLight, color: colors.danger }
      };
    };
    var MultiValueGeneric = function MultiValueGeneric(_ref4) {
      var children = _ref4.children,
        innerProps = _ref4.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        innerProps,
        children
      );
    };
    var MultiValueContainer = MultiValueGeneric;
    var MultiValueLabel = MultiValueGeneric;
    var MultiValueRemove = (function(_Component) {
      inherits(MultiValueRemove, _Component);
      function MultiValueRemove() {
        classCallCheck(this, MultiValueRemove);
        return possibleConstructorReturn(
          this,
          (
            MultiValueRemove.__proto__ ||
            Object.getPrototypeOf(MultiValueRemove)
          ).apply(this, arguments)
        );
      }
      createClass(MultiValueRemove, [
        {
          key: "render",
          value: function render() {
            var _props = this.props,
              children = _props.children,
              innerProps = _props.innerProps;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              "div",
              innerProps,
              children
            );
          }
        }
      ]);
      return MultiValueRemove;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    MultiValueRemove.defaultProps = {
      children: __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        CrossIcon,
        { size: 14 }
      )
    };
    var MultiValue = (function(_Component2) {
      inherits(MultiValue, _Component2);
      function MultiValue() {
        classCallCheck(this, MultiValue);
        return possibleConstructorReturn(
          this,
          (MultiValue.__proto__ || Object.getPrototypeOf(MultiValue)).apply(
            this,
            arguments
          )
        );
      }
      createClass(MultiValue, [
        {
          key: "render",
          value: function render() {
            var _props2 = this.props,
              children = _props2.children,
              className = _props2.className,
              components = _props2.components,
              cx = _props2.cx,
              data = _props2.data,
              getStyles = _props2.getStyles,
              innerProps = _props2.innerProps,
              isDisabled = _props2.isDisabled,
              removeProps = _props2.removeProps,
              selectProps = _props2.selectProps;
            var Container = components.Container,
              Label = components.Label,
              Remove = components.Remove;
            var containerInnerProps = _extends(
              {
                className: cx(
                  __webpack_require__.i(
                    __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                  )(getStyles("multiValue", this.props)),
                  {
                    "multi-value": true,
                    "multi-value--is-disabled": isDisabled
                  },
                  className
                )
              },
              innerProps
            );
            var labelInnerProps = {
              className: cx(
                __webpack_require__.i(
                  __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                )(getStyles("multiValueLabel", this.props)),
                { "multi-value__label": true },
                className
              )
            };
            var removeInnerProps = _extends(
              {
                className: cx(
                  __webpack_require__.i(
                    __WEBPACK_IMPORTED_MODULE_2_emotion__["a"]
                  )(getStyles("multiValueRemove", this.props)),
                  { "multi-value__remove": true },
                  className
                )
              },
              removeProps
            );
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              Container,
              {
                data: data,
                innerProps: containerInnerProps,
                selectProps: selectProps
              },
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                Label,
                {
                  data: data,
                  innerProps: labelInnerProps,
                  selectProps: selectProps
                },
                children
              ),
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                Remove,
                {
                  data: data,
                  innerProps: removeInnerProps,
                  selectProps: selectProps
                }
              )
            );
          }
        }
      ]);
      return MultiValue;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    MultiValue.defaultProps = { cropWithEllipsis: true };
    var optionCSS = function optionCSS(_ref) {
      var isDisabled = _ref.isDisabled,
        isFocused = _ref.isFocused,
        isSelected = _ref.isSelected,
        _ref$theme = _ref.theme,
        spacing = _ref$theme.spacing,
        colors = _ref$theme.colors;
      return {
        backgroundColor: isSelected
          ? colors.primary
          : isFocused
          ? colors.primary25
          : "transparent",
        color: isDisabled
          ? colors.neutral20
          : isSelected
          ? colors.neutral0
          : "inherit",
        cursor: "default",
        display: "block",
        fontSize: "inherit",
        padding: spacing.baseUnit * 2 + "px " + spacing.baseUnit * 3 + "px",
        width: "100%",
        userSelect: "none",
        WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
        ":active": {
          backgroundColor: isSelected ? colors.primary : colors.primary50
        }
      };
    };
    var Option = function Option(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        isDisabled = props.isDisabled,
        isFocused = props.isFocused,
        isSelected = props.isSelected,
        innerRef = props.innerRef,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            ref: innerRef,
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("option", props)
              ),
              {
                option: true,
                "option--is-disabled": isDisabled,
                "option--is-focused": isFocused,
                "option--is-selected": isSelected
              },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    var placeholderCSS = function placeholderCSS(_ref) {
      var _ref$theme = _ref.theme,
        spacing = _ref$theme.spacing,
        colors = _ref$theme.colors;
      return {
        color: colors.neutral50,
        marginLeft: spacing.baseUnit / 2,
        marginRight: spacing.baseUnit / 2,
        position: "absolute",
        top: "50%",
        transform: "translateY(-50%)"
      };
    };
    var Placeholder = function Placeholder(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("placeholder", props)
              ),
              { placeholder: true },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    var css$2 = function css$$1(_ref) {
      var isDisabled = _ref.isDisabled,
        _ref$theme = _ref.theme,
        spacing = _ref$theme.spacing,
        colors = _ref$theme.colors;
      return {
        color: isDisabled ? colors.neutral40 : colors.neutral80,
        marginLeft: spacing.baseUnit / 2,
        marginRight: spacing.baseUnit / 2,
        maxWidth: "calc(100% - " + spacing.baseUnit * 2 + "px)",
        overflow: "hidden",
        position: "absolute",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        top: "50%",
        transform: "translateY(-50%)"
      };
    };
    var SingleValue = function SingleValue(props) {
      var children = props.children,
        className = props.className,
        cx = props.cx,
        getStyles = props.getStyles,
        isDisabled = props.isDisabled,
        innerProps = props.innerProps;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        "div",
        _extends(
          {
            className: cx(
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_emotion__["a"])(
                getStyles("singleValue", props)
              ),
              { "single-value": true, "single-value--is-disabled": isDisabled },
              className
            )
          },
          innerProps
        ),
        children
      );
    };
    var components = {
      ClearIndicator: ClearIndicator,
      Control: Control,
      DropdownIndicator: DropdownIndicator,
      DownChevron: DownChevron,
      CrossIcon: CrossIcon,
      Group: Group,
      GroupHeading: GroupHeading,
      IndicatorsContainer: IndicatorsContainer,
      IndicatorSeparator: IndicatorSeparator,
      Input: Input,
      LoadingIndicator: LoadingIndicator,
      Menu: Menu,
      MenuList: MenuList,
      MenuPortal: MenuPortal,
      LoadingMessage: LoadingMessage,
      NoOptionsMessage: NoOptionsMessage,
      MultiValue: MultiValue,
      MultiValueContainer: MultiValueContainer,
      MultiValueLabel: MultiValueLabel,
      MultiValueRemove: MultiValueRemove,
      Option: Option,
      Placeholder: Placeholder,
      SelectContainer: SelectContainer,
      SingleValue: SingleValue,
      ValueContainer: ValueContainer
    };
    var defaultComponents = function defaultComponents(props) {
      return _extends({}, components, props.components);
    };
    var defaultStyles = {
      clearIndicator: clearIndicatorCSS,
      container: containerCSS,
      control: css$1,
      dropdownIndicator: dropdownIndicatorCSS,
      group: groupCSS,
      groupHeading: groupHeadingCSS,
      indicatorsContainer: indicatorsContainerCSS,
      indicatorSeparator: indicatorSeparatorCSS,
      input: inputCSS,
      loadingIndicator: loadingIndicatorCSS,
      loadingMessage: loadingMessageCSS,
      menu: menuCSS,
      menuList: menuListCSS,
      menuPortal: menuPortalCSS,
      multiValue: multiValueCSS,
      multiValueLabel: multiValueLabelCSS,
      multiValueRemove: multiValueRemoveCSS,
      noOptionsMessage: noOptionsMessageCSS,
      option: optionCSS,
      placeholder: placeholderCSS,
      singleValue: css$2,
      valueContainer: valueContainerCSS
    };
    function mergeStyles(source) {
      var target =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var styles = _extends({}, source);
      Object.keys(target).forEach(function(key) {
        if (source[key]) {
          styles[key] = function(rsCss, props) {
            return target[key](source[key](rsCss, props), props);
          };
        } else {
          styles[key] = target[key];
        }
      });
      return styles;
    }
    var colors = {
      primary: "#2684FF",
      primary75: "#4C9AFF",
      primary50: "#B2D4FF",
      primary25: "#DEEBFF",
      danger: "#DE350B",
      dangerLight: "#FFBDAD",
      neutral0: "hsl(0, 0%, 100%)",
      neutral5: "hsl(0, 0%, 95%)",
      neutral10: "hsl(0, 0%, 90%)",
      neutral20: "hsl(0, 0%, 80%)",
      neutral30: "hsl(0, 0%, 70%)",
      neutral40: "hsl(0, 0%, 60%)",
      neutral50: "hsl(0, 0%, 50%)",
      neutral60: "hsl(0, 0%, 40%)",
      neutral70: "hsl(0, 0%, 30%)",
      neutral80: "hsl(0, 0%, 20%)",
      neutral90: "hsl(0, 0%, 10%)"
    };
    var borderRadius = 4;
    var baseUnit = 4;
    var controlHeight = 38;
    var menuGutter = baseUnit * 2;
    var spacing = {
      baseUnit: baseUnit,
      controlHeight: controlHeight,
      menuGutter: menuGutter
    };
    var defaultTheme = {
      borderRadius: borderRadius,
      colors: colors,
      spacing: spacing
    };
    var defaultProps = {
      backspaceRemovesValue: true,
      blurInputOnSelect: isTouchCapable(),
      captureMenuScroll: !isTouchCapable(),
      closeMenuOnSelect: true,
      closeMenuOnScroll: false,
      components: {},
      controlShouldRenderValue: true,
      escapeClearsValue: false,
      filterOption: createFilter(),
      formatGroupLabel: formatGroupLabel,
      getOptionLabel: getOptionLabel,
      getOptionValue: getOptionValue,
      isDisabled: false,
      isLoading: false,
      isMulti: false,
      isRtl: false,
      isSearchable: true,
      isOptionDisabled: isOptionDisabled,
      loadingMessage: function loadingMessage() {
        return "Loading...";
      },
      maxMenuHeight: 300,
      minMenuHeight: 140,
      menuIsOpen: false,
      menuPlacement: "bottom",
      menuPosition: "absolute",
      menuShouldBlockScroll: false,
      menuShouldScrollIntoView: !isMobileDevice(),
      noOptionsMessage: function noOptionsMessage() {
        return "No options";
      },
      openMenuOnFocus: false,
      openMenuOnClick: true,
      options: [],
      pageSize: 5,
      placeholder: "Select...",
      screenReaderStatus: function screenReaderStatus(_ref) {
        var count = _ref.count;
        return count + " result" + (count !== 1 ? "s" : "") + " available";
      },
      styles: {},
      tabIndex: "0",
      tabSelectsValue: true
    };
    var instanceId = 1;
    var Select = (function(_Component) {
      inherits(Select, _Component);
      function Select(props) {
        classCallCheck(this, Select);
        var _this = possibleConstructorReturn(
          this,
          (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props)
        );
        _initialiseProps.call(_this);
        var value = props.value;
        _this.cacheComponents = __webpack_require__
          .i(__WEBPACK_IMPORTED_MODULE_6_memoize_one__["a"])(
            _this.cacheComponents,
            exportedEqual
          )
          .bind(_this);
        _this.cacheComponents(props.components);
        _this.instancePrefix =
          "react-select-" + (_this.props.instanceId || ++instanceId);
        var selectValue = cleanValue(value);
        var menuOptions = _this.buildMenuOptions(props, selectValue);
        _this.state.menuOptions = menuOptions;
        _this.state.selectValue = selectValue;
        return _this;
      }
      createClass(Select, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.startListeningComposition();
            this.startListeningToTouch();
            if (
              this.props.closeMenuOnScroll &&
              document &&
              document.addEventListener
            ) {
              document.addEventListener("scroll", this.onScroll, true);
            }
            if (this.props.autoFocus) {
              this.focusInput();
            }
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            var _props = this.props,
              options = _props.options,
              value = _props.value,
              inputValue = _props.inputValue;
            this.cacheComponents(nextProps.components);
            if (
              nextProps.value !== value ||
              nextProps.options !== options ||
              nextProps.inputValue !== inputValue
            ) {
              var _selectValue = cleanValue(nextProps.value);
              var _menuOptions = this.buildMenuOptions(nextProps, _selectValue);
              var _focusedValue = this.getNextFocusedValue(_selectValue);
              var _focusedOption = this.getNextFocusedOption(
                _menuOptions.focusable
              );
              this.setState({
                menuOptions: _menuOptions,
                selectValue: _selectValue,
                focusedOption: _focusedOption,
                focusedValue: _focusedValue
              });
            }
            if (this.inputIsHiddenAfterUpdate != null) {
              this.setState({ inputIsHidden: this.inputIsHiddenAfterUpdate });
              delete this.inputIsHiddenAfterUpdate;
            }
          }
        },
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            var _props2 = this.props,
              isDisabled = _props2.isDisabled,
              menuIsOpen = _props2.menuIsOpen;
            var isFocused = this.state.isFocused;
            if (
              (isFocused && !isDisabled && prevProps.isDisabled) ||
              (isFocused && menuIsOpen && !prevProps.menuIsOpen)
            ) {
              this.focusInput();
            }
            if (
              this.menuListRef &&
              this.focusedOptionRef &&
              this.scrollToFocusedOptionOnUpdate
            ) {
              scrollIntoView(this.menuListRef, this.focusedOptionRef);
            }
            this.scrollToFocusedOptionOnUpdate = false;
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.stopListeningComposition();
            this.stopListeningToTouch();
            document.removeEventListener("scroll", this.onScroll, true);
          }
        },
        {
          key: "onMenuOpen",
          value: function onMenuOpen() {
            this.props.onMenuOpen();
          }
        },
        {
          key: "onMenuClose",
          value: function onMenuClose() {
            var _props3 = this.props,
              isSearchable = _props3.isSearchable,
              isMulti = _props3.isMulti;
            this.announceAriaLiveContext({
              event: "input",
              context: { isSearchable: isSearchable, isMulti: isMulti }
            });
            this.onInputChange("", { action: "menu-close" });
            this.props.onMenuClose();
          }
        },
        {
          key: "onInputChange",
          value: function onInputChange(newValue, actionMeta) {
            this.props.onInputChange(newValue, actionMeta);
          }
        },
        {
          key: "focusInput",
          value: function focusInput() {
            if (!this.inputRef) return;
            this.inputRef.focus();
          }
        },
        {
          key: "blurInput",
          value: function blurInput() {
            if (!this.inputRef) return;
            this.inputRef.blur();
          }
        },
        {
          key: "openMenu",
          value: function openMenu(focusOption) {
            var _state = this.state,
              menuOptions = _state.menuOptions,
              selectValue = _state.selectValue;
            var isMulti = this.props.isMulti;
            var openAtIndex =
              focusOption === "first" ? 0 : menuOptions.focusable.length - 1;
            if (!isMulti) {
              var selectedIndex = menuOptions.focusable.indexOf(selectValue[0]);
              if (selectedIndex > -1) {
                openAtIndex = selectedIndex;
              }
            }
            this.scrollToFocusedOptionOnUpdate = true;
            this.inputIsHiddenAfterUpdate = false;
            this.onMenuOpen();
            this.setState({
              focusedValue: null,
              focusedOption: menuOptions.focusable[openAtIndex]
            });
            this.announceAriaLiveContext({ event: "menu" });
          }
        },
        {
          key: "focusValue",
          value: function focusValue(direction) {
            var _props4 = this.props,
              isMulti = _props4.isMulti,
              isSearchable = _props4.isSearchable;
            var _state2 = this.state,
              selectValue = _state2.selectValue,
              focusedValue = _state2.focusedValue;
            if (!isMulti) return;
            this.setState({ focusedOption: null });
            var focusedIndex = selectValue.indexOf(focusedValue);
            if (!focusedValue) {
              focusedIndex = -1;
              this.announceAriaLiveContext({ event: "value" });
            }
            var lastIndex = selectValue.length - 1;
            var nextFocus = -1;
            if (!selectValue.length) return;
            switch (direction) {
              case "previous":
                if (focusedIndex === 0) {
                  nextFocus = 0;
                } else if (focusedIndex === -1) {
                  nextFocus = lastIndex;
                } else {
                  nextFocus = focusedIndex - 1;
                }
                break;
              case "next":
                if (focusedIndex > -1 && focusedIndex < lastIndex) {
                  nextFocus = focusedIndex + 1;
                }
                break;
            }
            if (nextFocus === -1) {
              this.announceAriaLiveContext({
                event: "input",
                context: { isSearchable: isSearchable, isMulti: isMulti }
              });
            }
            this.setState({
              inputIsHidden: nextFocus === -1 ? false : true,
              focusedValue: selectValue[nextFocus]
            });
          }
        },
        {
          key: "focusOption",
          value: function focusOption() {
            var direction =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : "first";
            var pageSize = this.props.pageSize;
            var _state3 = this.state,
              focusedOption = _state3.focusedOption,
              menuOptions = _state3.menuOptions;
            var options = menuOptions.focusable;
            if (!options.length) return;
            var nextFocus = 0;
            var focusedIndex = options.indexOf(focusedOption);
            if (!focusedOption) {
              focusedIndex = -1;
              this.announceAriaLiveContext({ event: "menu" });
            }
            if (direction === "up") {
              nextFocus =
                focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
            } else if (direction === "down") {
              nextFocus = (focusedIndex + 1) % options.length;
            } else if (direction === "pageup") {
              nextFocus = focusedIndex - pageSize;
              if (nextFocus < 0) nextFocus = 0;
            } else if (direction === "pagedown") {
              nextFocus = focusedIndex + pageSize;
              if (nextFocus > options.length - 1)
                nextFocus = options.length - 1;
            } else if (direction === "last") {
              nextFocus = options.length - 1;
            }
            this.scrollToFocusedOptionOnUpdate = true;
            this.setState({
              focusedOption: options[nextFocus],
              focusedValue: null
            });
          }
        },
        {
          key: "getTheme",
          value: function getTheme() {
            if (!this.props.theme) {
              return defaultTheme;
            }
            if (typeof this.props.theme === "function") {
              return this.props.theme(defaultTheme);
            }
            return _extends({}, defaultTheme, this.props.theme);
          }
        },
        {
          key: "getCommonProps",
          value: function getCommonProps() {
            var clearValue = this.clearValue,
              getStyles = this.getStyles,
              setValue = this.setValue,
              selectOption = this.selectOption,
              props = this.props;
            var classNamePrefix = props.classNamePrefix,
              isMulti = props.isMulti,
              isRtl = props.isRtl,
              options = props.options;
            var selectValue = this.state.selectValue;
            var hasValue = this.hasValue();
            var getValue = function getValue() {
              return selectValue;
            };
            var cxPrefix = classNamePrefix;
            var cx = classNames.bind(null, cxPrefix);
            return {
              cx: cx,
              clearValue: clearValue,
              getStyles: getStyles,
              getValue: getValue,
              hasValue: hasValue,
              isMulti: isMulti,
              isRtl: isRtl,
              options: options,
              selectOption: selectOption,
              setValue: setValue,
              selectProps: props,
              theme: this.getTheme()
            };
          }
        },
        {
          key: "getNextFocusedValue",
          value: function getNextFocusedValue(nextSelectValue) {
            if (this.clearFocusValueOnUpdate) {
              this.clearFocusValueOnUpdate = false;
              return null;
            }
            var _state4 = this.state,
              focusedValue = _state4.focusedValue,
              lastSelectValue = _state4.selectValue;
            var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
            if (lastFocusedIndex > -1) {
              var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
              if (nextFocusedIndex > -1) {
                return focusedValue;
              } else if (lastFocusedIndex < nextSelectValue.length) {
                return nextSelectValue[lastFocusedIndex];
              }
            }
            return null;
          }
        },
        {
          key: "getNextFocusedOption",
          value: function getNextFocusedOption(options) {
            var lastFocusedOption = this.state.focusedOption;
            return lastFocusedOption && options.indexOf(lastFocusedOption) > -1
              ? lastFocusedOption
              : options[0];
          }
        },
        {
          key: "hasValue",
          value: function hasValue() {
            var selectValue = this.state.selectValue;
            return selectValue.length > 0;
          }
        },
        {
          key: "hasOptions",
          value: function hasOptions() {
            return !!this.state.menuOptions.render.length;
          }
        },
        {
          key: "countOptions",
          value: function countOptions() {
            return this.state.menuOptions.focusable.length;
          }
        },
        {
          key: "isClearable",
          value: function isClearable() {
            var _props5 = this.props,
              isClearable = _props5.isClearable,
              isMulti = _props5.isMulti;
            if (isClearable === undefined) return isMulti;
            return isClearable;
          }
        },
        {
          key: "isOptionDisabled",
          value: function isOptionDisabled$$1(option, selectValue) {
            return typeof this.props.isOptionDisabled === "function"
              ? this.props.isOptionDisabled(option, selectValue)
              : false;
          }
        },
        {
          key: "isOptionSelected",
          value: function isOptionSelected(option, selectValue) {
            var _this2 = this;
            if (selectValue.indexOf(option) > -1) return true;
            if (typeof this.props.isOptionSelected === "function") {
              return this.props.isOptionSelected(option, selectValue);
            }
            var candidate = this.getOptionValue(option);
            return selectValue.some(function(i) {
              return _this2.getOptionValue(i) === candidate;
            });
          }
        },
        {
          key: "filterOption",
          value: function filterOption(option, inputValue) {
            return this.props.filterOption
              ? this.props.filterOption(option, inputValue)
              : true;
          }
        },
        {
          key: "formatOptionLabel",
          value: function formatOptionLabel(data, context) {
            if (typeof this.props.formatOptionLabel === "function") {
              var _inputValue = this.props.inputValue;
              var _selectValue2 = this.state.selectValue;
              return this.props.formatOptionLabel(data, {
                context: context,
                inputValue: _inputValue,
                selectValue: _selectValue2
              });
            } else {
              return this.getOptionLabel(data);
            }
          }
        },
        {
          key: "formatGroupLabel",
          value: function formatGroupLabel$$1(data) {
            return this.props.formatGroupLabel(data);
          }
        },
        {
          key: "startListeningComposition",
          value: function startListeningComposition() {
            if (document && document.addEventListener) {
              document.addEventListener(
                "compositionstart",
                this.onCompositionStart,
                false
              );
              document.addEventListener(
                "compositionend",
                this.onCompositionEnd,
                false
              );
            }
          }
        },
        {
          key: "stopListeningComposition",
          value: function stopListeningComposition() {
            if (document && document.removeEventListener) {
              document.removeEventListener(
                "compositionstart",
                this.onCompositionStart
              );
              document.removeEventListener(
                "compositionend",
                this.onCompositionEnd
              );
            }
          }
        },
        {
          key: "startListeningToTouch",
          value: function startListeningToTouch() {
            if (document && document.addEventListener) {
              document.addEventListener("touchstart", this.onTouchStart, false);
              document.addEventListener("touchmove", this.onTouchMove, false);
              document.addEventListener("touchend", this.onTouchEnd, false);
            }
          }
        },
        {
          key: "stopListeningToTouch",
          value: function stopListeningToTouch() {
            if (document && document.removeEventListener) {
              document.removeEventListener("touchstart", this.onTouchStart);
              document.removeEventListener("touchmove", this.onTouchMove);
              document.removeEventListener("touchend", this.onTouchEnd);
            }
          }
        },
        {
          key: "buildMenuOptions",
          value: function buildMenuOptions(props, selectValue) {
            var _this3 = this;
            var _props$inputValue = props.inputValue,
              inputValue =
                _props$inputValue === undefined ? "" : _props$inputValue,
              options = props.options;
            var toOption = function toOption(option, id) {
              var isDisabled = _this3.isOptionDisabled(option, selectValue);
              var isSelected = _this3.isOptionSelected(option, selectValue);
              var label = _this3.getOptionLabel(option);
              var value = _this3.getOptionValue(option);
              if (
                (_this3.shouldHideSelectedOptions() && isSelected) ||
                !_this3.filterOption(
                  { label: label, value: value, data: option },
                  inputValue
                )
              ) {
                return;
              }
              var onHover = isDisabled
                ? undefined
                : function() {
                    return _this3.onOptionHover(option);
                  };
              var onSelect = isDisabled
                ? undefined
                : function() {
                    return _this3.selectOption(option);
                  };
              var optionId = _this3.getElementId("option") + "-" + id;
              return {
                innerProps: {
                  id: optionId,
                  onClick: onSelect,
                  onMouseMove: onHover,
                  onMouseOver: onHover,
                  role: "option",
                  tabIndex: -1
                },
                data: option,
                isDisabled: isDisabled,
                isSelected: isSelected,
                key: optionId,
                label: label,
                type: "option",
                value: value
              };
            };
            return options.reduce(
              function(acc, item, itemIndex) {
                if (item.options) {
                  if (!_this3.hasGroups) _this3.hasGroups = true;
                  var items = item.options;
                  var children = items
                    .map(function(child, i) {
                      var option = toOption(child, itemIndex + "-" + i);
                      if (option && !option.isDisabled)
                        acc.focusable.push(child);
                      return option;
                    })
                    .filter(Boolean);
                  if (children.length) {
                    var groupId =
                      _this3.getElementId("group") + "-" + itemIndex;
                    acc.render.push({
                      type: "group",
                      key: groupId,
                      data: item,
                      options: children
                    });
                  }
                } else {
                  var option = toOption(item, "" + itemIndex);
                  if (option) {
                    acc.render.push(option);
                    if (!option.isDisabled) acc.focusable.push(item);
                  }
                }
                return acc;
              },
              { render: [], focusable: [] }
            );
          }
        },
        {
          key: "constructAriaLiveMessage",
          value: function constructAriaLiveMessage() {
            var _state5 = this.state,
              ariaLiveContext = _state5.ariaLiveContext,
              selectValue = _state5.selectValue,
              focusedValue = _state5.focusedValue,
              focusedOption = _state5.focusedOption;
            var _props6 = this.props,
              options = _props6.options,
              menuIsOpen = _props6.menuIsOpen,
              inputValue = _props6.inputValue,
              screenReaderStatus = _props6.screenReaderStatus;
            var focusedValueMsg = focusedValue
              ? valueFocusAriaMessage({
                  focusedValue: focusedValue,
                  getOptionLabel: this.getOptionLabel,
                  selectValue: selectValue
                })
              : "";
            var focusedOptionMsg =
              focusedOption && menuIsOpen
                ? optionFocusAriaMessage({
                    focusedOption: focusedOption,
                    getOptionLabel: this.getOptionLabel,
                    options: options
                  })
                : "";
            var resultsMsg = resultsAriaMessage({
              inputValue: inputValue,
              screenReaderMessage: screenReaderStatus({
                count: this.countOptions()
              })
            });
            return (
              focusedValueMsg +
              " " +
              focusedOptionMsg +
              " " +
              resultsMsg +
              " " +
              ariaLiveContext
            );
          }
        },
        {
          key: "renderInput",
          value: function renderInput() {
            var _props7 = this.props,
              isDisabled = _props7.isDisabled,
              isSearchable = _props7.isSearchable,
              inputId = _props7.inputId,
              inputValue = _props7.inputValue,
              tabIndex = _props7.tabIndex;
            var Input = this.components.Input;
            var inputIsHidden = this.state.inputIsHidden;
            var id = inputId || this.getElementId("input");
            if (!isSearchable) {
              return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                DummyInput,
                {
                  id: id,
                  innerRef: this.getInputRef,
                  onBlur: this.onInputBlur,
                  onChange: noop,
                  onFocus: this.onInputFocus,
                  readOnly: true,
                  disabled: isDisabled,
                  tabIndex: tabIndex,
                  value: ""
                }
              );
            }
            var ariaAttributes = {
              "aria-autocomplete": "list",
              "aria-label": this.props["aria-label"],
              "aria-labelledby": this.props["aria-labelledby"]
            };
            var _commonProps = this.commonProps,
              cx = _commonProps.cx,
              theme = _commonProps.theme;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              Input,
              _extends(
                {
                  autoCapitalize: "none",
                  autoComplete: "off",
                  autoCorrect: "off",
                  cx: cx,
                  getStyles: this.getStyles,
                  id: id,
                  innerRef: this.getInputRef,
                  isDisabled: isDisabled,
                  isHidden: inputIsHidden,
                  onBlur: this.onInputBlur,
                  onChange: this.handleInputChange,
                  onFocus: this.onInputFocus,
                  spellCheck: "false",
                  tabIndex: tabIndex,
                  theme: theme,
                  type: "text",
                  value: inputValue
                },
                ariaAttributes
              )
            );
          }
        },
        {
          key: "renderPlaceholderOrValue",
          value: function renderPlaceholderOrValue() {
            var _this4 = this;
            var _components = this.components,
              MultiValue = _components.MultiValue,
              MultiValueContainer = _components.MultiValueContainer,
              MultiValueLabel = _components.MultiValueLabel,
              MultiValueRemove = _components.MultiValueRemove,
              SingleValue = _components.SingleValue,
              Placeholder = _components.Placeholder;
            var commonProps = this.commonProps;
            var _props8 = this.props,
              controlShouldRenderValue = _props8.controlShouldRenderValue,
              isDisabled = _props8.isDisabled,
              isMulti = _props8.isMulti,
              inputValue = _props8.inputValue,
              placeholder = _props8.placeholder;
            var _state6 = this.state,
              selectValue = _state6.selectValue,
              focusedValue = _state6.focusedValue,
              isFocused = _state6.isFocused;
            if (!this.hasValue() || !controlShouldRenderValue) {
              return inputValue
                ? null
                : __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                    Placeholder,
                    _extends({}, commonProps, {
                      key: "placeholder",
                      isDisabled: isDisabled,
                      isFocused: isFocused
                    }),
                    placeholder
                  );
            }
            if (isMulti) {
              var selectValues = selectValue.map(function(opt) {
                var isFocused = opt === focusedValue;
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  MultiValue,
                  _extends({}, commonProps, {
                    components: {
                      Container: MultiValueContainer,
                      Label: MultiValueLabel,
                      Remove: MultiValueRemove
                    },
                    isFocused: isFocused,
                    isDisabled: isDisabled,
                    key: _this4.getOptionValue(opt),
                    removeProps: {
                      onClick: function onClick() {
                        return _this4.removeValue(opt);
                      },
                      onTouchEnd: function onTouchEnd() {
                        return _this4.removeValue(opt);
                      },
                      onMouseDown: function onMouseDown(e) {
                        e.preventDefault();
                        e.stopPropagation();
                      }
                    },
                    data: opt
                  }),
                  _this4.formatOptionLabel(opt, "value")
                );
              });
              return selectValues;
            }
            if (inputValue) {
              return null;
            }
            var singleValue = selectValue[0];
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              SingleValue,
              _extends({}, commonProps, {
                data: singleValue,
                isDisabled: isDisabled
              }),
              this.formatOptionLabel(singleValue, "value")
            );
          }
        },
        {
          key: "renderClearIndicator",
          value: function renderClearIndicator() {
            var ClearIndicator = this.components.ClearIndicator;
            var commonProps = this.commonProps;
            var _props9 = this.props,
              isDisabled = _props9.isDisabled,
              isLoading = _props9.isLoading;
            var isFocused = this.state.isFocused;
            if (
              !this.isClearable() ||
              !ClearIndicator ||
              isDisabled ||
              !this.hasValue() ||
              isLoading
            ) {
              return null;
            }
            var innerProps = {
              onMouseDown: this.onClearIndicatorMouseDown,
              onTouchEnd: this.onClearIndicatorTouchEnd,
              "aria-hidden": "true"
            };
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              ClearIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isFocused: isFocused
              })
            );
          }
        },
        {
          key: "renderLoadingIndicator",
          value: function renderLoadingIndicator() {
            var LoadingIndicator = this.components.LoadingIndicator;
            var commonProps = this.commonProps;
            var _props10 = this.props,
              isDisabled = _props10.isDisabled,
              isLoading = _props10.isLoading;
            var isFocused = this.state.isFocused;
            if (!LoadingIndicator || !isLoading) return null;
            var innerProps = { "aria-hidden": "true" };
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              LoadingIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isDisabled: isDisabled,
                isFocused: isFocused
              })
            );
          }
        },
        {
          key: "renderIndicatorSeparator",
          value: function renderIndicatorSeparator() {
            var _components2 = this.components,
              DropdownIndicator = _components2.DropdownIndicator,
              IndicatorSeparator = _components2.IndicatorSeparator;
            if (!DropdownIndicator || !IndicatorSeparator) return null;
            var commonProps = this.commonProps;
            var isDisabled = this.props.isDisabled;
            var isFocused = this.state.isFocused;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              IndicatorSeparator,
              _extends({}, commonProps, {
                isDisabled: isDisabled,
                isFocused: isFocused
              })
            );
          }
        },
        {
          key: "renderDropdownIndicator",
          value: function renderDropdownIndicator() {
            var DropdownIndicator = this.components.DropdownIndicator;
            if (!DropdownIndicator) return null;
            var commonProps = this.commonProps;
            var isDisabled = this.props.isDisabled;
            var isFocused = this.state.isFocused;
            var innerProps = {
              onMouseDown: this.onDropdownIndicatorMouseDown,
              onTouchEnd: this.onDropdownIndicatorTouchEnd,
              "aria-hidden": "true"
            };
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              DropdownIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isDisabled: isDisabled,
                isFocused: isFocused
              })
            );
          }
        },
        {
          key: "renderMenu",
          value: function renderMenu() {
            var _this5 = this;
            var _components3 = this.components,
              Group = _components3.Group,
              GroupHeading = _components3.GroupHeading,
              Menu$$1 = _components3.Menu,
              MenuList$$1 = _components3.MenuList,
              MenuPortal$$1 = _components3.MenuPortal,
              LoadingMessage$$1 = _components3.LoadingMessage,
              NoOptionsMessage$$1 = _components3.NoOptionsMessage,
              Option = _components3.Option;
            var commonProps = this.commonProps;
            var _state7 = this.state,
              focusedOption = _state7.focusedOption,
              menuOptions = _state7.menuOptions;
            var _props11 = this.props,
              captureMenuScroll = _props11.captureMenuScroll,
              inputValue = _props11.inputValue,
              isLoading = _props11.isLoading,
              loadingMessage = _props11.loadingMessage,
              minMenuHeight = _props11.minMenuHeight,
              maxMenuHeight = _props11.maxMenuHeight,
              menuIsOpen = _props11.menuIsOpen,
              menuPlacement = _props11.menuPlacement,
              menuPosition = _props11.menuPosition,
              menuPortalTarget = _props11.menuPortalTarget,
              menuShouldBlockScroll = _props11.menuShouldBlockScroll,
              menuShouldScrollIntoView = _props11.menuShouldScrollIntoView,
              noOptionsMessage = _props11.noOptionsMessage,
              onMenuScrollToTop = _props11.onMenuScrollToTop,
              onMenuScrollToBottom = _props11.onMenuScrollToBottom;
            if (!menuIsOpen) return null;
            var render = function render(props) {
              var isFocused = focusedOption === props.data;
              props.innerRef = isFocused
                ? _this5.getFocusedOptionRef
                : undefined;
              return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                Option,
                _extends({}, commonProps, props, { isFocused: isFocused }),
                _this5.formatOptionLabel(props.data, "menu")
              );
            };
            var menuUI = void 0;
            if (this.hasOptions()) {
              menuUI = menuOptions.render.map(function(item) {
                if (item.type === "group") {
                  var type = item.type,
                    group = objectWithoutProperties(item, ["type"]);
                  var headingId = item.key + "-heading";
                  return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                    Group,
                    _extends({}, commonProps, group, {
                      Heading: GroupHeading,
                      headingProps: { id: headingId },
                      label: _this5.formatGroupLabel(item.data)
                    }),
                    item.options.map(function(option) {
                      return render(option);
                    })
                  );
                } else if (item.type === "option") {
                  return render(item);
                }
              });
            } else if (isLoading) {
              var message = loadingMessage({ inputValue: inputValue });
              if (message === null) return null;
              menuUI = __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                LoadingMessage$$1,
                commonProps,
                message
              );
            } else {
              var _message = noOptionsMessage({ inputValue: inputValue });
              if (_message === null) return null;
              menuUI = __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                NoOptionsMessage$$1,
                commonProps,
                _message
              );
            }
            var menuPlacementProps = {
              minMenuHeight: minMenuHeight,
              maxMenuHeight: maxMenuHeight,
              menuPlacement: menuPlacement,
              menuPosition: menuPosition,
              menuShouldScrollIntoView: menuShouldScrollIntoView
            };
            var menuElement = __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              MenuPlacer,
              _extends({}, commonProps, menuPlacementProps),
              function(_ref2) {
                var ref = _ref2.ref,
                  _ref2$placerProps = _ref2.placerProps,
                  placement = _ref2$placerProps.placement,
                  maxHeight = _ref2$placerProps.maxHeight;
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  Menu$$1,
                  _extends({}, commonProps, menuPlacementProps, {
                    innerRef: ref,
                    innerProps: {
                      onMouseDown: _this5.onMenuMouseDown,
                      onMouseMove: _this5.onMenuMouseMove
                    },
                    isLoading: isLoading,
                    placement: placement
                  }),
                  __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                    ScrollCaptorSwitch,
                    {
                      isEnabled: captureMenuScroll,
                      onTopArrive: onMenuScrollToTop,
                      onBottomArrive: onMenuScrollToBottom
                    },
                    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                      ScrollBlock,
                      { isEnabled: menuShouldBlockScroll },
                      __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                        MenuList$$1,
                        _extends({}, commonProps, {
                          innerRef: _this5.getMenuListRef,
                          isLoading: isLoading,
                          maxHeight: maxHeight
                        }),
                        menuUI
                      )
                    )
                  )
                );
              }
            );
            return menuPortalTarget || menuPosition === "fixed"
              ? __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  MenuPortal$$1,
                  _extends({}, commonProps, {
                    appendTo: menuPortalTarget,
                    controlElement: this.controlRef,
                    menuPlacement: menuPlacement,
                    menuPosition: menuPosition
                  }),
                  menuElement
                )
              : menuElement;
          }
        },
        {
          key: "renderFormField",
          value: function renderFormField() {
            var _this6 = this;
            var _props12 = this.props,
              delimiter = _props12.delimiter,
              isDisabled = _props12.isDisabled,
              isMulti = _props12.isMulti,
              name = _props12.name;
            var selectValue = this.state.selectValue;
            if (!name || isDisabled) return;
            if (isMulti) {
              if (delimiter) {
                var _value = selectValue
                  .map(function(opt) {
                    return _this6.getOptionValue(opt);
                  })
                  .join(delimiter);
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  "input",
                  { name: name, type: "hidden", value: _value }
                );
              } else {
                var input =
                  selectValue.length > 0
                    ? selectValue.map(function(opt, i) {
                        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                          "input",
                          {
                            key: "i-" + i,
                            name: name,
                            type: "hidden",
                            value: _this6.getOptionValue(opt)
                          }
                        );
                      })
                    : __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                        "input",
                        { name: name, type: "hidden" }
                      );
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  "div",
                  null,
                  input
                );
              }
            } else {
              var _value2 = selectValue[0]
                ? this.getOptionValue(selectValue[0])
                : "";
              return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                "input",
                { name: name, type: "hidden", value: _value2 }
              );
            }
          }
        },
        {
          key: "renderLiveRegion",
          value: function renderLiveRegion() {
            if (!this.state.isFocused) return null;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              A11yText,
              { "aria-live": "assertive" },
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                "p",
                { id: "aria-selection-event" },
                "\xA0",
                this.state.ariaLiveSelection
              ),
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                "p",
                { id: "aria-context" },
                "\xA0",
                this.constructAriaLiveMessage()
              )
            );
          }
        },
        {
          key: "render",
          value: function render() {
            var _components4 = this.components,
              Control = _components4.Control,
              IndicatorsContainer = _components4.IndicatorsContainer,
              SelectContainer = _components4.SelectContainer,
              ValueContainer = _components4.ValueContainer;
            var _props13 = this.props,
              className = _props13.className,
              id = _props13.id,
              isDisabled = _props13.isDisabled;
            var isFocused = this.state.isFocused;
            var commonProps = (this.commonProps = this.getCommonProps());
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              SelectContainer,
              _extends({}, commonProps, {
                className: className,
                innerProps: { id: id, onKeyDown: this.onKeyDown },
                isDisabled: isDisabled,
                isFocused: isFocused
              }),
              this.renderLiveRegion(),
              __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                Control,
                _extends({}, commonProps, {
                  innerRef: this.getControlRef,
                  innerProps: {
                    onMouseDown: this.onControlMouseDown,
                    onTouchEnd: this.onControlTouchEnd
                  },
                  isDisabled: isDisabled,
                  isFocused: isFocused
                }),
                __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  ValueContainer,
                  _extends({}, commonProps, { isDisabled: isDisabled }),
                  this.renderPlaceholderOrValue(),
                  this.renderInput()
                ),
                __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  IndicatorsContainer,
                  _extends({}, commonProps, { isDisabled: isDisabled }),
                  this.renderClearIndicator(),
                  this.renderLoadingIndicator(),
                  this.renderIndicatorSeparator(),
                  this.renderDropdownIndicator()
                )
              ),
              this.renderMenu(),
              this.renderFormField()
            );
          }
        }
      ]);
      return Select;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    Select.defaultProps = defaultProps;
    var _initialiseProps = function _initialiseProps() {
      var _this7 = this;
      this.state = {
        ariaLiveSelection: "",
        ariaLiveContext: "",
        focusedOption: null,
        focusedValue: null,
        inputIsHidden: false,
        isFocused: false,
        isComposing: false,
        menuOptions: { render: [], focusable: [] },
        selectValue: []
      };
      this.blockOptionHover = false;
      this.clearFocusValueOnUpdate = false;
      this.hasGroups = false;
      this.initialTouchX = 0;
      this.initialTouchY = 0;
      this.instancePrefix = "";
      this.openAfterFocus = false;
      this.scrollToFocusedOptionOnUpdate = false;
      this.controlRef = null;
      this.getControlRef = function(ref) {
        _this7.controlRef = ref;
      };
      this.focusedOptionRef = null;
      this.getFocusedOptionRef = function(ref) {
        _this7.focusedOptionRef = ref;
      };
      this.menuListRef = null;
      this.getMenuListRef = function(ref) {
        _this7.menuListRef = ref;
      };
      this.inputRef = null;
      this.getInputRef = function(ref) {
        _this7.inputRef = ref;
      };
      this.cacheComponents = function(components$$1) {
        _this7.components = defaultComponents({ components: components$$1 });
      };
      this.focus = this.focusInput;
      this.blur = this.blurInput;
      this.setValue = function(newValue) {
        var action =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : "set-value";
        var option = arguments[2];
        var _props14 = _this7.props,
          closeMenuOnSelect = _props14.closeMenuOnSelect,
          isMulti = _props14.isMulti,
          onChange = _props14.onChange;
        _this7.onInputChange("", { action: "set-value" });
        if (closeMenuOnSelect) {
          _this7.inputIsHiddenAfterUpdate = !isMulti;
          _this7.onMenuClose();
        }
        _this7.clearFocusValueOnUpdate = true;
        onChange(newValue, { action: action, option: option });
      };
      this.selectOption = function(newValue) {
        var _props15 = _this7.props,
          blurInputOnSelect = _props15.blurInputOnSelect,
          isMulti = _props15.isMulti;
        if (isMulti) {
          var _selectValue3 = _this7.state.selectValue;
          if (_this7.isOptionSelected(newValue, _selectValue3)) {
            var candidate = _this7.getOptionValue(newValue);
            _this7.setValue(
              _selectValue3.filter(function(i) {
                return _this7.getOptionValue(i) !== candidate;
              }),
              "deselect-option",
              newValue
            );
            _this7.announceAriaLiveSelection({
              event: "deselect-option",
              context: { value: _this7.getOptionLabel(newValue) }
            });
          } else {
            _this7.setValue(
              [].concat(toConsumableArray(_selectValue3), [newValue]),
              "select-option",
              newValue
            );
            _this7.announceAriaLiveSelection({
              event: "select-option",
              context: { value: _this7.getOptionLabel(newValue) }
            });
          }
        } else {
          _this7.setValue(newValue, "select-option");
          _this7.announceAriaLiveSelection({
            event: "select-option",
            context: { value: _this7.getOptionLabel(newValue) }
          });
        }
        if (blurInputOnSelect) {
          _this7.blurInput();
        }
      };
      this.removeValue = function(removedValue) {
        var onChange = _this7.props.onChange;
        var selectValue = _this7.state.selectValue;
        var candidate = _this7.getOptionValue(removedValue);
        onChange(
          selectValue.filter(function(i) {
            return _this7.getOptionValue(i) !== candidate;
          }),
          { action: "remove-value", removedValue: removedValue }
        );
        _this7.announceAriaLiveSelection({
          event: "remove-value",
          context: {
            value: removedValue
              ? _this7.getOptionLabel(removedValue)
              : undefined
          }
        });
        _this7.focusInput();
      };
      this.clearValue = function() {
        var _props16 = _this7.props,
          isMulti = _props16.isMulti,
          onChange = _props16.onChange;
        onChange(isMulti ? [] : null, { action: "clear" });
      };
      this.popValue = function() {
        var onChange = _this7.props.onChange;
        var selectValue = _this7.state.selectValue;
        var lastSelectedValue = selectValue[selectValue.length - 1];
        _this7.announceAriaLiveSelection({
          event: "pop-value",
          context: {
            value: lastSelectedValue
              ? _this7.getOptionLabel(lastSelectedValue)
              : undefined
          }
        });
        onChange(selectValue.slice(0, selectValue.length - 1), {
          action: "pop-value",
          removedValue: lastSelectedValue
        });
      };
      this.getOptionLabel = function(data) {
        return _this7.props.getOptionLabel(data);
      };
      this.getOptionValue = function(data) {
        return _this7.props.getOptionValue(data);
      };
      this.getStyles = function(key, props) {
        var base = defaultStyles[key](props);
        base.boxSizing = "border-box";
        var custom = _this7.props.styles[key];
        return custom ? custom(base, props) : base;
      };
      this.getElementId = function(element) {
        return _this7.instancePrefix + "-" + element;
      };
      this.getActiveDescendentId = function() {
        var menuIsOpen = _this7.props.menuIsOpen;
        var _state8 = _this7.state,
          menuOptions = _state8.menuOptions,
          focusedOption = _state8.focusedOption;
        if (!focusedOption || !menuIsOpen) return undefined;
        var index = menuOptions.focusable.indexOf(focusedOption);
        var option = menuOptions.render[index];
        return option && option.key;
      };
      this.announceAriaLiveSelection = function(_ref3) {
        var event = _ref3.event,
          context = _ref3.context;
        _this7.setState({
          ariaLiveSelection: valueEventAriaMessage(event, context)
        });
      };
      this.announceAriaLiveContext = function(_ref4) {
        var event = _ref4.event,
          context = _ref4.context;
        _this7.setState({
          ariaLiveContext: instructionsAriaMessage(
            event,
            _extends({}, context, { label: _this7.props["aria-label"] })
          )
        });
      };
      this.onMenuMouseDown = function(event) {
        if (event.button !== 0) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        _this7.focusInput();
      };
      this.onMenuMouseMove = function(event) {
        _this7.blockOptionHover = false;
      };
      this.onControlMouseDown = function(event) {
        var openMenuOnClick = _this7.props.openMenuOnClick;
        if (!_this7.state.isFocused) {
          if (openMenuOnClick) {
            _this7.openAfterFocus = true;
          }
          _this7.focusInput();
        } else if (!_this7.props.menuIsOpen) {
          _this7.openMenu("first");
        } else {
          if (event.target.tagName !== "INPUT") {
            _this7.onMenuClose();
          }
        }
        if (event.target.tagName !== "INPUT") {
          event.preventDefault();
        }
      };
      this.onDropdownIndicatorMouseDown = function(event) {
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        if (_this7.props.isDisabled) return;
        var _props17 = _this7.props,
          isMulti = _props17.isMulti,
          menuIsOpen = _props17.menuIsOpen;
        _this7.focusInput();
        if (menuIsOpen) {
          _this7.inputIsHiddenAfterUpdate = !isMulti;
          _this7.onMenuClose();
        } else {
          _this7.openMenu("first");
        }
        event.preventDefault();
        event.stopPropagation();
      };
      this.onClearIndicatorMouseDown = function(event) {
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        _this7.clearValue();
        event.stopPropagation();
        _this7.openAfterFocus = false;
        setTimeout(function() {
          return _this7.focusInput();
        });
      };
      this.onScroll = function(event) {
        if (typeof _this7.props.closeMenuOnScroll === "boolean") {
          if (
            event.target instanceof HTMLElement &&
            isDocumentElement(event.target)
          ) {
            _this7.props.onMenuClose();
          }
        } else if (typeof _this7.props.closeMenuOnScroll === "function") {
          if (_this7.props.closeMenuOnScroll(event)) {
            _this7.props.onMenuClose();
          }
        }
      };
      this.onCompositionStart = function() {
        _this7.setState({ isComposing: true });
      };
      this.onCompositionEnd = function() {
        _this7.setState({ isComposing: false });
      };
      this.onTouchStart = function(_ref5) {
        var _ref5$touches = slicedToArray(_ref5.touches, 1),
          touch = _ref5$touches[0];
        _this7.initialTouchX = touch.clientX;
        _this7.initialTouchY = touch.clientY;
        _this7.userIsDragging = false;
      };
      this.onTouchMove = function(_ref6) {
        var _ref6$touches = slicedToArray(_ref6.touches, 1),
          touch = _ref6$touches[0];
        var deltaX = Math.abs(touch.clientX - _this7.initialTouchX);
        var deltaY = Math.abs(touch.clientY - _this7.initialTouchY);
        var moveThreshold = 5;
        _this7.userIsDragging =
          deltaX > moveThreshold || deltaY > moveThreshold;
      };
      this.onTouchEnd = function(event) {
        if (_this7.userIsDragging) return;
        var target = event.target;
        if (
          _this7.controlRef &&
          !_this7.controlRef.contains(target) &&
          _this7.menuListRef &&
          !_this7.menuListRef.contains(target)
        ) {
          _this7.blurInput();
        }
        _this7.initialTouchX = 0;
        _this7.initialTouchY = 0;
      };
      this.onControlTouchEnd = function(event) {
        if (_this7.userIsDragging) return;
        _this7.onControlMouseDown(event);
      };
      this.onClearIndicatorTouchEnd = function(event) {
        if (_this7.userIsDragging) return;
        _this7.onClearIndicatorMouseDown(event);
      };
      this.onDropdownIndicatorTouchEnd = function(event) {
        if (_this7.userIsDragging) return;
        _this7.onDropdownIndicatorMouseDown(event);
      };
      this.handleInputChange = function(event) {
        var inputValue = event.currentTarget.value;
        _this7.inputIsHiddenAfterUpdate = false;
        _this7.onInputChange(inputValue, { action: "input-change" });
        _this7.onMenuOpen();
      };
      this.onInputFocus = function(event) {
        var _props18 = _this7.props,
          isSearchable = _props18.isSearchable,
          isMulti = _props18.isMulti;
        if (_this7.props.onFocus) {
          _this7.props.onFocus(event);
        }
        _this7.inputIsHiddenAfterUpdate = false;
        _this7.announceAriaLiveContext({
          event: "input",
          context: { isSearchable: isSearchable, isMulti: isMulti }
        });
        _this7.setState({ isFocused: true });
        if (_this7.openAfterFocus || _this7.props.openMenuOnFocus) {
          _this7.openMenu("first");
        }
        _this7.openAfterFocus = false;
      };
      this.onInputBlur = function(event) {
        if (
          _this7.menuListRef &&
          _this7.menuListRef.contains(document.activeElement)
        ) {
          _this7.inputRef.focus();
          return;
        }
        if (_this7.props.onBlur) {
          _this7.props.onBlur(event);
        }
        _this7.onInputChange("", { action: "input-blur" });
        _this7.onMenuClose();
        _this7.setState({ focusedValue: null, isFocused: false });
      };
      this.onOptionHover = function(focusedOption) {
        if (
          _this7.blockOptionHover ||
          _this7.state.focusedOption === focusedOption
        ) {
          return;
        }
        _this7.setState({ focusedOption: focusedOption });
      };
      this.shouldHideSelectedOptions = function() {
        var _props19 = _this7.props,
          hideSelectedOptions = _props19.hideSelectedOptions,
          isMulti = _props19.isMulti;
        if (hideSelectedOptions === undefined) return isMulti;
        return hideSelectedOptions;
      };
      this.onKeyDown = function(event) {
        var _props20 = _this7.props,
          isMulti = _props20.isMulti,
          backspaceRemovesValue = _props20.backspaceRemovesValue,
          escapeClearsValue = _props20.escapeClearsValue,
          inputValue = _props20.inputValue,
          isClearable = _props20.isClearable,
          isDisabled = _props20.isDisabled,
          menuIsOpen = _props20.menuIsOpen,
          onKeyDown = _props20.onKeyDown,
          tabSelectsValue = _props20.tabSelectsValue,
          openMenuOnFocus = _props20.openMenuOnFocus;
        var _state9 = _this7.state,
          isComposing = _state9.isComposing,
          focusedOption = _state9.focusedOption,
          focusedValue = _state9.focusedValue,
          selectValue = _state9.selectValue;
        if (isDisabled) return;
        if (typeof onKeyDown === "function") {
          onKeyDown(event);
          if (event.defaultPrevented) {
            return;
          }
        }
        _this7.blockOptionHover = true;
        switch (event.key) {
          case "ArrowLeft":
            if (!isMulti || inputValue) return;
            _this7.focusValue("previous");
            break;
          case "ArrowRight":
            if (!isMulti || inputValue) return;
            _this7.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (inputValue) return;
            if (focusedValue) {
              _this7.removeValue(focusedValue);
            } else {
              if (!backspaceRemovesValue) return;
              if (isMulti) {
                _this7.popValue();
              } else if (isClearable) {
                _this7.clearValue();
              }
            }
            break;
          case "Tab":
            if (
              event.shiftKey ||
              !menuIsOpen ||
              !tabSelectsValue ||
              !focusedOption ||
              (openMenuOnFocus &&
                _this7.isOptionSelected(focusedOption, selectValue))
            ) {
              return;
            }
            _this7.selectOption(focusedOption);
            break;
          case "Enter":
            if (menuIsOpen) {
              if (!focusedOption) return;
              if (isComposing) return;
              _this7.selectOption(focusedOption);
            } else {
              _this7.focusOption("first");
            }
            break;
          case "Escape":
            if (menuIsOpen) {
              _this7.inputIsHiddenAfterUpdate = false;
              _this7.onInputChange("", { action: "menu-close" });
              _this7.onMenuClose();
            } else if (isClearable && escapeClearsValue) {
              _this7.clearValue();
            }
            break;
          case " ":
            if (inputValue) {
              return;
            }
            if (!menuIsOpen) {
              _this7.openMenu("first");
              break;
            }
            if (!focusedOption) return;
            _this7.selectOption(focusedOption);
            break;
          case "ArrowUp":
            if (menuIsOpen) {
              _this7.focusOption("up");
            } else {
              _this7.openMenu("last");
            }
            break;
          case "ArrowDown":
            if (menuIsOpen) {
              _this7.focusOption("down");
            } else {
              _this7.openMenu("first");
            }
            break;
          case "PageUp":
            if (!menuIsOpen) return;
            _this7.focusOption("pageup");
            break;
          case "PageDown":
            if (!menuIsOpen) return;
            _this7.focusOption("pagedown");
            break;
          case "Home":
            if (!menuIsOpen) return;
            _this7.focusOption("first");
            break;
          case "End":
            if (!menuIsOpen) return;
            _this7.focusOption("last");
            break;
          default:
            return;
        }
        event.preventDefault();
      };
    };
    var manageState = function manageState(SelectComponent) {
      var _class, _temp2;
      return (
        (_temp2 = _class = (function(_Component) {
          inherits(StateManager, _Component);
          function StateManager() {
            var _ref;
            var _temp, _this, _ret;
            classCallCheck(this, StateManager);
            for (
              var _len = arguments.length, args = Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }
            return (
              (_ret =
                ((_temp =
                  ((_this = possibleConstructorReturn(
                    this,
                    (_ref =
                      StateManager.__proto__ ||
                      Object.getPrototypeOf(StateManager)).call.apply(
                      _ref,
                      [this].concat(args)
                    )
                  )),
                  _this)),
                (_this.state = {
                  inputValue:
                    _this.props.inputValue !== undefined
                      ? _this.props.inputValue
                      : _this.props.defaultInputValue,
                  menuIsOpen:
                    _this.props.menuIsOpen !== undefined
                      ? _this.props.menuIsOpen
                      : _this.props.defaultMenuIsOpen,
                  value:
                    _this.props.value !== undefined
                      ? _this.props.value
                      : _this.props.defaultValue
                }),
                (_this.onChange = function(value, actionMeta) {
                  _this.callProp("onChange", value, actionMeta);
                  _this.setState({ value: value });
                }),
                (_this.onInputChange = function(value, actionMeta) {
                  var newValue = _this.callProp(
                    "onInputChange",
                    value,
                    actionMeta
                  );
                  _this.setState({
                    inputValue: newValue !== undefined ? newValue : value
                  });
                }),
                (_this.onMenuOpen = function() {
                  _this.callProp("onMenuOpen");
                  _this.setState({ menuIsOpen: true });
                }),
                (_this.onMenuClose = function() {
                  _this.callProp("onMenuClose");
                  _this.setState({ menuIsOpen: false });
                }),
                _temp)),
              possibleConstructorReturn(_this, _ret)
            );
          }
          createClass(StateManager, [
            {
              key: "focus",
              value: function focus() {
                this.select.focus();
              }
            },
            {
              key: "blur",
              value: function blur() {
                this.select.blur();
              }
            },
            {
              key: "getProp",
              value: function getProp(key) {
                return this.props[key] !== undefined
                  ? this.props[key]
                  : this.state[key];
              }
            },
            {
              key: "callProp",
              value: function callProp(name) {
                if (typeof this.props[name] === "function") {
                  var _props;
                  for (
                    var _len2 = arguments.length,
                      args = Array(_len2 > 1 ? _len2 - 1 : 0),
                      _key2 = 1;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 1] = arguments[_key2];
                  }
                  return (_props = this.props)[name].apply(
                    _props,
                    toConsumableArray(args)
                  );
                }
              }
            },
            {
              key: "render",
              value: function render() {
                var _this2 = this;
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  SelectComponent,
                  _extends({}, this.props, {
                    ref: function ref(_ref2) {
                      _this2.select = _ref2;
                    },
                    inputValue: this.getProp("inputValue"),
                    menuIsOpen: this.getProp("menuIsOpen"),
                    onChange: this.onChange,
                    onInputChange: this.onInputChange,
                    onMenuClose: this.onMenuClose,
                    onMenuOpen: this.onMenuOpen,
                    value: this.getProp("value")
                  })
                );
              }
            }
          ]);
          return StateManager;
        })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"])),
        (_class.defaultProps = {
          defaultInputValue: "",
          defaultMenuIsOpen: false,
          defaultValue: null
        }),
        _temp2
      );
    };
    var defaultProps$1 = { cacheOptions: false, defaultOptions: false };
    var makeAsyncSelect = function makeAsyncSelect(SelectComponent) {
      var _class, _temp;
      return (
        (_temp = _class = (function(_Component) {
          inherits(Async, _Component);
          function Async(props) {
            classCallCheck(this, Async);
            var _this = possibleConstructorReturn(
              this,
              (Async.__proto__ || Object.getPrototypeOf(Async)).call(this)
            );
            _this.mounted = false;
            _this.optionsCache = {};
            _this.handleInputChange = function(newValue, actionMeta) {
              var _this$props = _this.props,
                cacheOptions = _this$props.cacheOptions,
                onInputChange = _this$props.onInputChange;
              var inputValue = handleInputChange(
                newValue,
                actionMeta,
                onInputChange
              );
              if (!inputValue) {
                delete _this.lastRequest;
                _this.setState({
                  inputValue: "",
                  loadedInputValue: "",
                  loadedOptions: [],
                  isLoading: false,
                  passEmptyOptions: false
                });
                return;
              }
              if (cacheOptions && _this.optionsCache[inputValue]) {
                _this.setState({
                  inputValue: inputValue,
                  loadedInputValue: inputValue,
                  loadedOptions: _this.optionsCache[inputValue],
                  isLoading: false,
                  passEmptyOptions: false
                });
              } else {
                var request = (_this.lastRequest = {});
                _this.setState(
                  {
                    inputValue: inputValue,
                    isLoading: true,
                    passEmptyOptions: !_this.state.loadedInputValue
                  },
                  function() {
                    _this.loadOptions(inputValue, function(options) {
                      if (!_this.mounted) return;
                      if (options) {
                        _this.optionsCache[inputValue] = options;
                      }
                      if (request !== _this.lastRequest) return;
                      delete _this.lastRequest;
                      _this.setState({
                        isLoading: false,
                        loadedInputValue: inputValue,
                        loadedOptions: options || [],
                        passEmptyOptions: false
                      });
                    });
                  }
                );
              }
              return inputValue;
            };
            _this.state = {
              defaultOptions: Array.isArray(props.defaultOptions)
                ? props.defaultOptions
                : undefined,
              inputValue: props.inputValue,
              isLoading: props.defaultOptions === true ? true : false,
              loadedOptions: [],
              passEmptyOptions: false
            };
            return _this;
          }
          createClass(Async, [
            {
              key: "componentDidMount",
              value: function componentDidMount() {
                var _this2 = this;
                this.mounted = true;
                var defaultOptions = this.props.defaultOptions;
                var inputValue = this.state.inputValue;
                if (defaultOptions === true) {
                  this.loadOptions(inputValue, function(options) {
                    if (!_this2.mounted) return;
                    var isLoading = !!_this2.lastRequest;
                    _this2.setState({
                      defaultOptions: options || [],
                      isLoading: isLoading
                    });
                  });
                }
              }
            },
            {
              key: "componentWillReceiveProps",
              value: function componentWillReceiveProps(nextProps) {
                if (nextProps.cacheOptions !== this.props.cacheOptions) {
                  this.optionsCache = {};
                }
                if (nextProps.defaultOptions !== this.props.defaultOptions) {
                  this.setState({
                    defaultOptions: Array.isArray(nextProps.defaultOptions)
                      ? nextProps.defaultOptions
                      : undefined
                  });
                }
              }
            },
            {
              key: "componentWillUnmount",
              value: function componentWillUnmount() {
                this.mounted = false;
              }
            },
            {
              key: "focus",
              value: function focus() {
                this.select.focus();
              }
            },
            {
              key: "blur",
              value: function blur() {
                this.select.blur();
              }
            },
            {
              key: "loadOptions",
              value: function loadOptions(inputValue, callback) {
                var loadOptions = this.props.loadOptions;
                if (!loadOptions) return callback();
                var loader = loadOptions(inputValue, callback);
                if (loader && typeof loader.then === "function") {
                  loader.then(callback, function() {
                    return callback();
                  });
                }
              }
            },
            {
              key: "render",
              value: function render() {
                var _this3 = this;
                var _props = this.props,
                  loadOptions = _props.loadOptions,
                  props = objectWithoutProperties(_props, ["loadOptions"]);
                var _state = this.state,
                  defaultOptions = _state.defaultOptions,
                  inputValue = _state.inputValue,
                  isLoading = _state.isLoading,
                  loadedInputValue = _state.loadedInputValue,
                  loadedOptions = _state.loadedOptions,
                  passEmptyOptions = _state.passEmptyOptions;
                var options = passEmptyOptions
                  ? []
                  : inputValue && loadedInputValue
                  ? loadedOptions
                  : defaultOptions || [];
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  SelectComponent,
                  _extends({}, props, {
                    filterOption: this.props.filterOption || null,
                    ref: function ref(_ref) {
                      _this3.select = _ref;
                    },
                    options: options,
                    isLoading: isLoading,
                    onInputChange: this.handleInputChange
                  })
                );
              }
            }
          ]);
          return Async;
        })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"])),
        (_class.defaultProps = defaultProps$1),
        _temp
      );
    };
    var Async = makeAsyncSelect(manageState(Select));
    var compareOption = function compareOption(inputValue, option) {
      var candidate = inputValue.toLowerCase();
      return (
        option.value.toLowerCase() === candidate ||
        option.label.toLowerCase() === candidate
      );
    };
    var builtins = {
      formatCreateLabel: function formatCreateLabel(inputValue) {
        return 'Create "' + inputValue + '"';
      },
      isValidNewOption: function isValidNewOption(
        inputValue,
        selectValue,
        selectOptions
      ) {
        return !(
          !inputValue ||
          selectValue.some(function(option) {
            return compareOption(inputValue, option);
          }) ||
          selectOptions.some(function(option) {
            return compareOption(inputValue, option);
          })
        );
      },
      getNewOptionData: function getNewOptionData(inputValue, optionLabel) {
        return { label: optionLabel, value: inputValue, __isNew__: true };
      }
    };
    var defaultProps$2 = _extends(
      { allowCreateWhileLoading: false, createOptionPosition: "last" },
      builtins
    );
    var makeCreatableSelect = function makeCreatableSelect(SelectComponent) {
      var _class, _temp;
      return (
        (_temp = _class = (function(_Component) {
          inherits(Creatable, _Component);
          function Creatable(props) {
            classCallCheck(this, Creatable);
            var _this = possibleConstructorReturn(
              this,
              (Creatable.__proto__ || Object.getPrototypeOf(Creatable)).call(
                this,
                props
              )
            );
            _this.onChange = function(newValue, actionMeta) {
              var _this$props = _this.props,
                getNewOptionData = _this$props.getNewOptionData,
                inputValue = _this$props.inputValue,
                isMulti = _this$props.isMulti,
                onChange = _this$props.onChange,
                onCreateOption = _this$props.onCreateOption,
                value = _this$props.value;
              if (actionMeta.action !== "select-option") {
                return onChange(newValue, actionMeta);
              }
              var newOption = _this.state.newOption;
              var valueArray = Array.isArray(newValue) ? newValue : [newValue];
              if (valueArray[valueArray.length - 1] === newOption) {
                if (onCreateOption) onCreateOption(inputValue);
                else {
                  var newOptionData = getNewOptionData(inputValue, inputValue);
                  var newActionMeta = { action: "create-option" };
                  if (isMulti) {
                    onChange(
                      [].concat(toConsumableArray(cleanValue(value)), [
                        newOptionData
                      ]),
                      newActionMeta
                    );
                  } else {
                    onChange(newOptionData, newActionMeta);
                  }
                }
                return;
              }
              onChange(newValue, actionMeta);
            };
            var options = props.options || [];
            _this.state = { newOption: undefined, options: options };
            return _this;
          }
          createClass(Creatable, [
            {
              key: "componentWillReceiveProps",
              value: function componentWillReceiveProps(nextProps) {
                var allowCreateWhileLoading = nextProps.allowCreateWhileLoading,
                  createOptionPosition = nextProps.createOptionPosition,
                  formatCreateLabel = nextProps.formatCreateLabel,
                  getNewOptionData = nextProps.getNewOptionData,
                  inputValue = nextProps.inputValue,
                  isLoading = nextProps.isLoading,
                  isValidNewOption = nextProps.isValidNewOption,
                  value = nextProps.value;
                var options = nextProps.options || [];
                var newOption = this.state.newOption;
                if (isValidNewOption(inputValue, cleanValue(value), options)) {
                  newOption = getNewOptionData(
                    inputValue,
                    formatCreateLabel(inputValue)
                  );
                } else {
                  newOption = undefined;
                }
                this.setState({
                  newOption: newOption,
                  options:
                    (allowCreateWhileLoading || !isLoading) && newOption
                      ? createOptionPosition === "first"
                        ? [newOption].concat(toConsumableArray(options))
                        : [].concat(toConsumableArray(options), [newOption])
                      : options
                });
              }
            },
            {
              key: "focus",
              value: function focus() {
                this.select.focus();
              }
            },
            {
              key: "blur",
              value: function blur() {
                this.select.blur();
              }
            },
            {
              key: "render",
              value: function render() {
                var _this2 = this;
                var props = objectWithoutProperties(this.props, []);
                var options = this.state.options;
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  SelectComponent,
                  _extends({}, props, {
                    ref: function ref(_ref) {
                      _this2.select = _ref;
                    },
                    options: options,
                    onChange: this.onChange
                  })
                );
              }
            }
          ]);
          return Creatable;
        })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"])),
        (_class.defaultProps = defaultProps$2),
        _temp
      );
    };
    var Creatable = manageState(makeCreatableSelect(Select));
    var AsyncCreatable = makeAsyncSelect(
      manageState(makeCreatableSelect(Select))
    );
    var Fade = function Fade(_ref) {
      var Tag = _ref.component,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 1 : _ref$duration,
        inProp = _ref.in,
        onExited = _ref.onExited,
        props = objectWithoutProperties(_ref, [
          "component",
          "duration",
          "in",
          "onExited"
        ]);
      var transition = {
        entering: { opacity: 0 },
        entered: { opacity: 1, transition: "opacity " + duration + "ms" },
        exiting: { opacity: 0 },
        exited: { opacity: 0 }
      };
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_7_react_transition_group__["Transition"],
        {
          mountOnEnter: true,
          unmountOnExit: true,
          in: inProp,
          timeout: duration
        },
        function(state) {
          var innerProps = { style: _extends({}, transition[state]) };
          return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            Tag,
            _extends({ innerProps: innerProps }, props)
          );
        }
      );
    };
    var collapseDuration = 260;
    var Collapse = (function(_Component) {
      inherits(Collapse, _Component);
      function Collapse() {
        var _ref2;
        var _temp, _this, _ret;
        classCallCheck(this, Collapse);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = possibleConstructorReturn(
                this,
                (_ref2 =
                  Collapse.__proto__ ||
                  Object.getPrototypeOf(Collapse)).call.apply(
                  _ref2,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.duration = collapseDuration),
            (_this.state = { width: "auto" }),
            (_this.transition = {
              exiting: {
                width: 0,
                transition: "width " + _this.duration + "ms ease-out"
              },
              exited: { width: 0 }
            }),
            (_this.getWidth = function(ref) {
              if (ref && isNaN(_this.state.width)) {
                var _ref$getBoundingClien = ref.getBoundingClientRect(),
                  _width = _ref$getBoundingClien.width;
                _this.setState({ width: _width });
              }
            }),
            (_this.getStyle = function(width) {
              return { overflow: "hidden", whiteSpace: "nowrap", width: width };
            }),
            (_this.getTransition = function(state) {
              return _this.transition[state];
            }),
            _temp)),
          possibleConstructorReturn(_this, _ret)
        );
      }
      createClass(Collapse, [
        {
          key: "render",
          value: function render() {
            var _this2 = this;
            var _props = this.props,
              children = _props.children,
              inProp = _props.in;
            var width = this.state.width;
            return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              __WEBPACK_IMPORTED_MODULE_7_react_transition_group__[
                "Transition"
              ],
              {
                enter: false,
                mountOnEnter: true,
                unmountOnExit: true,
                in: inProp,
                timeout: this.duration
              },
              function(state) {
                var style = _extends(
                  {},
                  _this2.getStyle(width),
                  _this2.getTransition(state)
                );
                return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
                  "div",
                  { ref: _this2.getWidth, style: style },
                  children
                );
              }
            );
          }
        }
      ]);
      return Collapse;
    })(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);
    var AnimatedInput = function AnimatedInput(WrappedComponent) {
      return function(_ref) {
        var inProp = _ref.in,
          onExited = _ref.onExited,
          appear = _ref.appear,
          enter = _ref.enter,
          exit = _ref.exit,
          innerRef = _ref.innerRef,
          props = objectWithoutProperties(_ref, [
            "in",
            "onExited",
            "appear",
            "enter",
            "exit",
            "innerRef"
          ]);
        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          WrappedComponent,
          _extends({ innerRef: innerRef }, props)
        );
      };
    };
    var AnimatedMultiValue = function AnimatedMultiValue(WrappedComponent) {
      return function(_ref) {
        var inProp = _ref.in,
          onExited = _ref.onExited,
          props = objectWithoutProperties(_ref, ["in", "onExited"]);
        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          Collapse,
          { in: inProp, onExited: onExited },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            WrappedComponent,
            _extends({ cropWithEllipsis: inProp }, props)
          )
        );
      };
    };
    var AnimatedPlaceholder = function AnimatedPlaceholder(WrappedComponent) {
      return function(props) {
        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          Fade,
          _extends(
            {
              component: WrappedComponent,
              duration: props.isMulti ? collapseDuration : 1
            },
            props
          )
        );
      };
    };
    var AnimatedSingleValue = function AnimatedSingleValue(WrappedComponent) {
      return function(props) {
        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          Fade,
          _extends({ component: WrappedComponent }, props)
        );
      };
    };
    var AnimatedValueContainer = function AnimatedValueContainer(
      WrappedComponent
    ) {
      return function(props) {
        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          __WEBPACK_IMPORTED_MODULE_7_react_transition_group__[
            "TransitionGroup"
          ],
          _extends({ component: WrappedComponent }, props)
        );
      };
    };
    var makeAnimated = function makeAnimated(externalComponents) {
      var components$$1 = defaultComponents({ components: externalComponents });
      var Input = components$$1.Input,
        MultiValue = components$$1.MultiValue,
        Placeholder = components$$1.Placeholder,
        SingleValue = components$$1.SingleValue,
        ValueContainer = components$$1.ValueContainer,
        rest = objectWithoutProperties(components$$1, [
          "Input",
          "MultiValue",
          "Placeholder",
          "SingleValue",
          "ValueContainer"
        ]);
      return _extends(
        {
          Input: AnimatedInput(Input),
          MultiValue: AnimatedMultiValue(MultiValue),
          Placeholder: AnimatedPlaceholder(Placeholder),
          SingleValue: AnimatedSingleValue(SingleValue),
          ValueContainer: AnimatedValueContainer(ValueContainer)
        },
        rest
      );
    };
    var AnimatedComponents = makeAnimated();
    var Input$1 = AnimatedComponents.Input;
    var MultiValue$1 = AnimatedComponents.MultiValue;
    var Placeholder$1 = AnimatedComponents.Placeholder;
    var SingleValue$1 = AnimatedComponents.SingleValue;
    var ValueContainer$1 = AnimatedComponents.ValueContainer;
    var index = __webpack_require__.i(
      __WEBPACK_IMPORTED_MODULE_6_memoize_one__["a"]
    )(makeAnimated, exportedEqual);
    var index$1 = manageState(Select);
    __webpack_exports__["default"] = index$1;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function is(x, y) {
      if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB)) {
        return true;
      }
      if (
        typeof objA !== "object" ||
        objA === null ||
        typeof objB !== "object" ||
        objB === null
      ) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (var i = 0; i < keysA.length; i++) {
        if (
          !hasOwnProperty.call(objB, keysA[i]) ||
          !is(objA[keysA[i]], objB[keysA[i]])
        ) {
          return false;
        }
      }
      return true;
    }
    module.exports = shallowEqual;
  },
  function(module, exports) {
    var process = (module.exports = {});
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if (
        (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
        setTimeout
      ) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if (
        (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&
        clearTimeout
      ) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMLazyTree = __webpack_require__(18);
    var Danger = __webpack_require__(175);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactInstrumentation = __webpack_require__(9);
    var createMicrosoftUnsafeLocalFunction = __webpack_require__(49);
    var setInnerHTML = __webpack_require__(36);
    var setTextContent = __webpack_require__(94);
    function getNodeAfter(parentNode, node) {
      if (Array.isArray(node)) {
        node = node[1];
      }
      return node ? node.nextSibling : parentNode.firstChild;
    }
    var insertChildAt = createMicrosoftUnsafeLocalFunction(function(
      parentNode,
      childNode,
      referenceNode
    ) {
      parentNode.insertBefore(childNode, referenceNode);
    });
    function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
      DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
    }
    function moveChild(parentNode, childNode, referenceNode) {
      if (Array.isArray(childNode)) {
        moveDelimitedText(
          parentNode,
          childNode[0],
          childNode[1],
          referenceNode
        );
      } else {
        insertChildAt(parentNode, childNode, referenceNode);
      }
    }
    function removeChild(parentNode, childNode) {
      if (Array.isArray(childNode)) {
        var closingComment = childNode[1];
        childNode = childNode[0];
        removeDelimitedText(parentNode, childNode, closingComment);
        parentNode.removeChild(closingComment);
      }
      parentNode.removeChild(childNode);
    }
    function moveDelimitedText(
      parentNode,
      openingComment,
      closingComment,
      referenceNode
    ) {
      var node = openingComment;
      while (true) {
        var nextNode = node.nextSibling;
        insertChildAt(parentNode, node, referenceNode);
        if (node === closingComment) {
          break;
        }
        node = nextNode;
      }
    }
    function removeDelimitedText(parentNode, startNode, closingComment) {
      while (true) {
        var node = startNode.nextSibling;
        if (node === closingComment) {
          break;
        } else {
          parentNode.removeChild(node);
        }
      }
    }
    function replaceDelimitedText(openingComment, closingComment, stringText) {
      var parentNode = openingComment.parentNode;
      var nodeAfterComment = openingComment.nextSibling;
      if (nodeAfterComment === closingComment) {
        if (stringText) {
          insertChildAt(
            parentNode,
            document.createTextNode(stringText),
            nodeAfterComment
          );
        }
      } else {
        if (stringText) {
          setTextContent(nodeAfterComment, stringText);
          removeDelimitedText(parentNode, nodeAfterComment, closingComment);
        } else {
          removeDelimitedText(parentNode, openingComment, closingComment);
        }
      }
      if (false) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)
            ._debugID,
          type: "replace text",
          payload: stringText
        });
      }
    }
    var dangerouslyReplaceNodeWithMarkup =
      Danger.dangerouslyReplaceNodeWithMarkup;
    if (false) {
      dangerouslyReplaceNodeWithMarkup = function(
        oldChild,
        markup,
        prevInstance
      ) {
        Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
        if (prevInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: prevInstance._debugID,
            type: "replace with",
            payload: markup.toString()
          });
        } else {
          var nextInstance = ReactDOMComponentTree.getInstanceFromNode(
            markup.node
          );
          if (nextInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: nextInstance._debugID,
              type: "mount",
              payload: markup.toString()
            });
          }
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
      replaceDelimitedText: replaceDelimitedText,
      processUpdates: function(parentNode, updates) {
        if (false) {
          var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(
            parentNode
          )._debugID;
        }
        for (var k = 0; k < updates.length; k++) {
          var update = updates[k];
          switch (update.type) {
            case "INSERT_MARKUP":
              insertLazyTreeChildAt(
                parentNode,
                update.content,
                getNodeAfter(parentNode, update.afterNode)
              );
              if (false) {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: "insert child",
                  payload: {
                    toIndex: update.toIndex,
                    content: update.content.toString()
                  }
                });
              }
              break;
            case "MOVE_EXISTING":
              moveChild(
                parentNode,
                update.fromNode,
                getNodeAfter(parentNode, update.afterNode)
              );
              if (false) {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: "move child",
                  payload: {
                    fromIndex: update.fromIndex,
                    toIndex: update.toIndex
                  }
                });
              }
              break;
            case "SET_MARKUP":
              setInnerHTML(parentNode, update.content);
              if (false) {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: "replace children",
                  payload: update.content.toString()
                });
              }
              break;
            case "TEXT_CONTENT":
              setTextContent(parentNode, update.content);
              if (false) {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: "replace text",
                  payload: update.content.toString()
                });
              }
              break;
            case "REMOVE_NODE":
              removeChild(parentNode, update.fromNode);
              if (false) {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: "remove child",
                  payload: { fromIndex: update.fromIndex }
                });
              }
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMNamespaces = {
      html: "http://www.w3.org/1999/xhtml",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg"
    };
    module.exports = DOMNamespaces;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    var eventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!eventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName];
        var pluginIndex = eventPluginOrder.indexOf(pluginName);
        !(pluginIndex > -1)
          ? false
            ? invariant(
                false,
                "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.",
                pluginName
              )
            : _prodInvariant("96", pluginName)
          : void 0;
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        !pluginModule.extractEvents
          ? false
            ? invariant(
                false,
                "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.",
                pluginName
              )
            : _prodInvariant("97", pluginName)
          : void 0;
        EventPluginRegistry.plugins[pluginIndex] = pluginModule;
        var publishedEvents = pluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          !publishEventForPlugin(
            publishedEvents[eventName],
            pluginModule,
            eventName
          )
            ? false
              ? invariant(
                  false,
                  "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.",
                  eventName,
                  pluginName
                )
              : _prodInvariant("98", eventName, pluginName)
            : void 0;
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)
        ? false
          ? invariant(
              false,
              "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.",
              eventName
            )
          : _prodInvariant("99", eventName)
        : void 0;
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(
              phasedRegistrationName,
              pluginModule,
              eventName
            );
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(
          dispatchConfig.registrationName,
          pluginModule,
          eventName
        );
        return true;
      }
      return false;
    }
    function publishRegistrationName(
      registrationName,
      pluginModule,
      eventName
    ) {
      !!EventPluginRegistry.registrationNameModules[registrationName]
        ? false
          ? invariant(
              false,
              "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.",
              registrationName
            )
          : _prodInvariant("100", registrationName)
        : void 0;
      EventPluginRegistry.registrationNameModules[
        registrationName
      ] = pluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] =
        pluginModule.eventTypes[eventName].dependencies;
      if (false) {
        var lowerCasedName = registrationName.toLowerCase();
        EventPluginRegistry.possibleRegistrationNames[
          lowerCasedName
        ] = registrationName;
        if (registrationName === "onDoubleClick") {
          EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
        }
      }
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      possibleRegistrationNames: false ? {} : null,
      injectEventPluginOrder: function(injectedEventPluginOrder) {
        !!eventPluginOrder
          ? false
            ? invariant(
                false,
                "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."
              )
            : _prodInvariant("101")
          : void 0;
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var pluginModule = injectedNamesToPlugins[pluginName];
          if (
            !namesToPlugins.hasOwnProperty(pluginName) ||
            namesToPlugins[pluginName] !== pluginModule
          ) {
            !!namesToPlugins[pluginName]
              ? false
                ? invariant(
                    false,
                    "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.",
                    pluginName
                  )
                : _prodInvariant("102", pluginName)
              : void 0;
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return (
            EventPluginRegistry.registrationNameModules[
              dispatchConfig.registrationName
            ] || null
          );
        }
        if (dispatchConfig.phasedRegistrationNames !== undefined) {
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
          for (var phase in phasedRegistrationNames) {
            if (!phasedRegistrationNames.hasOwnProperty(phase)) {
              continue;
            }
            var pluginModule =
              EventPluginRegistry.registrationNameModules[
                phasedRegistrationNames[phase]
              ];
            if (pluginModule) {
              return pluginModule;
            }
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        eventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs =
          EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules =
          EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
        if (false) {
          var possibleRegistrationNames =
            EventPluginRegistry.possibleRegistrationNames;
          for (var lowerCasedName in possibleRegistrationNames) {
            if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
              delete possibleRegistrationNames[lowerCasedName];
            }
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactErrorUtils = __webpack_require__(47);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    var ComponentTree;
    var TreeTraversal;
    var injection = {
      injectComponentTree: function(Injected) {
        ComponentTree = Injected;
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                Injected &&
                  Injected.getNodeFromInstance &&
                  Injected.getInstanceFromNode,
                "EventPluginUtils.injection.injectComponentTree(...): Injected " +
                  "module is missing getNodeFromInstance or getInstanceFromNode."
              )
            : void 0;
        }
      },
      injectTreeTraversal: function(Injected) {
        TreeTraversal = Injected;
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                Injected &&
                  Injected.isAncestor &&
                  Injected.getLowestCommonAncestor,
                "EventPluginUtils.injection.injectTreeTraversal(...): Injected " +
                  "module is missing isAncestor or getLowestCommonAncestor."
              )
            : void 0;
        }
      }
    };
    function isEndish(topLevelType) {
      return (
        topLevelType === "topMouseUp" ||
        topLevelType === "topTouchEnd" ||
        topLevelType === "topTouchCancel"
      );
    }
    function isMoveish(topLevelType) {
      return topLevelType === "topMouseMove" || topLevelType === "topTouchMove";
    }
    function isStartish(topLevelType) {
      return (
        topLevelType === "topMouseDown" || topLevelType === "topTouchStart"
      );
    }
    var validateEventDispatches;
    if (false) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var listenersLen = listenersIsArr
          ? dispatchListeners.length
          : dispatchListeners
          ? 1
          : 0;
        var instancesIsArr = Array.isArray(dispatchInstances);
        var instancesLen = instancesIsArr
          ? dispatchInstances.length
          : dispatchInstances
          ? 1
          : 0;
        process.env.NODE_ENV !== "production"
          ? warning(
              instancesIsArr === listenersIsArr &&
                instancesLen === listenersLen,
              "EventPluginUtils: Invalid `event`."
            )
          : void 0;
      };
    }
    function executeDispatch(event, simulated, listener, inst) {
      var type = event.type || "unknown-event";
      event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
      if (simulated) {
        ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
      } else {
        ReactErrorUtils.invokeGuardedCallback(type, listener, event);
      }
      event.currentTarget = null;
    }
    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if (false) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          executeDispatch(
            event,
            simulated,
            dispatchListeners[i],
            dispatchInstances[i]
          );
        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if (false) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchInstances[i])) {
            return dispatchInstances[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchInstances)) {
          return dispatchInstances;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchInstances = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if (false) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchInstance = event._dispatchInstances;
      !!Array.isArray(dispatchListener)
        ? false
          ? invariant(false, "executeDirectDispatch(...): Invalid `event`.")
          : _prodInvariant("103")
        : void 0;
      event.currentTarget = dispatchListener
        ? EventPluginUtils.getNodeFromInstance(dispatchInstance)
        : null;
      var res = dispatchListener ? dispatchListener(event) : null;
      event.currentTarget = null;
      event._dispatchListeners = null;
      event._dispatchInstances = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      getInstanceFromNode: function(node) {
        return ComponentTree.getInstanceFromNode(node);
      },
      getNodeFromInstance: function(node) {
        return ComponentTree.getNodeFromInstance(node);
      },
      isAncestor: function(a, b) {
        return TreeTraversal.isAncestor(a, b);
      },
      getLowestCommonAncestor: function(a, b) {
        return TreeTraversal.getLowestCommonAncestor(a, b);
      },
      getParentInstance: function(inst) {
        return TreeTraversal.getParentInstance(inst);
      },
      traverseTwoPhase: function(target, fn, arg) {
        return TreeTraversal.traverseTwoPhase(target, fn, arg);
      },
      traverseEnterLeave: function(from, to, fn, argFrom, argTo) {
        return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
      },
      injection: injection
    };
    module.exports = EventPluginUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = { "=": "=0", ":": "=2" };
      var escapedString = ("" + key).replace(escapeRegex, function(match) {
        return escaperLookup[match];
      });
      return "$" + escapedString;
    }
    function unescape(key) {
      var unescapeRegex = /(=0|=2)/g;
      var unescaperLookup = { "=0": "=", "=2": ":" };
      var keySubstring =
        key[0] === "." && key[1] === "$" ? key.substring(2) : key.substring(1);
      return ("" + keySubstring).replace(unescapeRegex, function(match) {
        return unescaperLookup[match];
      });
    }
    var KeyEscapeUtils = { escape: escape, unescape: unescape };
    module.exports = KeyEscapeUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactPropTypesSecret = __webpack_require__(204);
    var propTypesFactory = __webpack_require__(73);
    var React = __webpack_require__(21);
    var PropTypes = propTypesFactory(React.isValidElement);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    var hasReadOnlyValue = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    };
    function _assertSingleLink(inputProps) {
      !(inputProps.checkedLink == null || inputProps.valueLink == null)
        ? false
          ? invariant(
              false,
              "Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don't want to use valueLink and vice versa."
            )
          : _prodInvariant("87")
        : void 0;
    }
    function _assertValueLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.value == null && inputProps.onChange == null)
        ? false
          ? invariant(
              false,
              "Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don't want to use valueLink."
            )
          : _prodInvariant("88")
        : void 0;
    }
    function _assertCheckedLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.checked == null && inputProps.onChange == null)
        ? false
          ? invariant(
              false,
              "Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don't want to use checkedLink"
            )
          : _prodInvariant("89")
        : void 0;
    }
    var propTypes = {
      value: function(props, propName, componentName) {
        if (
          !props[propName] ||
          hasReadOnlyValue[props.type] ||
          props.onChange ||
          props.readOnly ||
          props.disabled
        ) {
          return null;
        }
        return new Error(
          "You provided a `value` prop to a form field without an " +
            "`onChange` handler. This will render a read-only field. If " +
            "the field should be mutable use `defaultValue`. Otherwise, " +
            "set either `onChange` or `readOnly`."
        );
      },
      checked: function(props, propName, componentName) {
        if (
          !props[propName] ||
          props.onChange ||
          props.readOnly ||
          props.disabled
        ) {
          return null;
        }
        return new Error(
          "You provided a `checked` prop to a form field without an " +
            "`onChange` handler. This will render a read-only field. If " +
            "the field should be mutable use `defaultChecked`. Otherwise, " +
            "set either `onChange` or `readOnly`."
        );
      },
      onChange: PropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return " Check the render method of `" + name + "`.";
        }
      }
      return "";
    }
    var LinkedValueUtils = {
      checkPropTypes: function(tagName, props, owner) {
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](
              props,
              propName,
              tagName,
              "prop",
              null,
              ReactPropTypesSecret
            );
          }
          if (
            error instanceof Error &&
            !(error.message in loggedTypeFailures)
          ) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(owner);
            false
              ? warning(
                  false,
                  "Failed form propType: %s%s",
                  error.message,
                  addendum
                )
              : void 0;
          }
        }
      },
      getValue: function(inputProps) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.value;
        }
        return inputProps.value;
      },
      getChecked: function(inputProps) {
        if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.value;
        }
        return inputProps.checked;
      },
      executeOnChange: function(inputProps, event) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.requestChange(event.target.value);
        } else if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.requestChange(event.target.checked);
        } else if (inputProps.onChange) {
          return inputProps.onChange.call(undefined, event);
        }
      }
    };
    module.exports = LinkedValueUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    var injected = false;
    var ReactComponentEnvironment = {
      replaceNodeWithMarkup: null,
      processChildrenUpdates: null,
      injection: {
        injectEnvironment: function(environment) {
          !!injected
            ? false
              ? invariant(
                  false,
                  "ReactCompositeComponent: injectEnvironment() can only be called once."
                )
              : _prodInvariant("104")
            : void 0;
          ReactComponentEnvironment.replaceNodeWithMarkup =
            environment.replaceNodeWithMarkup;
          ReactComponentEnvironment.processChildrenUpdates =
            environment.processChildrenUpdates;
          injected = true;
        }
      }
    };
    module.exports = ReactComponentEnvironment;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var caughtError = null;
    function invokeGuardedCallback(name, func, a) {
      try {
        func(a);
      } catch (x) {
        if (caughtError === null) {
          caughtError = x;
        }
      }
    }
    var ReactErrorUtils = {
      invokeGuardedCallback: invokeGuardedCallback,
      invokeGuardedCallbackWithCatch: invokeGuardedCallback,
      rethrowCaughtError: function() {
        if (caughtError) {
          var error = caughtError;
          caughtError = null;
          throw error;
        }
      }
    };
    if (false) {
      if (
        typeof window !== "undefined" &&
        typeof window.dispatchEvent === "function" &&
        typeof document !== "undefined" &&
        typeof document.createEvent === "function"
      ) {
        var fakeNode = document.createElement("react");
        ReactErrorUtils.invokeGuardedCallback = function(name, func, a) {
          var boundFunc = function() {
            func(a);
          };
          var evtType = "react-" + name;
          fakeNode.addEventListener(evtType, boundFunc, false);
          var evt = document.createEvent("Event");
          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);
          fakeNode.removeEventListener(evtType, boundFunc, false);
        };
      }
    }
    module.exports = ReactErrorUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactCurrentOwner = __webpack_require__(13);
    var ReactInstanceMap = __webpack_require__(27);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactUpdates = __webpack_require__(11);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    function enqueueUpdate(internalInstance) {
      ReactUpdates.enqueueUpdate(internalInstance);
    }
    function formatUnexpectedArgument(arg) {
      var type = typeof arg;
      if (type !== "object") {
        return type;
      }
      var displayName = (arg.constructor && arg.constructor.name) || type;
      var keys = Object.keys(arg);
      if (keys.length > 0 && keys.length < 20) {
        return displayName + " (keys: " + keys.join(", ") + ")";
      }
      return displayName;
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if (false) {
          var ctor = publicInstance.constructor;
          process.env.NODE_ENV !== "production"
            ? warning(
                !callerName,
                "%s(...): Can only update a mounted or mounting component. " +
                  "This usually means you called %s() on an unmounted component. " +
                  "This is a no-op. Please check the code for the %s component.",
                callerName,
                callerName,
                (ctor && (ctor.displayName || ctor.name)) || "ReactClass"
              )
            : void 0;
        }
        return null;
      }
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(
              ReactCurrentOwner.current == null,
              "%s(...): Cannot update during an existing state transition (such as " +
                "within `render` or another component's constructor). Render methods " +
                "should be a pure function of props and state; constructor " +
                "side-effects are an anti-pattern, but can be moved to " +
                "`componentWillMount`.",
              callerName
            )
          : void 0;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      isMounted: function(publicInstance) {
        if (false) {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  owner._warnedAboutRefsInRender,
                  "%s is accessing isMounted inside its render() function. " +
                    "render() should be a pure function of props and state. It should " +
                    "never access something that requires stale data from the previous " +
                    "render, such as refs. Move this logic to componentDidMount and " +
                    "componentDidUpdate instead.",
                  owner.getName() || "A component"
                )
              : void 0;
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (internalInstance) {
          return !!internalInstance._renderedComponent;
        } else {
          return false;
        }
      },
      enqueueCallback: function(publicInstance, callback, callerName) {
        ReactUpdateQueue.validateCallback(callback, callerName);
        var internalInstance = getInternalInstanceReadyForUpdate(
          publicInstance
        );
        if (!internalInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function(internalInstance, callback) {
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function(publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(
          publicInstance,
          "forceUpdate"
        );
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function(publicInstance, completeState, callback) {
        var internalInstance = getInternalInstanceReadyForUpdate(
          publicInstance,
          "replaceState"
        );
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        if (callback !== undefined && callback !== null) {
          ReactUpdateQueue.validateCallback(callback, "replaceState");
          if (internalInstance._pendingCallbacks) {
            internalInstance._pendingCallbacks.push(callback);
          } else {
            internalInstance._pendingCallbacks = [callback];
          }
        }
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function(publicInstance, partialState) {
        if (false) {
          ReactInstrumentation.debugTool.onSetState();
          process.env.NODE_ENV !== "production"
            ? warning(
                partialState != null,
                "setState(...): You passed an undefined or null state object; " +
                  "instead, use forceUpdate()."
              )
            : void 0;
        }
        var internalInstance = getInternalInstanceReadyForUpdate(
          publicInstance,
          "setState"
        );
        if (!internalInstance) {
          return;
        }
        var queue =
          internalInstance._pendingStateQueue ||
          (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueElementInternal: function(
        internalInstance,
        nextElement,
        nextContext
      ) {
        internalInstance._pendingElement = nextElement;
        internalInstance._context = nextContext;
        enqueueUpdate(internalInstance);
      },
      validateCallback: function(callback, callerName) {
        !(!callback || typeof callback === "function")
          ? false
            ? invariant(
                false,
                "%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",
                callerName,
                formatUnexpectedArgument(callback)
              )
            : _prodInvariant(
                "122",
                callerName,
                formatUnexpectedArgument(callback)
              )
          : void 0;
      }
    };
    module.exports = ReactUpdateQueue;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var createMicrosoftUnsafeLocalFunction = function(func) {
      if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
        return function(arg0, arg1, arg2, arg3) {
          MSApp.execUnsafeLocalFunction(function() {
            return func(arg0, arg1, arg2, arg3);
          });
        };
      } else {
        return func;
      }
    };
    module.exports = createMicrosoftUnsafeLocalFunction;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function getEventCharCode(nativeEvent) {
      var charCode;
      var keyCode = nativeEvent.keyCode;
      if ("charCode" in nativeEvent) {
        charCode = nativeEvent.charCode;
        if (charCode === 0 && keyCode === 13) {
          charCode = 13;
        }
      } else {
        charCode = keyCode;
      }
      if (charCode >= 32 || charCode === 13) {
        return charCode;
      }
      return 0;
    }
    module.exports = getEventCharCode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var syntheticEvent = this;
      var nativeEvent = syntheticEvent.nativeEvent;
      if (nativeEvent.getModifierState) {
        return nativeEvent.getModifierState(keyArg);
      }
      var keyProp = modifierKeyToProp[keyArg];
      return keyProp ? !!nativeEvent[keyProp] : false;
    }
    function getEventModifierState(nativeEvent) {
      return modifierStateGetter;
    }
    module.exports = getEventModifierState;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function getEventTarget(nativeEvent) {
      var target = nativeEvent.target || nativeEvent.srcElement || window;
      if (target.correspondingUseElement) {
        target = target.correspondingUseElement;
      }
      return target.nodeType === 3 ? target.parentNode : target;
    }
    module.exports = getEventTarget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var useHasFeature;
    if (ExecutionEnvironment.canUseDOM) {
      useHasFeature =
        document.implementation &&
        document.implementation.hasFeature &&
        document.implementation.hasFeature("", "") !== true;
    }
    function isEventSupported(eventNameSuffix, capture) {
      if (
        !ExecutionEnvironment.canUseDOM ||
        (capture && !("addEventListener" in document))
      ) {
        return false;
      }
      var eventName = "on" + eventNameSuffix;
      var isSupported = eventName in document;
      if (!isSupported) {
        var element = document.createElement("div");
        element.setAttribute(eventName, "return;");
        isSupported = typeof element[eventName] === "function";
      }
      if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
        isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
      }
      return isSupported;
    }
    module.exports = isEventSupported;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function shouldUpdateReactComponent(prevElement, nextElement) {
      var prevEmpty = prevElement === null || prevElement === false;
      var nextEmpty = nextElement === null || nextElement === false;
      if (prevEmpty || nextEmpty) {
        return prevEmpty === nextEmpty;
      }
      var prevType = typeof prevElement;
      var nextType = typeof nextElement;
      if (prevType === "string" || prevType === "number") {
        return nextType === "string" || nextType === "number";
      } else {
        return (
          nextType === "object" &&
          prevElement.type === nextElement.type &&
          prevElement.key === nextElement.key
        );
      }
    }
    module.exports = shouldUpdateReactComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var emptyFunction = __webpack_require__(10);
    var warning = __webpack_require__(4);
    var validateDOMNesting = emptyFunction;
    if (false) {
      var specialTags = [
        "address",
        "applet",
        "area",
        "article",
        "aside",
        "base",
        "basefont",
        "bgsound",
        "blockquote",
        "body",
        "br",
        "button",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "details",
        "dir",
        "div",
        "dl",
        "dt",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "iframe",
        "img",
        "input",
        "isindex",
        "li",
        "link",
        "listing",
        "main",
        "marquee",
        "menu",
        "menuitem",
        "meta",
        "nav",
        "noembed",
        "noframes",
        "noscript",
        "object",
        "ol",
        "p",
        "param",
        "plaintext",
        "pre",
        "script",
        "section",
        "select",
        "source",
        "style",
        "summary",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "track",
        "ul",
        "wbr",
        "xmp"
      ];
      var inScopeTags = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        "foreignObject",
        "desc",
        "title"
      ];
      var buttonScopeTags = inScopeTags.concat(["button"]);
      var impliedEndTags = [
        "dd",
        "dt",
        "li",
        "option",
        "optgroup",
        "p",
        "rp",
        "rt"
      ];
      var emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      var updatedAncestorInfo = function(oldInfo, tag, instance) {
        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
        var info = { tag: tag, instance: instance };
        if (inScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.aTagInScope = null;
          ancestorInfo.buttonTagInScope = null;
          ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.pTagInButtonScope = null;
        }
        if (
          specialTags.indexOf(tag) !== -1 &&
          tag !== "address" &&
          tag !== "div" &&
          tag !== "p"
        ) {
          ancestorInfo.listItemTagAutoclosing = null;
          ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.current = info;
        if (tag === "form") {
          ancestorInfo.formTag = info;
        }
        if (tag === "a") {
          ancestorInfo.aTagInScope = info;
        }
        if (tag === "button") {
          ancestorInfo.buttonTagInScope = info;
        }
        if (tag === "nobr") {
          ancestorInfo.nobrTagInScope = info;
        }
        if (tag === "p") {
          ancestorInfo.pTagInButtonScope = info;
        }
        if (tag === "li") {
          ancestorInfo.listItemTagAutoclosing = info;
        }
        if (tag === "dd" || tag === "dt") {
          ancestorInfo.dlItemTagAutoclosing = info;
        }
        return ancestorInfo;
      };
      var isTagValidWithParent = function(tag, parentTag) {
        switch (parentTag) {
          case "select":
            return tag === "option" || tag === "optgroup" || tag === "#text";
          case "optgroup":
            return tag === "option" || tag === "#text";
          case "option":
            return tag === "#text";
          case "tr":
            return (
              tag === "th" ||
              tag === "td" ||
              tag === "style" ||
              tag === "script" ||
              tag === "template"
            );
          case "tbody":
          case "thead":
          case "tfoot":
            return (
              tag === "tr" ||
              tag === "style" ||
              tag === "script" ||
              tag === "template"
            );
          case "colgroup":
            return tag === "col" || tag === "template";
          case "table":
            return (
              tag === "caption" ||
              tag === "colgroup" ||
              tag === "tbody" ||
              tag === "tfoot" ||
              tag === "thead" ||
              tag === "style" ||
              tag === "script" ||
              tag === "template"
            );
          case "head":
            return (
              tag === "base" ||
              tag === "basefont" ||
              tag === "bgsound" ||
              tag === "link" ||
              tag === "meta" ||
              tag === "title" ||
              tag === "noscript" ||
              tag === "noframes" ||
              tag === "style" ||
              tag === "script" ||
              tag === "template"
            );
          case "html":
            return tag === "head" || tag === "body";
          case "#document":
            return tag === "html";
        }
        switch (tag) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return (
              parentTag !== "h1" &&
              parentTag !== "h2" &&
              parentTag !== "h3" &&
              parentTag !== "h4" &&
              parentTag !== "h5" &&
              parentTag !== "h6"
            );
          case "rp":
          case "rt":
            return impliedEndTags.indexOf(parentTag) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return parentTag == null;
        }
        return true;
      };
      var findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch (tag) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ancestorInfo.pTagInButtonScope;
          case "form":
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case "li":
            return ancestorInfo.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ancestorInfo.dlItemTagAutoclosing;
          case "button":
            return ancestorInfo.buttonTagInScope;
          case "a":
            return ancestorInfo.aTagInScope;
          case "nobr":
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      };
      var findOwnerStack = function(instance) {
        if (!instance) {
          return [];
        }
        var stack = [];
        do {
          stack.push(instance);
        } while ((instance = instance._currentElement._owner));
        stack.reverse();
        return stack;
      };
      var didWarn = {};
      validateDOMNesting = function(
        childTag,
        childText,
        childInstance,
        ancestorInfo
      ) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        if (childText != null) {
          process.env.NODE_ENV !== "production"
            ? warning(
                childTag == null,
                "validateDOMNesting: when childText is passed, childTag should be null"
              )
            : void 0;
          childTag = "#text";
        }
        var invalidParent = isTagValidWithParent(childTag, parentTag)
          ? null
          : parentInfo;
        var invalidAncestor = invalidParent
          ? null
          : findInvalidAncestorForTag(childTag, ancestorInfo);
        var problematic = invalidParent || invalidAncestor;
        if (problematic) {
          var ancestorTag = problematic.tag;
          var ancestorInstance = problematic.instance;
          var childOwner =
            childInstance && childInstance._currentElement._owner;
          var ancestorOwner =
            ancestorInstance && ancestorInstance._currentElement._owner;
          var childOwners = findOwnerStack(childOwner);
          var ancestorOwners = findOwnerStack(ancestorOwner);
          var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
          var i;
          var deepestCommon = -1;
          for (i = 0; i < minStackLen; i++) {
            if (childOwners[i] === ancestorOwners[i]) {
              deepestCommon = i;
            } else {
              break;
            }
          }
          var UNKNOWN = "(unknown)";
          var childOwnerNames = childOwners
            .slice(deepestCommon + 1)
            .map(function(inst) {
              return inst.getName() || UNKNOWN;
            });
          var ancestorOwnerNames = ancestorOwners
            .slice(deepestCommon + 1)
            .map(function(inst) {
              return inst.getName() || UNKNOWN;
            });
          var ownerInfo = []
            .concat(
              deepestCommon !== -1
                ? childOwners[deepestCommon].getName() || UNKNOWN
                : [],
              ancestorOwnerNames,
              ancestorTag,
              invalidAncestor ? ["..."] : [],
              childOwnerNames,
              childTag
            )
            .join(" > ");
          var warnKey =
            !!invalidParent +
            "|" +
            childTag +
            "|" +
            ancestorTag +
            "|" +
            ownerInfo;
          if (didWarn[warnKey]) {
            return;
          }
          didWarn[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = "";
          if (childTag === "#text") {
            if (/\S/.test(childText)) {
              tagDisplayName = "Text nodes";
            } else {
              tagDisplayName = "Whitespace text nodes";
              whitespaceInfo =
                " Make sure you don't have any extra whitespace between tags on " +
                "each line of your source code.";
            }
          } else {
            tagDisplayName = "<" + childTag + ">";
          }
          if (invalidParent) {
            var info = "";
            if (ancestorTag === "table" && childTag === "tr") {
              info +=
                " Add a <tbody> to your code to match the DOM tree generated by " +
                "the browser.";
            }
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "validateDOMNesting(...): %s cannot appear as a child of <%s>.%s " +
                    "See %s.%s",
                  tagDisplayName,
                  ancestorTag,
                  whitespaceInfo,
                  ownerInfo,
                  info
                )
              : void 0;
          } else {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "validateDOMNesting(...): %s cannot appear as a descendant of " +
                    "<%s>. See %s.",
                  tagDisplayName,
                  ancestorTag,
                  ownerInfo
                )
              : void 0;
          }
        }
      };
      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
      validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        return (
          isTagValidWithParent(tag, parentTag) &&
          !findInvalidAncestorForTag(tag, ancestorInfo)
        );
      };
    }
    module.exports = validateDOMNesting;
  },
  function(module, exports) {
    var g;
    g = (function() {
      return this;
    })();
    try {
      g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
      if (typeof window === "object") g = window;
    }
    module.exports = g;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _classnames = __webpack_require__(16);
    var _classnames2 = _interopRequireDefault(_classnames);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Collapsible = (function(_React$Component) {
      _inherits(Collapsible, _React$Component);
      function Collapsible(props) {
        _classCallCheck(this, Collapsible);
        var _this = _possibleConstructorReturn(
          this,
          (Collapsible.__proto__ || Object.getPrototypeOf(Collapsible)).call(
            this,
            props
          )
        );
        _this.toggleVisibility = function() {
          _this.setState({ collapsed: !_this.state.collapsed });
          ga("send", "event", "Components", "collapse");
        };
        _this.state = { collapsed: _this.props.collapsed };
        return _this;
      }
      _createClass(Collapsible, [
        {
          key: "render",
          value: function render() {
            var rootClassNames = {
              collapsible: true,
              component: true,
              collapsed: this.state.collapsed
            };
            if (this.props.className) {
              rootClassNames[this.props.className] = true;
            }
            var rootClasses = (0, _classnames2.default)(rootClassNames);
            var contentClasses = (0, _classnames2.default)({
              content: true,
              hide: this.state.collapsed
            });
            return _react2.default.createElement(
              "div",
              { id: this.props.id, className: rootClasses },
              _react2.default.createElement(
                "div",
                { className: "static", onClick: this.toggleVisibility },
                _react2.default.createElement("div", {
                  className: "collapse-button"
                }),
                this.props.children[0]
              ),
              _react2.default.createElement(
                "div",
                { className: contentClasses },
                this.props.children[1]
              )
            );
          }
        }
      ]);
      return Collapsible;
    })(_react2.default.Component);
    Collapsible.propTypes = {
      collapsed: _propTypes2.default.bool,
      children: _propTypes2.default.oneOfType([
        _propTypes2.default.array,
        _propTypes2.default.element
      ]).isRequired,
      id: _propTypes2.default.string
    };
    Collapsible.defaultProps = { collapsed: false };
    exports.default = Collapsible;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = ["visible", "position", "scale", "rotation"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _classnames = __webpack_require__(16);
    var _classnames2 = _interopRequireDefault(_classnames);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _lodash = __webpack_require__(24);
    var _lodash2 = _interopRequireDefault(_lodash);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    var _BooleanWidget = __webpack_require__(61);
    var _BooleanWidget2 = _interopRequireDefault(_BooleanWidget);
    var _ColorWidget = __webpack_require__(62);
    var _ColorWidget2 = _interopRequireDefault(_ColorWidget);
    var _InputWidget = __webpack_require__(63);
    var _InputWidget2 = _interopRequireDefault(_InputWidget);
    var _NumberWidget = __webpack_require__(23);
    var _NumberWidget2 = _interopRequireDefault(_NumberWidget);
    var _SelectWidget = __webpack_require__(64);
    var _SelectWidget2 = _interopRequireDefault(_SelectWidget);
    var _TextureWidget = __webpack_require__(65);
    var _TextureWidget2 = _interopRequireDefault(_TextureWidget);
    var _Vec4Widget = __webpack_require__(68);
    var _Vec4Widget2 = _interopRequireDefault(_Vec4Widget);
    var _Vec3Widget = __webpack_require__(67);
    var _Vec3Widget2 = _interopRequireDefault(_Vec3Widget);
    var _Vec2Widget = __webpack_require__(66);
    var _Vec2Widget2 = _interopRequireDefault(_Vec2Widget);
    var _entity = __webpack_require__(14);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var PropertyRow = (function(_React$Component) {
      _inherits(PropertyRow, _React$Component);
      function PropertyRow(props) {
        _classCallCheck(this, PropertyRow);
        var _this = _possibleConstructorReturn(
          this,
          (PropertyRow.__proto__ || Object.getPrototypeOf(PropertyRow)).call(
            this,
            props
          )
        );
        _this.id = props.componentname + ":" + props.name;
        if (
          ["position", "rotation", "scale"].indexOf(
            _this.props.componentname
          ) !== -1
        ) {
          _Events2.default.on(
            "entitytransformed",
            (0, _lodash2.default)(function(entity) {
              if (entity === props.entity) {
                _this.forceUpdate();
              }
            }, 250)
          );
        }
        return _this;
      }
      _createClass(PropertyRow, [
        {
          key: "getWidget",
          value: function getWidget() {
            var props = this.props;
            var isMap =
              props.componentname === "material" &&
              (props.name === "envMap" || props.name === "src");
            var type = props.schema.type;
            var value =
              props.schema.type === "selector"
                ? props.entity.getDOMAttribute(props.componentname)[props.name]
                : props.data;
            var widgetProps = {
              componentname: props.componentname,
              entity: props.entity,
              isSingle: props.isSingle,
              name: props.name,
              onChange: function onChange(name, value) {
                var propertyName = props.componentname;
                if (!props.isSingle) {
                  propertyName += "." + props.name;
                }
                _entity.updateEntity.apply(this, [
                  props.entity,
                  propertyName,
                  value
                ]);
              },
              value: value
            };
            var numberWidgetProps = {
              min: props.schema.hasOwnProperty("min")
                ? props.schema.min
                : -Infinity,
              max: props.schema.hasOwnProperty("max")
                ? props.schema.max
                : Infinity
            };
            if (props.schema.oneOf && props.schema.oneOf.length > 0) {
              return _react2.default.createElement(
                _SelectWidget2.default,
                _extends({}, widgetProps, { options: props.schema.oneOf })
              );
            }
            if (type === "map" || isMap) {
              return _react2.default.createElement(
                _TextureWidget2.default,
                widgetProps
              );
            }
            switch (type) {
              case "number": {
                return _react2.default.createElement(
                  _NumberWidget2.default,
                  _extends({}, widgetProps, numberWidgetProps)
                );
              }
              case "int": {
                return _react2.default.createElement(
                  _NumberWidget2.default,
                  _extends({}, widgetProps, numberWidgetProps, { precision: 0 })
                );
              }
              case "vec2": {
                return _react2.default.createElement(
                  _Vec2Widget2.default,
                  widgetProps
                );
              }
              case "vec3": {
                return _react2.default.createElement(
                  _Vec3Widget2.default,
                  widgetProps
                );
              }
              case "vec4": {
                return _react2.default.createElement(
                  _Vec4Widget2.default,
                  widgetProps
                );
              }
              case "color": {
                return _react2.default.createElement(
                  _ColorWidget2.default,
                  widgetProps
                );
              }
              case "boolean": {
                return _react2.default.createElement(
                  _BooleanWidget2.default,
                  widgetProps
                );
              }
              default: {
                return _react2.default.createElement(
                  _InputWidget2.default,
                  widgetProps
                );
              }
            }
          }
        },
        {
          key: "render",
          value: function render() {
            var props = this.props;
            var value =
              props.schema.type === "selector"
                ? props.entity.getDOMAttribute(props.componentname)[props.name]
                : JSON.stringify(props.data);
            var title =
              props.name +
              "\n - type: " +
              props.schema.type +
              "\n - value: " +
              value;
            var className = (0, _classnames2.default)({
              propertyRow: true,
              propertyRowDefined: props.isSingle
                ? !!props.entity.getDOMAttribute(props.componentname)
                : props.name in
                  (props.entity.getDOMAttribute(props.componentname) || {})
            });
            return _react2.default.createElement(
              "div",
              { className: className },
              _react2.default.createElement(
                "label",
                { htmlFor: this.id, className: "text", title: title },
                props.name
              ),
              this.getWidget(props.schema.type)
            );
          }
        }
      ]);
      return PropertyRow;
    })(_react2.default.Component);
    PropertyRow.propTypes = {
      componentname: _propTypes2.default.string.isRequired,
      id: _propTypes2.default.string,
      name: _propTypes2.default.string.isRequired,
      schema: _propTypes2.default.object.isRequired
    };
    exports.default = PropertyRow;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var Modal = (function(_React$Component) {
      _inherits(Modal, _React$Component);
      function Modal(props) {
        _classCallCheck(this, Modal);
        var _this = _possibleConstructorReturn(
          this,
          (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props)
        );
        _this.handleGlobalKeydown = function(event) {
          if (
            _this.state.isOpen &&
            (event.keyCode === 27 ||
              (_this.props.extraCloseKeyCode &&
                event.keyCode === _this.props.extraCloseKeyCode))
          ) {
            _this.close();
            event.stopPropagation();
          }
        };
        _this.shouldClickDismiss = function(event) {
          var target = event.target;
          if (target.tagName === "INPUT" && target.type === "file") {
            return false;
          }
          if (target === _this.refs.self || _this.refs.self.contains(target))
            return false;
          return true;
        };
        _this.handleGlobalMousedown = function(event) {
          if (
            _this.props.closeOnClickOutside &&
            _this.state.isOpen &&
            _this.shouldClickDismiss(event)
          ) {
            if (typeof _this.props.onClose === "function") {
              _this.props.onClose();
            }
          }
        };
        _this.close = function() {
          _this.setState({ isOpen: false });
          if (_this.props.onClose) {
            _this.props.onClose();
          }
        };
        _this.state = { isOpen: _this.props.isOpen };
        return _this;
      }
      _createClass(Modal, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            document.addEventListener("keyup", this.handleGlobalKeydown);
            document.addEventListener("mousedown", this.handleGlobalMousedown);
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            document.removeEventListener("keyup", this.handleGlobalKeydown);
            document.removeEventListener(
              "mousedown",
              this.handleGlobalMousedown
            );
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (this.state.isOpen !== newProps.isOpen) {
              this.setState({ isOpen: newProps.isOpen });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement(
              "div",
              {
                id: this.props.id,
                className: this.state.isOpen ? "modal" : "modal hide"
              },
              React.createElement(
                "div",
                { className: "modal-content", ref: "self" },
                React.createElement(
                  "div",
                  { className: "modal-header" },
                  React.createElement(
                    "span",
                    { className: "close", onClick: this.close },
                    "\xD7"
                  ),
                  React.createElement("h3", null, this.props.title)
                ),
                React.createElement(
                  "div",
                  { className: "modal-body" },
                  this.props.children
                )
              )
            );
          }
        }
      ]);
      return Modal;
    })(React.Component);
    Modal.propTypes = {
      id: _propTypes2.default.string,
      children: _propTypes2.default.oneOfType([
        _propTypes2.default.array,
        _propTypes2.default.element
      ]).isRequired,
      isOpen: _propTypes2.default.bool,
      extraCloseKeyCode: _propTypes2.default.number,
      closeOnClickOutside: _propTypes2.default.bool,
      onClose: _propTypes2.default.func,
      title: _propTypes2.default.string
    };
    Modal.defaultProps = { closeOnClickOutside: true };
    exports.default = Modal;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var BooleanWidget = (function(_React$Component) {
      _inherits(BooleanWidget, _React$Component);
      function BooleanWidget(props) {
        _classCallCheck(this, BooleanWidget);
        var _this = _possibleConstructorReturn(
          this,
          (
            BooleanWidget.__proto__ || Object.getPrototypeOf(BooleanWidget)
          ).call(this, props)
        );
        _this.onChange = function(e) {
          var value = e.target.checked;
          _this.setState({ value: value });
          if (_this.props.onChange) {
            _this.props.onChange(_this.props.name, value);
          }
        };
        _this.state = { value: _this.props.value };
        return _this;
      }
      _createClass(BooleanWidget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (newProps.value !== this.state.value) {
              this.setState({ value: newProps.value });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            var id = this.props.componentname + "." + this.props.name;
            return React.createElement("input", {
              id: id,
              ref: "input",
              type: "checkbox",
              checked: this.state.value,
              value: this.state.value,
              onChange: this.onChange
            });
          }
        }
      ]);
      return BooleanWidget;
    })(React.Component);
    BooleanWidget.propTypes = {
      componentname: _propTypes2.default.string.isRequired,
      entity: _propTypes2.default.object,
      name: _propTypes2.default.string.isRequired,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.bool
    };
    BooleanWidget.defaultProps = { value: false };
    exports.default = BooleanWidget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var ColorWidget = (function(_React$Component) {
      _inherits(ColorWidget, _React$Component);
      function ColorWidget(props) {
        _classCallCheck(this, ColorWidget);
        var _this = _possibleConstructorReturn(
          this,
          (ColorWidget.__proto__ || Object.getPrototypeOf(ColorWidget)).call(
            this,
            props
          )
        );
        _this.onChange = function(e) {
          _this.setValue(e.target.value);
        };
        _this.onKeyUp = function(e) {
          e.stopPropagation();
          _this.setValue(e.target.value);
        };
        _this.onChangeText = function(e) {
          _this.setState({ value: e.target.value });
        };
        var value = _this.props.value;
        _this.color = new THREE.Color();
        _this.state = { value: value, pickerValue: _this.getHexString(value) };
        return _this;
      }
      _createClass(ColorWidget, [
        {
          key: "setValue",
          value: function setValue(value) {
            var pickerValue = this.getHexString(value);
            this.setState({ value: value, pickerValue: pickerValue });
            if (this.props.onChange) {
              this.props.onChange(this.props.name, value);
            }
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (newProps.value !== this.state.value) {
              this.setState({
                value: newProps.value,
                pickerValue: this.getHexString(newProps.value)
              });
            }
          }
        },
        {
          key: "getHexString",
          value: function getHexString(value) {
            return "#" + this.color.set(value).getHexString();
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement(
              "span",
              { className: "color-widget" },
              React.createElement("input", {
                type: "color",
                className: "color",
                value: this.state.pickerValue,
                title: this.state.value,
                onChange: this.onChange
              }),
              React.createElement("input", {
                type: "text",
                className: "color_value",
                value: this.state.value,
                onKeyUp: this.onKeyUp,
                onChange: this.onChangeText
              })
            );
          }
        }
      ]);
      return ColorWidget;
    })(React.Component);
    ColorWidget.propTypes = {
      componentname: _propTypes2.default.string.isRequired,
      entity: _propTypes2.default.object,
      name: _propTypes2.default.string.isRequired,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.string
    };
    ColorWidget.defaultProps = { value: "#ffffff" };
    exports.default = ColorWidget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var InputWidget = (function(_React$Component) {
      _inherits(InputWidget, _React$Component);
      function InputWidget(props) {
        _classCallCheck(this, InputWidget);
        var _this = _possibleConstructorReturn(
          this,
          (InputWidget.__proto__ || Object.getPrototypeOf(InputWidget)).call(
            this,
            props
          )
        );
        _this.onChange = function(e) {
          var value = e.target.value;
          _this.setState({ value: value });
          if (_this.props.onChange) {
            _this.props.onChange(_this.props.name, value);
          }
        };
        _this.state = { value: _this.props.value || "" };
        return _this;
      }
      _createClass(InputWidget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (newProps.value !== this.state.value) {
              this.setState({ value: newProps.value });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement("input", {
              type: "text",
              className: "string",
              value: this.state.value || "",
              onChange: this.onChange
            });
          }
        }
      ]);
      return InputWidget;
    })(React.Component);
    InputWidget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      name: _propTypes2.default.string.isRequired,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.any
    };
    exports.default = InputWidget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _reactSelect = __webpack_require__(37);
    var _reactSelect2 = _interopRequireDefault(_reactSelect);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var SelectWidget = (function(_React$Component) {
      _inherits(SelectWidget, _React$Component);
      function SelectWidget(props) {
        _classCallCheck(this, SelectWidget);
        var _this = _possibleConstructorReturn(
          this,
          (SelectWidget.__proto__ || Object.getPrototypeOf(SelectWidget)).call(
            this,
            props
          )
        );
        _initialiseProps.call(_this);
        var value = _this.props.value || "";
        _this.state = { value: { value: value, label: value } };
        return _this;
      }
      _createClass(SelectWidget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (newProps.value !== this.state.value.value) {
              this.setState({
                value: { value: newProps.value, label: newProps.value }
              });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            var options = this.props.options.map(function(value) {
              return { value: value, label: value };
            });
            return React.createElement(_reactSelect2.default, {
              className: "select-widget",
              classNamePrefix: "select",
              options: options,
              simpleValue: true,
              clearable: true,
              placeholder: "",
              value: this.state.value,
              noResultsText: "No value found",
              onChange: this.onChange,
              searchable: true
            });
          }
        }
      ]);
      return SelectWidget;
    })(React.Component);
    SelectWidget.propTypes = {
      componentname: _propTypes2.default.string.isRequired,
      entity: _propTypes2.default.object,
      name: _propTypes2.default.string.isRequired,
      onChange: _propTypes2.default.func,
      options: _propTypes2.default.array.isRequired,
      value: _propTypes2.default.string
    };
    var _initialiseProps = function _initialiseProps() {
      var _this2 = this;
      this.onChange = function(value) {
        _this2.setState({ value: value });
        if (_this2.props.onChange) {
          _this2.props.onChange(_this2.props.name, value.value);
        }
      };
    };
    exports.default = SelectWidget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Events = __webpack_require__(5);
    function getUrlFromId(assetId) {
      return (
        assetId.length > 1 &&
        document.querySelector(assetId) &&
        document.querySelector(assetId).getAttribute("src")
      );
    }
    function GetFilename(url) {
      if (url) {
        var m = url.toString().match(/.*\/(.+?)\./);
        if (m && m.length > 1) {
          return m[1];
        }
      }
      return "";
    }
    function insertNewAsset(type, id, src) {
      var element = null;
      switch (type) {
        case "img":
          {
            element = document.createElement("img");
            element.id = id;
            element.src = src;
          }
          break;
      }
      if (element) {
        document.getElementsByTagName("a-assets")[0].appendChild(element);
      }
    }
    function insertOrGetImageAsset(src) {
      var id = GetFilename(src);
      var element = document.querySelector("a-assets > img[src='" + src + "']");
      if (element) {
        id = element.id;
      } else {
        if (!isNaN(parseInt(id[0], 10))) {
          id = "i" + id;
        }
        if (document.getElementById(id)) {
          var i = 1;
          while (document.getElementById(id + "_" + i)) {
            i++;
          }
          id += "_" + i;
        }
        insertNewAsset("img", id, src);
      }
      return id;
    }
    var TextureWidget = (function(_React$Component) {
      _inherits(TextureWidget, _React$Component);
      function TextureWidget(props) {
        _classCallCheck(this, TextureWidget);
        var _this = _possibleConstructorReturn(
          this,
          (
            TextureWidget.__proto__ || Object.getPrototypeOf(TextureWidget)
          ).call(this, props)
        );
        _this.notifyChanged = function(value) {
          if (_this.props.onChange) {
            _this.props.onChange(_this.props.name, value);
          }
          _this.setState({ value: value });
        };
        _this.onChange = function(e) {
          var value = e.target.value;
          _this.setState({ value: value });
          _this.notifyChanged(value);
        };
        _this.removeMap = function(e) {
          _this.setValue("");
          _this.notifyChanged("");
        };
        _this.openDialog = function() {
          Events.emit("opentexturesmodal", _this.state.value, function(image) {
            if (!image) {
              return;
            }
            var value = image.value;
            if (image.type !== "asset") {
              var assetId = insertOrGetImageAsset(image.src);
              value = "#" + assetId;
            }
            if (_this.props.onChange) {
              _this.props.onChange(_this.props.name, value);
            }
            _this.setValue(value);
          });
        };
        _this.state = { value: _this.props.value || "" };
        return _this;
      }
      _createClass(TextureWidget, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.setValue(this.props.value || "");
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            var component = this.props.entity.components[
              this.props.componentname
            ];
            if (!component) {
              return;
            }
            var newValue = component.attrValue[this.props.name];
            if (newValue && newValue !== this.state.value) {
              this.setValue(newValue);
            }
          }
        },
        {
          key: "setValue",
          value: function setValue(value) {
            var canvas = this.refs.canvas;
            var context = canvas.getContext("2d");
            function paintPreviewWithImage(image) {
              var filename = image.src.replace(/^.*[\\\/]/, "");
              if (image !== undefined && image.width > 0) {
                canvas.title = filename;
                var scale = canvas.width / image.width;
                context.drawImage(
                  image,
                  0,
                  0,
                  image.width * scale,
                  image.height * scale
                );
              } else {
                context.clearRect(0, 0, canvas.width, canvas.height);
              }
            }
            function paintPreview(texture) {
              var image = texture.image;
              paintPreviewWithImage(image);
            }
            function getTextureFromSrc(src) {
              for (var hash in AFRAME.INSPECTOR.sceneEl.systems.material
                .textureCache) {
                if (JSON.parse(hash).src === src) {
                  return AFRAME.INSPECTOR.sceneEl.systems.material.textureCache[
                    hash
                  ];
                }
              }
              return null;
            }
            var url;
            var isAssetHash = value[0] === "#";
            var isAssetImg = value instanceof HTMLImageElement;
            if (isAssetImg) {
              url = value.src;
            } else if (isAssetHash) {
              url = getUrlFromId(value);
            } else {
              url = AFRAME.utils.srcLoader.parseUrl(value);
            }
            var texture = getTextureFromSrc(value);
            var valueType = null;
            valueType = isAssetImg || isAssetHash ? "asset" : "url";
            if (texture) {
              texture.then(paintPreview);
            } else if (url) {
              var image = new Image();
              image.addEventListener(
                "load",
                function() {
                  paintPreviewWithImage(image);
                },
                false
              );
              image.src = url;
            } else {
              context.clearRect(0, 0, canvas.width, canvas.height);
            }
            this.setState({
              value: isAssetImg ? "#" + value.id : value,
              valueType: valueType,
              url: url
            });
          }
        },
        {
          key: "render",
          value: function render() {
            var hint = "";
            if (this.state.value) {
              if (this.state.valueType === "asset") {
                hint =
                  "Asset ID: " + this.state.value + "\nURL: " + this.state.url;
              } else {
                hint = "URL: " + this.state.value;
              }
            }
            return _react2.default.createElement(
              "span",
              { className: "texture" },
              _react2.default.createElement("input", {
                className: "map_value string",
                type: "text",
                title: hint,
                value: this.state.value,
                onChange: this.onChange
              }),
              _react2.default.createElement("canvas", {
                ref: "canvas",
                width: "32",
                height: "16",
                title: hint,
                onClick: this.openDialog
              })
            );
          }
        }
      ]);
      return TextureWidget;
    })(_react2.default.Component);
    TextureWidget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      mapName: _propTypes2.default.string,
      name: _propTypes2.default.string.isRequired,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.oneOfType([
        _propTypes2.default.object,
        _propTypes2.default.string
      ])
    };
    TextureWidget.defaultProps = { value: "", mapName: "nomap", dataURL: "" };
    exports.default = TextureWidget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _NumberWidget = __webpack_require__(23);
    var _NumberWidget2 = _interopRequireDefault(_NumberWidget);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Vec2Widget = (function(_React$Component) {
      _inherits(Vec2Widget, _React$Component);
      function Vec2Widget(props) {
        _classCallCheck(this, Vec2Widget);
        var _this = _possibleConstructorReturn(
          this,
          (Vec2Widget.__proto__ || Object.getPrototypeOf(Vec2Widget)).call(
            this,
            props
          )
        );
        _this.onChange = function(name, value) {
          _this.setState(
            _defineProperty({}, name, parseFloat(value.toFixed(5))),
            function() {
              if (_this.props.onChange) {
                _this.props.onChange(name, _this.state);
              }
            }
          );
        };
        _this.state = { x: props.value.x, y: props.value.y };
        return _this;
      }
      _createClass(Vec2Widget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            this.setState(nextProps.value);
          }
        },
        {
          key: "render",
          value: function render() {
            var widgetProps = {
              componentname: this.props.componentname,
              entity: this.props.entity,
              onChange: this.onChange
            };
            return _react2.default.createElement(
              "div",
              { className: "vec2" },
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "x", value: this.state.x }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "y", value: this.state.y }, widgetProps)
              )
            );
          }
        }
      ]);
      return Vec2Widget;
    })(_react2.default.Component);
    Vec2Widget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.object.isRequired
    };
    exports.default = Vec2Widget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _NumberWidget = __webpack_require__(23);
    var _NumberWidget2 = _interopRequireDefault(_NumberWidget);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Vec3Widget = (function(_React$Component) {
      _inherits(Vec3Widget, _React$Component);
      function Vec3Widget(props) {
        _classCallCheck(this, Vec3Widget);
        var _this = _possibleConstructorReturn(
          this,
          (Vec3Widget.__proto__ || Object.getPrototypeOf(Vec3Widget)).call(
            this,
            props
          )
        );
        _this.onChange = function(name, value) {
          _this.setState(
            _defineProperty({}, name, parseFloat(value.toFixed(5))),
            function() {
              if (_this.props.onChange) {
                _this.props.onChange(name, _this.state);
              }
            }
          );
        };
        _this.state = { x: props.value.x, y: props.value.y, z: props.value.z };
        return _this;
      }
      _createClass(Vec3Widget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            this.setState(nextProps.value);
          }
        },
        {
          key: "render",
          value: function render() {
            var widgetProps = {
              componentname: this.props.componentname,
              entity: this.props.entity,
              onChange: this.onChange
            };
            return _react2.default.createElement(
              "div",
              { className: "vec3" },
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "x", value: this.state.x }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "y", value: this.state.y }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "z", value: this.state.z }, widgetProps)
              )
            );
          }
        }
      ]);
      return Vec3Widget;
    })(_react2.default.Component);
    Vec3Widget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.object.isRequired
    };
    exports.default = Vec3Widget;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _NumberWidget = __webpack_require__(23);
    var _NumberWidget2 = _interopRequireDefault(_NumberWidget);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Vec4Widget = (function(_React$Component) {
      _inherits(Vec4Widget, _React$Component);
      function Vec4Widget(props) {
        _classCallCheck(this, Vec4Widget);
        var _this = _possibleConstructorReturn(
          this,
          (Vec4Widget.__proto__ || Object.getPrototypeOf(Vec4Widget)).call(
            this,
            props
          )
        );
        _this.onChange = function(name, value) {
          _this.setState(
            _defineProperty({}, name, parseFloat(value.toFixed(5))),
            function() {
              if (_this.props.onChange) {
                _this.props.onChange(name, _this.state);
              }
            }
          );
        };
        _this.state = {
          x: props.value.x,
          y: props.value.y,
          z: props.value.z,
          w: props.value.w
        };
        return _this;
      }
      _createClass(Vec4Widget, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            this.setState(nextProps.value);
          }
        },
        {
          key: "render",
          value: function render() {
            var widgetProps = {
              componentname: this.props.componentname,
              entity: this.props.entity,
              onChange: this.onChange
            };
            return _react2.default.createElement(
              "div",
              { className: "vec4" },
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "x", value: this.state.x }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "y", value: this.state.y }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "z", value: this.state.z }, widgetProps)
              ),
              _react2.default.createElement(
                _NumberWidget2.default,
                _extends({ name: "w", value: this.state.w }, widgetProps)
              )
            );
          }
        }
      ]);
      return Vec4Widget;
    })(_react2.default.Component);
    Vec4Widget.propTypes = {
      componentname: _propTypes2.default.string,
      entity: _propTypes2.default.object,
      onChange: _propTypes2.default.func,
      value: _propTypes2.default.object.isRequired
    };
    exports.default = Vec4Widget;
  },
  function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__,
      __WEBPACK_AMD_DEFINE_ARRAY__,
      __WEBPACK_AMD_DEFINE_RESULT__;
    (function(global, factory) {
      if (true) {
        !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
          module,
          __webpack_require__(138),
          __webpack_require__(254),
          __webpack_require__(163)
        ]),
        (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
        (__WEBPACK_AMD_DEFINE_RESULT__ =
          typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
            ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                exports,
                __WEBPACK_AMD_DEFINE_ARRAY__
              )
            : __WEBPACK_AMD_DEFINE_FACTORY__),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if (typeof exports !== "undefined") {
        factory(
          module,
          require("./clipboard-action"),
          require("tiny-emitter"),
          require("good-listener")
        );
      } else {
        var mod = { exports: {} };
        factory(
          mod,
          global.clipboardAction,
          global.tinyEmitter,
          global.goodListener
        );
        global.clipboard = mod.exports;
      }
    })(this, function(module, _clipboardAction, _tinyEmitter, _goodListener) {
      "use strict";
      var _clipboardAction2 = _interopRequireDefault(_clipboardAction);
      var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);
      var _goodListener2 = _interopRequireDefault(_goodListener);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function(obj) {
              return typeof obj;
            }
          : function(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _createClass = (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        }
        return call && (typeof call === "object" || typeof call === "function")
          ? call
          : self;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError(
            "Super expression must either be null or a function, not " +
              typeof superClass
          );
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          Object.setPrototypeOf
            ? Object.setPrototypeOf(subClass, superClass)
            : (subClass.__proto__ = superClass);
      }
      var Clipboard = (function(_Emitter) {
        _inherits(Clipboard, _Emitter);
        function Clipboard(trigger, options) {
          _classCallCheck(this, Clipboard);
          var _this = _possibleConstructorReturn(
            this,
            (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this)
          );
          _this.resolveOptions(options);
          _this.listenClick(trigger);
          return _this;
        }
        _createClass(
          Clipboard,
          [
            {
              key: "resolveOptions",
              value: function resolveOptions() {
                var options =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {};
                this.action =
                  typeof options.action === "function"
                    ? options.action
                    : this.defaultAction;
                this.target =
                  typeof options.target === "function"
                    ? options.target
                    : this.defaultTarget;
                this.text =
                  typeof options.text === "function"
                    ? options.text
                    : this.defaultText;
                this.container =
                  _typeof(options.container) === "object"
                    ? options.container
                    : document.body;
              }
            },
            {
              key: "listenClick",
              value: function listenClick(trigger) {
                var _this2 = this;
                this.listener = (0, _goodListener2.default)(
                  trigger,
                  "click",
                  function(e) {
                    return _this2.onClick(e);
                  }
                );
              }
            },
            {
              key: "onClick",
              value: function onClick(e) {
                var trigger = e.delegateTarget || e.currentTarget;
                if (this.clipboardAction) {
                  this.clipboardAction = null;
                }
                this.clipboardAction = new _clipboardAction2.default({
                  action: this.action(trigger),
                  target: this.target(trigger),
                  text: this.text(trigger),
                  container: this.container,
                  trigger: trigger,
                  emitter: this
                });
              }
            },
            {
              key: "defaultAction",
              value: function defaultAction(trigger) {
                return getAttributeValue("action", trigger);
              }
            },
            {
              key: "defaultTarget",
              value: function defaultTarget(trigger) {
                var selector = getAttributeValue("target", trigger);
                if (selector) {
                  return document.querySelector(selector);
                }
              }
            },
            {
              key: "defaultText",
              value: function defaultText(trigger) {
                return getAttributeValue("text", trigger);
              }
            },
            {
              key: "destroy",
              value: function destroy() {
                this.listener.destroy();
                if (this.clipboardAction) {
                  this.clipboardAction.destroy();
                  this.clipboardAction = null;
                }
              }
            }
          ],
          [
            {
              key: "isSupported",
              value: function isSupported() {
                var action =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : ["copy", "cut"];
                var actions = typeof action === "string" ? [action] : action;
                var support = !!document.queryCommandSupported;
                actions.forEach(function(action) {
                  support = support && !!document.queryCommandSupported(action);
                });
                return support;
              }
            }
          ]
        );
        return Clipboard;
      })(_tinyEmitter2.default);
      function getAttributeValue(suffix, element) {
        var attribute = "data-clipboard-" + suffix;
        if (!element.hasAttribute(attribute)) {
          return;
        }
        return element.getAttribute(attribute);
      }
      module.exports = Clipboard;
    });
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var emptyFunction = __webpack_require__(10);
    var EventListener = {
      listen: function listen(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {
            remove: function remove() {
              target.removeEventListener(eventType, callback, false);
            }
          };
        } else if (target.attachEvent) {
          target.attachEvent("on" + eventType, callback);
          return {
            remove: function remove() {
              target.detachEvent("on" + eventType, callback);
            }
          };
        }
      },
      capture: function capture(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, true);
          return {
            remove: function remove() {
              target.removeEventListener(eventType, callback, true);
            }
          };
        } else {
          if (false) {
            console.error(
              "Attempted to listen to events during the capture phase on a " +
                "browser that does not support the capture phase. Your application " +
                "will not receive some events."
            );
          }
          return { remove: emptyFunction };
        }
      },
      registerDefault: function registerDefault() {}
    };
    module.exports = EventListener;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function focusNode(node) {
      try {
        node.focus();
      } catch (e) {}
    }
    module.exports = focusNode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function getActiveElement(doc) {
      doc = doc || (typeof document !== "undefined" ? document : undefined);
      if (typeof doc === "undefined") {
        return null;
      }
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    module.exports = getActiveElement;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var factory = __webpack_require__(168);
    module.exports = function(isValidElement) {
      var throwOnDirectAccess = false;
      return factory(isValidElement, throwOnDirectAccess);
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var isUnitlessNumber = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    function prefixKey(prefix, key) {
      return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    var prefixes = ["Webkit", "ms", "Moz", "O"];
    Object.keys(isUnitlessNumber).forEach(function(prop) {
      prefixes.forEach(function(prefix) {
        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
      });
    });
    var shorthandPropertyExpansions = {
      background: {
        backgroundAttachment: true,
        backgroundColor: true,
        backgroundImage: true,
        backgroundPositionX: true,
        backgroundPositionY: true,
        backgroundRepeat: true
      },
      backgroundPosition: {
        backgroundPositionX: true,
        backgroundPositionY: true
      },
      border: { borderWidth: true, borderStyle: true, borderColor: true },
      borderBottom: {
        borderBottomWidth: true,
        borderBottomStyle: true,
        borderBottomColor: true
      },
      borderLeft: {
        borderLeftWidth: true,
        borderLeftStyle: true,
        borderLeftColor: true
      },
      borderRight: {
        borderRightWidth: true,
        borderRightStyle: true,
        borderRightColor: true
      },
      borderTop: {
        borderTopWidth: true,
        borderTopStyle: true,
        borderTopColor: true
      },
      font: {
        fontStyle: true,
        fontVariant: true,
        fontWeight: true,
        fontSize: true,
        lineHeight: true,
        fontFamily: true
      },
      outline: { outlineWidth: true, outlineStyle: true, outlineColor: true }
    };
    var CSSProperty = {
      isUnitlessNumber: isUnitlessNumber,
      shorthandPropertyExpansions: shorthandPropertyExpansions
    };
    module.exports = CSSProperty;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var PooledClass = __webpack_require__(17);
    var invariant = __webpack_require__(0);
    var CallbackQueue = (function() {
      function CallbackQueue(arg) {
        _classCallCheck(this, CallbackQueue);
        this._callbacks = null;
        this._contexts = null;
        this._arg = arg;
      }
      CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
        this._callbacks = this._callbacks || [];
        this._callbacks.push(callback);
        this._contexts = this._contexts || [];
        this._contexts.push(context);
      };
      CallbackQueue.prototype.notifyAll = function notifyAll() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        var arg = this._arg;
        if (callbacks && contexts) {
          !(callbacks.length === contexts.length)
            ? false
              ? invariant(
                  false,
                  "Mismatched list of contexts in callback queue"
                )
              : _prodInvariant("24")
            : void 0;
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i], arg);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      };
      CallbackQueue.prototype.checkpoint = function checkpoint() {
        return this._callbacks ? this._callbacks.length : 0;
      };
      CallbackQueue.prototype.rollback = function rollback(len) {
        if (this._callbacks && this._contexts) {
          this._callbacks.length = len;
          this._contexts.length = len;
        }
      };
      CallbackQueue.prototype.reset = function reset() {
        this._callbacks = null;
        this._contexts = null;
      };
      CallbackQueue.prototype.destructor = function destructor() {
        this.reset();
      };
      return CallbackQueue;
    })();
    module.exports = PooledClass.addPoolingTo(CallbackQueue);
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMProperty = __webpack_require__(19);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactInstrumentation = __webpack_require__(9);
    var quoteAttributeValueForBrowser = __webpack_require__(231);
    var warning = __webpack_require__(4);
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
      "^[" +
        DOMProperty.ATTRIBUTE_NAME_START_CHAR +
        "][" +
        DOMProperty.ATTRIBUTE_NAME_CHAR +
        "]*$"
    );
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
        return true;
      }
      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
        return false;
      }
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = true;
        return true;
      }
      illegalAttributeNameCache[attributeName] = true;
      false
        ? warning(false, "Invalid attribute name: `%s`", attributeName)
        : void 0;
      return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
      return (
        value == null ||
        (propertyInfo.hasBooleanValue && !value) ||
        (propertyInfo.hasNumericValue && isNaN(value)) ||
        (propertyInfo.hasPositiveNumericValue && value < 1) ||
        (propertyInfo.hasOverloadedBooleanValue && value === false)
      );
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return (
          DOMProperty.ID_ATTRIBUTE_NAME +
          "=" +
          quoteAttributeValueForBrowser(id)
        );
      },
      setAttributeForID: function(node, id) {
        node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
      },
      createMarkupForRoot: function() {
        return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
      },
      setAttributeForRoot: function(node) {
        node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, "");
      },
      createMarkupForProperty: function(name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name)
          ? DOMProperty.properties[name]
          : null;
        if (propertyInfo) {
          if (shouldIgnoreValue(propertyInfo, value)) {
            return "";
          }
          var attributeName = propertyInfo.attributeName;
          if (
            propertyInfo.hasBooleanValue ||
            (propertyInfo.hasOverloadedBooleanValue && value === true)
          ) {
            return attributeName + '=""';
          }
          return attributeName + "=" + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        return null;
      },
      createMarkupForCustomAttribute: function(name, value) {
        if (!isAttributeNameSafe(name) || value == null) {
          return "";
        }
        return name + "=" + quoteAttributeValueForBrowser(value);
      },
      setValueForProperty: function(node, name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name)
          ? DOMProperty.properties[name]
          : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(propertyInfo, value)) {
            this.deleteValueForProperty(node, name);
            return;
          } else if (propertyInfo.mustUseProperty) {
            node[propertyInfo.propertyName] = value;
          } else {
            var attributeName = propertyInfo.attributeName;
            var namespace = propertyInfo.attributeNamespace;
            if (namespace) {
              node.setAttributeNS(namespace, attributeName, "" + value);
            } else if (
              propertyInfo.hasBooleanValue ||
              (propertyInfo.hasOverloadedBooleanValue && value === true)
            ) {
              node.setAttribute(attributeName, "");
            } else {
              node.setAttribute(attributeName, "" + value);
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          DOMPropertyOperations.setValueForAttribute(node, name, value);
          return;
        }
        if (false) {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)
              ._debugID,
            type: "update attribute",
            payload: payload
          });
        }
      },
      setValueForAttribute: function(node, name, value) {
        if (!isAttributeNameSafe(name)) {
          return;
        }
        if (value == null) {
          node.removeAttribute(name);
        } else {
          node.setAttribute(name, "" + value);
        }
        if (false) {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)
              ._debugID,
            type: "update attribute",
            payload: payload
          });
        }
      },
      deleteValueForAttribute: function(node, name) {
        node.removeAttribute(name);
        if (false) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)
              ._debugID,
            type: "remove attribute",
            payload: name
          });
        }
      },
      deleteValueForProperty: function(node, name) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name)
          ? DOMProperty.properties[name]
          : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (propertyInfo.mustUseProperty) {
            var propName = propertyInfo.propertyName;
            if (propertyInfo.hasBooleanValue) {
              node[propName] = false;
            } else {
              node[propName] = "";
            }
          } else {
            node.removeAttribute(propertyInfo.attributeName);
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        }
        if (false) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)
              ._debugID,
            type: "remove attribute",
            payload: name
          });
        }
      }
    };
    module.exports = DOMPropertyOperations;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMComponentFlags = { hasCachedChildNodes: 1 << 0 };
    module.exports = ReactDOMComponentFlags;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var LinkedValueUtils = __webpack_require__(45);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactUpdates = __webpack_require__(11);
    var warning = __webpack_require__(4);
    var didWarnValueLink = false;
    var didWarnValueDefaultValue = false;
    function updateOptionsIfPendingUpdateAndMounted() {
      if (this._rootNodeID && this._wrapperState.pendingUpdate) {
        this._wrapperState.pendingUpdate = false;
        var props = this._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          updateOptions(this, Boolean(props.multiple), value);
        }
      }
    }
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return " Check the render method of `" + name + "`.";
        }
      }
      return "";
    }
    var valuePropNames = ["value", "defaultValue"];
    function checkSelectPropTypes(inst, props) {
      var owner = inst._currentElement._owner;
      LinkedValueUtils.checkPropTypes("select", props, owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        false
          ? warning(
              false,
              "`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead."
            )
          : void 0;
        didWarnValueLink = true;
      }
      for (var i = 0; i < valuePropNames.length; i++) {
        var propName = valuePropNames[i];
        if (props[propName] == null) {
          continue;
        }
        var isArray = Array.isArray(props[propName]);
        if (props.multiple && !isArray) {
          false
            ? warning(
                false,
                "The `%s` prop supplied to <select> must be an array if " +
                  "`multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum(owner)
              )
            : void 0;
        } else if (!props.multiple && isArray) {
          false
            ? warning(
                false,
                "The `%s` prop supplied to <select> must be a scalar " +
                  "value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum(owner)
              )
            : void 0;
        }
      }
    }
    function updateOptions(inst, multiple, propValue) {
      var selectedValue, i;
      var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
      if (multiple) {
        selectedValue = {};
        for (i = 0; i < propValue.length; i++) {
          selectedValue["" + propValue[i]] = true;
        }
        for (i = 0; i < options.length; i++) {
          var selected = selectedValue.hasOwnProperty(options[i].value);
          if (options[i].selected !== selected) {
            options[i].selected = selected;
          }
        }
      } else {
        selectedValue = "" + propValue;
        for (i = 0; i < options.length; i++) {
          if (options[i].value === selectedValue) {
            options[i].selected = true;
            return;
          }
        }
        if (options.length) {
          options[0].selected = true;
        }
      }
    }
    var ReactDOMSelect = {
      getHostProps: function(inst, props) {
        return _assign({}, props, {
          onChange: inst._wrapperState.onChange,
          value: undefined
        });
      },
      mountWrapper: function(inst, props) {
        if (false) {
          checkSelectPropTypes(inst, props);
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          pendingUpdate: false,
          initialValue: value != null ? value : props.defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst),
          wasMultiple: Boolean(props.multiple)
        };
        if (
          props.value !== undefined &&
          props.defaultValue !== undefined &&
          !didWarnValueDefaultValue
        ) {
          false
            ? warning(
                false,
                "Select elements must be either controlled or uncontrolled " +
                  "(specify either the value prop, or the defaultValue prop, but not " +
                  "both). Decide between using a controlled or uncontrolled select " +
                  "element and remove one of these props. More info: " +
                  "https://fb.me/react-controlled-components"
              )
            : void 0;
          didWarnValueDefaultValue = true;
        }
      },
      getSelectValueContext: function(inst) {
        return inst._wrapperState.initialValue;
      },
      postUpdateWrapper: function(inst) {
        var props = inst._currentElement.props;
        inst._wrapperState.initialValue = undefined;
        var wasMultiple = inst._wrapperState.wasMultiple;
        inst._wrapperState.wasMultiple = Boolean(props.multiple);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          inst._wrapperState.pendingUpdate = false;
          updateOptions(inst, Boolean(props.multiple), value);
        } else if (wasMultiple !== Boolean(props.multiple)) {
          if (props.defaultValue != null) {
            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
          } else {
            updateOptions(
              inst,
              Boolean(props.multiple),
              props.multiple ? [] : ""
            );
          }
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      if (this._rootNodeID) {
        this._wrapperState.pendingUpdate = true;
      }
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMSelect;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var emptyComponentFactory;
    var ReactEmptyComponentInjection = {
      injectEmptyComponentFactory: function(factory) {
        emptyComponentFactory = factory;
      }
    };
    var ReactEmptyComponent = {
      create: function(instantiate) {
        return emptyComponentFactory(instantiate);
      }
    };
    ReactEmptyComponent.injection = ReactEmptyComponentInjection;
    module.exports = ReactEmptyComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactFeatureFlags = { logTopLevelRenders: false };
    module.exports = ReactFeatureFlags;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    var genericComponentClass = null;
    var textComponentClass = null;
    var ReactHostComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function(componentClass) {
        textComponentClass = componentClass;
      }
    };
    function createInternalComponent(element) {
      !genericComponentClass
        ? false
          ? invariant(
              false,
              "There is no registered component for the tag %s",
              element.type
            )
          : _prodInvariant("111", element.type)
        : void 0;
      return new genericComponentClass(element);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactHostComponent = {
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactHostComponentInjection
    };
    module.exports = ReactHostComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMSelection = __webpack_require__(191);
    var containsNode = __webpack_require__(152);
    var focusNode = __webpack_require__(71);
    var getActiveElement = __webpack_require__(72);
    function isInDocument(node) {
      return containsNode(document.documentElement, node);
    }
    var ReactInputSelection = {
      hasSelectionCapabilities: function(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return (
          nodeName &&
          ((nodeName === "input" && elem.type === "text") ||
            nodeName === "textarea" ||
            elem.contentEditable === "true")
        );
      },
      getSelectionInformation: function() {
        var focusedElem = getActiveElement();
        return {
          focusedElem: focusedElem,
          selectionRange: ReactInputSelection.hasSelectionCapabilities(
            focusedElem
          )
            ? ReactInputSelection.getSelection(focusedElem)
            : null
        };
      },
      restoreSelection: function(priorSelectionInformation) {
        var curFocusedElem = getActiveElement();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (
          curFocusedElem !== priorFocusedElem &&
          isInDocument(priorFocusedElem)
        ) {
          if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
            ReactInputSelection.setSelection(
              priorFocusedElem,
              priorSelectionRange
            );
          }
          focusNode(priorFocusedElem);
        }
      },
      getSelection: function(input) {
        var selection;
        if ("selectionStart" in input) {
          selection = { start: input.selectionStart, end: input.selectionEnd };
        } else if (
          document.selection &&
          input.nodeName &&
          input.nodeName.toLowerCase() === "input"
        ) {
          var range = document.selection.createRange();
          if (range.parentElement() === input) {
            selection = {
              start: -range.moveStart("character", -input.value.length),
              end: -range.moveEnd("character", -input.value.length)
            };
          }
        } else {
          selection = ReactDOMSelection.getOffsets(input);
        }
        return selection || { start: 0, end: 0 };
      },
      setSelection: function(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === undefined) {
          end = start;
        }
        if ("selectionStart" in input) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        } else if (
          document.selection &&
          input.nodeName &&
          input.nodeName.toLowerCase() === "input"
        ) {
          var range = input.createTextRange();
          range.collapse(true);
          range.moveStart("character", start);
          range.moveEnd("character", end - start);
          range.select();
        } else {
          ReactDOMSelection.setOffsets(input, offsets);
        }
      }
    };
    module.exports = ReactInputSelection;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var DOMLazyTree = __webpack_require__(18);
    var DOMProperty = __webpack_require__(19);
    var React = __webpack_require__(21);
    var ReactBrowserEventEmitter = __webpack_require__(32);
    var ReactCurrentOwner = __webpack_require__(13);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMContainerInfo = __webpack_require__(185);
    var ReactDOMFeatureFlags = __webpack_require__(187);
    var ReactFeatureFlags = __webpack_require__(81);
    var ReactInstanceMap = __webpack_require__(27);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactMarkupChecksum = __webpack_require__(201);
    var ReactReconciler = __webpack_require__(20);
    var ReactUpdateQueue = __webpack_require__(48);
    var ReactUpdates = __webpack_require__(11);
    var emptyObject = __webpack_require__(30);
    var instantiateReactComponent = __webpack_require__(92);
    var invariant = __webpack_require__(0);
    var setInnerHTML = __webpack_require__(36);
    var shouldUpdateReactComponent = __webpack_require__(54);
    var warning = __webpack_require__(4);
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var instancesByReactRootID = {};
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    function internalGetID(node) {
      return (node.getAttribute && node.getAttribute(ATTR_NAME)) || "";
    }
    function mountComponentIntoNode(
      wrapperInstance,
      container,
      transaction,
      shouldReuseMarkup,
      context
    ) {
      var markerName;
      if (ReactFeatureFlags.logTopLevelRenders) {
        var wrappedElement = wrapperInstance._currentElement.props.child;
        var type = wrappedElement.type;
        markerName =
          "React mount: " +
          (typeof type === "string" ? type : type.displayName || type.name);
        console.time(markerName);
      }
      var markup = ReactReconciler.mountComponent(
        wrapperInstance,
        transaction,
        null,
        ReactDOMContainerInfo(wrapperInstance, container),
        context,
        0
      );
      if (markerName) {
        console.timeEnd(markerName);
      }
      wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
      ReactMount._mountImageIntoNode(
        markup,
        container,
        wrapperInstance,
        shouldReuseMarkup,
        transaction
      );
    }
    function batchedMountComponentIntoNode(
      componentInstance,
      container,
      shouldReuseMarkup,
      context
    ) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
        !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement
      );
      transaction.perform(
        mountComponentIntoNode,
        null,
        componentInstance,
        container,
        transaction,
        shouldReuseMarkup,
        context
      );
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container, safely) {
      if (false) {
        ReactInstrumentation.debugTool.onBeginFlush();
      }
      ReactReconciler.unmountComponent(instance, safely);
      if (false) {
        ReactInstrumentation.debugTool.onEndFlush();
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        container = container.documentElement;
      }
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
    }
    function hasNonRootReactChild(container) {
      var rootEl = getReactRootElementInContainer(container);
      if (rootEl) {
        var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
        return !!(inst && inst._hostParent);
      }
    }
    function nodeIsRenderedByOtherInstance(container) {
      var rootEl = getReactRootElementInContainer(container);
      return !!(
        rootEl &&
        isReactNode(rootEl) &&
        !ReactDOMComponentTree.getInstanceFromNode(rootEl)
      );
    }
    function isValidContainer(node) {
      return !!(
        node &&
        (node.nodeType === ELEMENT_NODE_TYPE ||
          node.nodeType === DOC_NODE_TYPE ||
          node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)
      );
    }
    function isReactNode(node) {
      return (
        isValidContainer(node) &&
        (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME))
      );
    }
    function getHostRootInstanceInContainer(container) {
      var rootEl = getReactRootElementInContainer(container);
      var prevHostInstance =
        rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
      return prevHostInstance && !prevHostInstance._hostParent
        ? prevHostInstance
        : null;
    }
    function getTopLevelWrapperInContainer(container) {
      var root = getHostRootInstanceInContainer(container);
      return root ? root._hostContainerInfo._topLevelWrapper : null;
    }
    var topLevelRootCounter = 1;
    var TopLevelWrapper = function() {
      this.rootID = topLevelRootCounter++;
    };
    TopLevelWrapper.prototype.isReactComponent = {};
    if (false) {
      TopLevelWrapper.displayName = "TopLevelWrapper";
    }
    TopLevelWrapper.prototype.render = function() {
      return this.props.child;
    };
    TopLevelWrapper.isReactTopLevelWrapper = true;
    var ReactMount = {
      TopLevelWrapper: TopLevelWrapper,
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(
        prevComponent,
        nextElement,
        nextContext,
        container,
        callback
      ) {
        ReactMount.scrollMonitor(container, function() {
          ReactUpdateQueue.enqueueElementInternal(
            prevComponent,
            nextElement,
            nextContext
          );
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        return prevComponent;
      },
      _renderNewRootComponent: function(
        nextElement,
        container,
        shouldReuseMarkup,
        context
      ) {
        false
          ? warning(
              ReactCurrentOwner.current == null,
              "_renderNewRootComponent(): Render methods should be a pure function " +
                "of props and state; triggering nested component updates from " +
                "render is not allowed. If necessary, trigger nested updates in " +
                "componentDidUpdate. Check the render method of %s.",
              (ReactCurrentOwner.current &&
                ReactCurrentOwner.current.getName()) ||
                "ReactCompositeComponent"
            )
          : void 0;
        !isValidContainer(container)
          ? false
            ? invariant(
                false,
                "_registerComponent(...): Target container is not a DOM element."
              )
            : _prodInvariant("37")
          : void 0;
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var componentInstance = instantiateReactComponent(nextElement, false);
        ReactUpdates.batchedUpdates(
          batchedMountComponentIntoNode,
          componentInstance,
          container,
          shouldReuseMarkup,
          context
        );
        var wrapperID = componentInstance._instance.rootID;
        instancesByReactRootID[wrapperID] = componentInstance;
        return componentInstance;
      },
      renderSubtreeIntoContainer: function(
        parentComponent,
        nextElement,
        container,
        callback
      ) {
        !(parentComponent != null && ReactInstanceMap.has(parentComponent))
          ? false
            ? invariant(
                false,
                "parentComponent must be a valid React Component"
              )
            : _prodInvariant("38")
          : void 0;
        return ReactMount._renderSubtreeIntoContainer(
          parentComponent,
          nextElement,
          container,
          callback
        );
      },
      _renderSubtreeIntoContainer: function(
        parentComponent,
        nextElement,
        container,
        callback
      ) {
        ReactUpdateQueue.validateCallback(callback, "ReactDOM.render");
        !React.isValidElement(nextElement)
          ? false
            ? invariant(
                false,
                "ReactDOM.render(): Invalid component element.%s",
                typeof nextElement === "string"
                  ? " Instead of passing a string like 'div', pass " +
                      "React.createElement('div') or <div />."
                  : typeof nextElement === "function"
                  ? " Instead of passing a class like Foo, pass " +
                    "React.createElement(Foo) or <Foo />."
                  : nextElement != null && nextElement.props !== undefined
                  ? " This may be caused by unintentionally loading two independent " +
                    "copies of React."
                  : ""
              )
            : _prodInvariant(
                "39",
                typeof nextElement === "string"
                  ? " Instead of passing a string like 'div', pass " +
                      "React.createElement('div') or <div />."
                  : typeof nextElement === "function"
                  ? " Instead of passing a class like Foo, pass " +
                    "React.createElement(Foo) or <Foo />."
                  : nextElement != null && nextElement.props !== undefined
                  ? " This may be caused by unintentionally loading two independent " +
                    "copies of React."
                  : ""
              )
          : void 0;
        false
          ? warning(
              !container ||
                !container.tagName ||
                container.tagName.toUpperCase() !== "BODY",
              "render(): Rendering components directly into document.body is " +
                "discouraged, since its children are often manipulated by third-party " +
                "scripts and browser extensions. This may lead to subtle " +
                "reconciliation issues. Try rendering into a container element created " +
                "for your app."
            )
          : void 0;
        var nextWrappedElement = React.createElement(TopLevelWrapper, {
          child: nextElement
        });
        var nextContext;
        if (parentComponent) {
          var parentInst = ReactInstanceMap.get(parentComponent);
          nextContext = parentInst._processChildContext(parentInst._context);
        } else {
          nextContext = emptyObject;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (prevComponent) {
          var prevWrappedElement = prevComponent._currentElement;
          var prevElement = prevWrappedElement.props.child;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            var publicInst = prevComponent._renderedComponent.getPublicInstance();
            var updatedCallback =
              callback &&
              function() {
                callback.call(publicInst);
              };
            ReactMount._updateRootComponent(
              prevComponent,
              nextWrappedElement,
              nextContext,
              container,
              updatedCallback
            );
            return publicInst;
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup =
          reactRootElement && !!internalGetID(reactRootElement);
        var containerHasNonRootReactChild = hasNonRootReactChild(container);
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                !containerHasNonRootReactChild,
                "render(...): Replacing React-rendered children with a new root " +
                  "component. If you intended to update the children of this node, " +
                  "you should instead have the existing children update their state " +
                  "and render the new components instead of calling ReactDOM.render."
              )
            : void 0;
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (internalGetID(rootElementSibling)) {
                process.env.NODE_ENV !== "production"
                  ? warning(
                      false,
                      "render(): Target node has markup rendered by React, but there " +
                        "are unrelated nodes as well. This is most commonly caused by " +
                        "white-space inserted around server-rendered markup."
                    )
                  : void 0;
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup =
          containerHasReactMarkup &&
          !prevComponent &&
          !containerHasNonRootReactChild;
        var component = ReactMount._renderNewRootComponent(
          nextWrappedElement,
          container,
          shouldReuseMarkup,
          nextContext
        )._renderedComponent.getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      render: function(nextElement, container, callback) {
        return ReactMount._renderSubtreeIntoContainer(
          null,
          nextElement,
          container,
          callback
        );
      },
      unmountComponentAtNode: function(container) {
        false
          ? warning(
              ReactCurrentOwner.current == null,
              "unmountComponentAtNode(): Render methods should be a pure function " +
                "of props and state; triggering nested component updates from render " +
                "is not allowed. If necessary, trigger nested updates in " +
                "componentDidUpdate. Check the render method of %s.",
              (ReactCurrentOwner.current &&
                ReactCurrentOwner.current.getName()) ||
                "ReactCompositeComponent"
            )
          : void 0;
        !isValidContainer(container)
          ? false
            ? invariant(
                false,
                "unmountComponentAtNode(...): Target container is not a DOM element."
              )
            : _prodInvariant("40")
          : void 0;
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                !nodeIsRenderedByOtherInstance(container),
                "unmountComponentAtNode(): The node you're attempting to unmount " +
                  "was rendered by another copy of React."
              )
            : void 0;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (!prevComponent) {
          var containerHasNonRootReactChild = hasNonRootReactChild(container);
          var isContainerReactRoot =
            container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
          if (false) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  !containerHasNonRootReactChild,
                  "unmountComponentAtNode(): The node you're attempting to unmount " +
                    "was rendered by React and is not a top-level container. %s",
                  isContainerReactRoot
                    ? "You may have accidentally passed in a React root node instead " +
                        "of its container."
                    : "Instead, have the parent component update its state and " +
                        "rerender in order to remove this component."
                )
              : void 0;
          }
          return false;
        }
        delete instancesByReactRootID[prevComponent._instance.rootID];
        ReactUpdates.batchedUpdates(
          unmountComponentFromNode,
          prevComponent,
          container,
          false
        );
        return true;
      },
      _mountImageIntoNode: function(
        markup,
        container,
        instance,
        shouldReuseMarkup,
        transaction
      ) {
        !isValidContainer(container)
          ? false
            ? invariant(
                false,
                "mountComponentIntoNode(...): Target container is not valid."
              )
            : _prodInvariant("41")
          : void 0;
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            ReactDOMComponentTree.precacheNode(instance, rootElement);
            return;
          } else {
            var checksum = rootElement.getAttribute(
              ReactMarkupChecksum.CHECKSUM_ATTR_NAME
            );
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(
              ReactMarkupChecksum.CHECKSUM_ATTR_NAME,
              checksum
            );
            var normalizedMarkup = markup;
            if (false) {
              var normalizer;
              if (container.nodeType === ELEMENT_NODE_TYPE) {
                normalizer = document.createElement("div");
                normalizer.innerHTML = markup;
                normalizedMarkup = normalizer.innerHTML;
              } else {
                normalizer = document.createElement("iframe");
                document.body.appendChild(normalizer);
                normalizer.contentDocument.write(markup);
                normalizedMarkup =
                  normalizer.contentDocument.documentElement.outerHTML;
                document.body.removeChild(normalizer);
              }
            }
            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
            var difference =
              " (client) " +
              normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) +
              "\n (server) " +
              rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            !(container.nodeType !== DOC_NODE_TYPE)
              ? false
                ? invariant(
                    false,
                    "You're trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s",
                    difference
                  )
                : _prodInvariant("42", difference)
              : void 0;
            if (false) {
              process.env.NODE_ENV !== "production"
                ? warning(
                    false,
                    "React attempted to reuse markup in a container but the " +
                      "checksum was invalid. This generally means that you are " +
                      "using server rendering and the markup generated on the " +
                      "server was not what the client was expecting. React injected " +
                      "new markup to compensate which works but you have lost many " +
                      "of the benefits of server rendering. Instead, figure out " +
                      "why the markup being generated is different on the client " +
                      "or server:\n%s",
                    difference
                  )
                : void 0;
            }
          }
        }
        !(container.nodeType !== DOC_NODE_TYPE)
          ? false
            ? invariant(
                false,
                "You're trying to render a component to the document but you didn't use server rendering. We can't do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering."
              )
            : _prodInvariant("43")
          : void 0;
        if (transaction.useCreateElement) {
          while (container.lastChild) {
            container.removeChild(container.lastChild);
          }
          DOMLazyTree.insertTreeBefore(container, markup, null);
        } else {
          setInnerHTML(container, markup);
          ReactDOMComponentTree.precacheNode(instance, container.firstChild);
        }
        if (false) {
          var hostNode = ReactDOMComponentTree.getInstanceFromNode(
            container.firstChild
          );
          if (hostNode._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: hostNode._debugID,
              type: "mount",
              payload: markup.toString()
            });
          }
        }
      }
    };
    module.exports = ReactMount;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var React = __webpack_require__(21);
    var invariant = __webpack_require__(0);
    var ReactNodeTypes = {
      HOST: 0,
      COMPOSITE: 1,
      EMPTY: 2,
      getType: function(node) {
        if (node === null || node === false) {
          return ReactNodeTypes.EMPTY;
        } else if (React.isValidElement(node)) {
          if (typeof node.type === "function") {
            return ReactNodeTypes.COMPOSITE;
          } else {
            return ReactNodeTypes.HOST;
          }
        }
        true
          ? false
            ? invariant(false, "Unexpected node: %s", node)
            : _prodInvariant("26", node)
          : void 0;
      }
    };
    module.exports = ReactNodeTypes;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ViewportMetrics = {
      currentScrollLeft: 0,
      currentScrollTop: 0,
      refreshScrollValues: function(scrollPosition) {
        ViewportMetrics.currentScrollLeft = scrollPosition.x;
        ViewportMetrics.currentScrollTop = scrollPosition.y;
      }
    };
    module.exports = ViewportMetrics;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    function accumulateInto(current, next) {
      !(next != null)
        ? false
          ? invariant(
              false,
              "accumulateInto(...): Accumulated items must not be null or undefined."
            )
          : _prodInvariant("30")
        : void 0;
      if (current == null) {
        return next;
      }
      if (Array.isArray(current)) {
        if (Array.isArray(next)) {
          current.push.apply(current, next);
          return current;
        }
        current.push(next);
        return current;
      }
      if (Array.isArray(next)) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function forEachAccumulated(arr, cb, scope) {
      if (Array.isArray(arr)) {
        arr.forEach(cb, scope);
      } else if (arr) {
        cb.call(scope, arr);
      }
    }
    module.exports = forEachAccumulated;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactNodeTypes = __webpack_require__(85);
    function getHostComponentFromComposite(inst) {
      var type;
      while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
        inst = inst._renderedComponent;
      }
      if (type === ReactNodeTypes.HOST) {
        return inst._renderedComponent;
      } else if (type === ReactNodeTypes.EMPTY) {
        return null;
      }
    }
    module.exports = getHostComponentFromComposite;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var contentKey = null;
    function getTextContentAccessor() {
      if (!contentKey && ExecutionEnvironment.canUseDOM) {
        contentKey =
          "textContent" in document.documentElement
            ? "textContent"
            : "innerText";
      }
      return contentKey;
    }
    module.exports = getTextContentAccessor;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMComponentTree = __webpack_require__(7);
    function isCheckable(elem) {
      var type = elem.type;
      var nodeName = elem.nodeName;
      return (
        nodeName &&
        nodeName.toLowerCase() === "input" &&
        (type === "checkbox" || type === "radio")
      );
    }
    function getTracker(inst) {
      return inst._wrapperState.valueTracker;
    }
    function attachTracker(inst, tracker) {
      inst._wrapperState.valueTracker = tracker;
    }
    function detachTracker(inst) {
      inst._wrapperState.valueTracker = null;
    }
    function getValueFromNode(node) {
      var value;
      if (node) {
        value = isCheckable(node) ? "" + node.checked : node.value;
      }
      return value;
    }
    var inputValueTracking = {
      _getTrackerFromNode: function(node) {
        return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
      },
      track: function(inst) {
        if (getTracker(inst)) {
          return;
        }
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var valueField = isCheckable(node) ? "checked" : "value";
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        var currentValue = "" + node[valueField];
        if (
          node.hasOwnProperty(valueField) ||
          typeof descriptor.get !== "function" ||
          typeof descriptor.set !== "function"
        ) {
          return;
        }
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable,
          configurable: true,
          get: function() {
            return descriptor.get.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            descriptor.set.call(this, value);
          }
        });
        attachTracker(inst, {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            detachTracker(inst);
            delete node[valueField];
          }
        });
      },
      updateValueIfChanged: function(inst) {
        if (!inst) {
          return false;
        }
        var tracker = getTracker(inst);
        if (!tracker) {
          inputValueTracking.track(inst);
          return true;
        }
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(
          ReactDOMComponentTree.getNodeFromInstance(inst)
        );
        if (nextValue !== lastValue) {
          tracker.setValue(nextValue);
          return true;
        }
        return false;
      },
      stopTracking: function(inst) {
        var tracker = getTracker(inst);
        if (tracker) {
          tracker.stopTracking();
        }
      }
    };
    module.exports = inputValueTracking;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var ReactCompositeComponent = __webpack_require__(182);
    var ReactEmptyComponent = __webpack_require__(80);
    var ReactHostComponent = __webpack_require__(82);
    var getNextDebugID = __webpack_require__(246);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    var ReactCompositeComponentWrapper = function(element) {
      this.construct(element);
    };
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return " Check the render method of `" + name + "`.";
        }
      }
      return "";
    }
    function isInternalComponentType(type) {
      return (
        typeof type === "function" &&
        typeof type.prototype !== "undefined" &&
        typeof type.prototype.mountComponent === "function" &&
        typeof type.prototype.receiveComponent === "function"
      );
    }
    function instantiateReactComponent(node, shouldHaveDebugID) {
      var instance;
      if (node === null || node === false) {
        instance = ReactEmptyComponent.create(instantiateReactComponent);
      } else if (typeof node === "object") {
        var element = node;
        var type = element.type;
        if (typeof type !== "function" && typeof type !== "string") {
          var info = "";
          if (false) {
            if (
              type === undefined ||
              (typeof type === "object" &&
                type !== null &&
                Object.keys(type).length === 0)
            ) {
              info +=
                " You likely forgot to export your component from the file " +
                "it's defined in.";
            }
          }
          info += getDeclarationErrorAddendum(element._owner);
          true
            ? false
              ? invariant(
                  false,
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
                  type == null ? type : typeof type,
                  info
                )
              : _prodInvariant("130", type == null ? type : typeof type, info)
            : void 0;
        }
        if (typeof element.type === "string") {
          instance = ReactHostComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
          if (!instance.getHostNode) {
            instance.getHostNode = instance.getNativeNode;
          }
        } else {
          instance = new ReactCompositeComponentWrapper(element);
        }
      } else if (typeof node === "string" || typeof node === "number") {
        instance = ReactHostComponent.createInstanceForText(node);
      } else {
        true
          ? false
            ? invariant(
                false,
                "Encountered invalid React node of type %s",
                typeof node
              )
            : _prodInvariant("131", typeof node)
          : void 0;
      }
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(
              typeof instance.mountComponent === "function" &&
                typeof instance.receiveComponent === "function" &&
                typeof instance.getHostNode === "function" &&
                typeof instance.unmountComponent === "function",
              "Only React Components can be mounted."
            )
          : void 0;
      }
      instance._mountIndex = 0;
      instance._mountImage = null;
      if (false) {
        instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
      }
      if (false) {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
      _instantiateReactComponent: instantiateReactComponent
    });
    module.exports = instantiateReactComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      if (nodeName === "input") {
        return !!supportedInputTypes[elem.type];
      }
      if (nodeName === "textarea") {
        return true;
      }
      return false;
    }
    module.exports = isTextInputElement;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var escapeTextContentForBrowser = __webpack_require__(35);
    var setInnerHTML = __webpack_require__(36);
    var setTextContent = function(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          firstChild.nodeType === 3
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    };
    if (ExecutionEnvironment.canUseDOM) {
      if (!("textContent" in document.documentElement)) {
        setTextContent = function(node, text) {
          if (node.nodeType === 3) {
            node.nodeValue = text;
            return;
          }
          setInnerHTML(node, escapeTextContentForBrowser(text));
        };
      }
    }
    module.exports = setTextContent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactCurrentOwner = __webpack_require__(13);
    var REACT_ELEMENT_TYPE = __webpack_require__(197);
    var getIteratorFn = __webpack_require__(228);
    var invariant = __webpack_require__(0);
    var KeyEscapeUtils = __webpack_require__(44);
    var warning = __webpack_require__(4);
    var SEPARATOR = ".";
    var SUBSEPARATOR = ":";
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === "object" && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(
      children,
      nameSoFar,
      callback,
      traverseContext
    ) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean") {
        children = null;
      }
      if (
        children === null ||
        type === "string" ||
        type === "number" ||
        (type === "object" && children.$$typeof === REACT_ELEMENT_TYPE)
      ) {
        callback(
          traverseContext,
          children,
          nameSoFar === ""
            ? SEPARATOR + getComponentKey(children, 0)
            : nameSoFar
        );
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix =
        nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(
            child,
            nextName,
            callback,
            traverseContext
          );
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(
                child,
                nextName,
                callback,
                traverseContext
              );
            }
          } else {
            if (false) {
              var mapsAsChildrenAddendum = "";
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum =
                    " Check the render method of `" +
                    mapsAsChildrenOwnerName +
                    "`.";
                }
              }
              process.env.NODE_ENV !== "production"
                ? warning(
                    didWarnAboutMaps,
                    "Using Maps as children is not yet fully supported. It is an " +
                      "experimental feature that might be removed. Convert it to a " +
                      "sequence / iterable of keyed ReactElements instead.%s",
                    mapsAsChildrenAddendum
                  )
                : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName =
                  nextNamePrefix +
                  KeyEscapeUtils.escape(entry[0]) +
                  SUBSEPARATOR +
                  getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(
                  child,
                  nextName,
                  callback,
                  traverseContext
                );
              }
            }
          }
        } else if (type === "object") {
          var addendum = "";
          if (false) {
            addendum =
              " If you meant to render a collection of children, use an array " +
              "instead or wrap the object using createFragment(object) from the " +
              "React add-ons.";
            if (children._isReactElement) {
              addendum =
                " It looks like you're using an element created by a different " +
                "version of React. Make sure to use only one copy of React.";
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += " Check the render method of `" + name + "`.";
              }
            }
          }
          var childrenString = String(children);
          true
            ? false
              ? invariant(
                  false,
                  "Objects are not valid as a React child (found: %s).%s",
                  childrenString === "[object Object]"
                    ? "object with keys {" +
                        Object.keys(children).join(", ") +
                        "}"
                    : childrenString,
                  addendum
                )
              : _prodInvariant(
                  "31",
                  childrenString === "[object Object]"
                    ? "object with keys {" +
                        Object.keys(children).join(", ") +
                        "}"
                    : childrenString,
                  addendum
                )
            : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, "", callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
    __webpack_require__.d(__webpack_exports__, "polyfill", function() {
      return polyfill;
    });
    function componentWillMount() {
      var state = this.constructor.getDerivedStateFromProps(
        this.props,
        this.state
      );
      if (state !== null && state !== undefined) {
        this.setState(state);
      }
    }
    function componentWillReceiveProps(nextProps) {
      function updater(prevState) {
        var state = this.constructor.getDerivedStateFromProps(
          nextProps,
          prevState
        );
        return state !== null && state !== undefined ? state : null;
      }
      this.setState(updater.bind(this));
    }
    function componentWillUpdate(nextProps, nextState) {
      try {
        var prevProps = this.props;
        var prevState = this.state;
        this.props = nextProps;
        this.state = nextState;
        this.__reactInternalSnapshotFlag = true;
        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
          prevProps,
          prevState
        );
      } finally {
        this.props = prevProps;
        this.state = prevState;
      }
    }
    componentWillMount.__suppressDeprecationWarning = true;
    componentWillReceiveProps.__suppressDeprecationWarning = true;
    componentWillUpdate.__suppressDeprecationWarning = true;
    function polyfill(Component) {
      var prototype = Component.prototype;
      if (!prototype || !prototype.isReactComponent) {
        throw new Error("Can only polyfill class components");
      }
      if (
        typeof Component.getDerivedStateFromProps !== "function" &&
        typeof prototype.getSnapshotBeforeUpdate !== "function"
      ) {
        return Component;
      }
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;
      if (typeof prototype.componentWillMount === "function") {
        foundWillMountName = "componentWillMount";
      } else if (typeof prototype.UNSAFE_componentWillMount === "function") {
        foundWillMountName = "UNSAFE_componentWillMount";
      }
      if (typeof prototype.componentWillReceiveProps === "function") {
        foundWillReceivePropsName = "componentWillReceiveProps";
      } else if (
        typeof prototype.UNSAFE_componentWillReceiveProps === "function"
      ) {
        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
      }
      if (typeof prototype.componentWillUpdate === "function") {
        foundWillUpdateName = "componentWillUpdate";
      } else if (typeof prototype.UNSAFE_componentWillUpdate === "function") {
        foundWillUpdateName = "UNSAFE_componentWillUpdate";
      }
      if (
        foundWillMountName !== null ||
        foundWillReceivePropsName !== null ||
        foundWillUpdateName !== null
      ) {
        var componentName = Component.displayName || Component.name;
        var newApiName =
          typeof Component.getDerivedStateFromProps === "function"
            ? "getDerivedStateFromProps()"
            : "getSnapshotBeforeUpdate()";
        throw Error(
          "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
            componentName +
            " uses " +
            newApiName +
            " but also contains the following legacy lifecycles:" +
            (foundWillMountName !== null ? "\n  " + foundWillMountName : "") +
            (foundWillReceivePropsName !== null
              ? "\n  " + foundWillReceivePropsName
              : "") +
            (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") +
            "\n\nThe above lifecycles should be removed. Learn more about this warning here:\n" +
            "https://fb.me/react-async-component-lifecycle-hooks"
        );
      }
      if (typeof Component.getDerivedStateFromProps === "function") {
        prototype.componentWillMount = componentWillMount;
        prototype.componentWillReceiveProps = componentWillReceiveProps;
      }
      if (typeof prototype.getSnapshotBeforeUpdate === "function") {
        if (typeof prototype.componentDidUpdate !== "function") {
          throw new Error(
            "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
          );
        }
        prototype.componentWillUpdate = componentWillUpdate;
        var componentDidUpdate = prototype.componentDidUpdate;
        prototype.componentDidUpdate = function componentDidUpdatePolyfill(
          prevProps,
          prevState,
          maybeSnapshot
        ) {
          var snapshot = this.__reactInternalSnapshotFlag
            ? this.__reactInternalSnapshot
            : maybeSnapshot;
          componentDidUpdate.call(this, prevProps, prevState, snapshot);
        };
      }
      return Component;
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;
    var PropTypes = _interopRequireWildcard(__webpack_require__(2));
    var _react = _interopRequireDefault(__webpack_require__(1));
    var _reactDom = _interopRequireDefault(__webpack_require__(31));
    var _reactLifecyclesCompat = __webpack_require__(96);
    var _PropTypes = __webpack_require__(99);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var UNMOUNTED = "unmounted";
    exports.UNMOUNTED = UNMOUNTED;
    var EXITED = "exited";
    exports.EXITED = EXITED;
    var ENTERING = "entering";
    exports.ENTERING = ENTERING;
    var ENTERED = "entered";
    exports.ENTERED = ENTERED;
    var EXITING = "exiting";
    exports.EXITING = EXITING;
    var Transition = (function(_React$Component) {
      _inheritsLoose(Transition, _React$Component);
      function Transition(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context.transitionGroup;
        var appear =
          parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = { status: initialStatus };
        _this.nextCallback = null;
        return _this;
      }
      var _proto = Transition.prototype;
      _proto.getChildContext = function getChildContext() {
        return { transitionGroup: null };
      };
      Transition.getDerivedStateFromProps = function getDerivedStateFromProps(
        _ref,
        prevState
      ) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return { status: EXITED };
        }
        return null;
      };
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;
        if (timeout != null && typeof timeout !== "number") {
          exit = timeout.exit;
          enter = timeout.enter;
          appear = timeout.appear;
        }
        return { exit: exit, enter: enter, appear: appear };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          var node = _reactDom.default.findDOMNode(this);
          if (nextStatus === ENTERING) {
            this.performEnter(node, mounting);
          } else {
            this.performExit(node);
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({ status: UNMOUNTED });
        }
      };
      _proto.performEnter = function performEnter(node, mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context.transitionGroup
          ? this.context.transitionGroup.isMounting
          : mounting;
        var timeouts = this.getTimeouts();
        if (!mounting && !enter) {
          this.safeSetState({ status: ENTERED }, function() {
            _this2.props.onEntered(node);
          });
          return;
        }
        this.props.onEnter(node, appearing);
        this.safeSetState({ status: ENTERING }, function() {
          _this2.props.onEntering(node, appearing);
          _this2.onTransitionEnd(node, timeouts.enter, function() {
            _this2.safeSetState({ status: ENTERED }, function() {
              _this2.props.onEntered(node, appearing);
            });
          });
        });
      };
      _proto.performExit = function performExit(node) {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        if (!exit) {
          this.safeSetState({ status: EXITED }, function() {
            _this3.props.onExited(node);
          });
          return;
        }
        this.props.onExit(node);
        this.safeSetState({ status: EXITING }, function() {
          _this3.props.onExiting(node);
          _this3.onTransitionEnd(node, timeouts.exit, function() {
            _this3.safeSetState({ status: EXITED }, function() {
              _this3.props.onExited(node);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(
        node,
        timeout,
        handler
      ) {
        this.setNextCallback(handler);
        if (node) {
          if (this.props.addEndListener) {
            this.props.addEndListener(node, this.nextCallback);
          }
          if (timeout != null) {
            setTimeout(this.nextCallback, timeout);
          }
        } else {
          setTimeout(this.nextCallback, 0);
        }
      };
      _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props,
          children = _this$props.children,
          childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]);
        delete childProps.in;
        delete childProps.mountOnEnter;
        delete childProps.unmountOnExit;
        delete childProps.appear;
        delete childProps.enter;
        delete childProps.exit;
        delete childProps.timeout;
        delete childProps.addEndListener;
        delete childProps.onEnter;
        delete childProps.onEntering;
        delete childProps.onEntered;
        delete childProps.onExit;
        delete childProps.onExiting;
        delete childProps.onExited;
        if (typeof children === "function") {
          return children(status, childProps);
        }
        var child = _react.default.Children.only(children);
        return _react.default.cloneElement(child, childProps);
      };
      return Transition;
    })(_react.default.Component);
    Transition.contextTypes = { transitionGroup: PropTypes.object };
    Transition.childContextTypes = {
      transitionGroup: function transitionGroup() {}
    };
    Transition.propTypes = false
      ? {
          children: PropTypes.oneOfType([
            PropTypes.func.isRequired,
            PropTypes.element.isRequired
          ]).isRequired,
          in: PropTypes.bool,
          mountOnEnter: PropTypes.bool,
          unmountOnExit: PropTypes.bool,
          appear: PropTypes.bool,
          enter: PropTypes.bool,
          exit: PropTypes.bool,
          timeout: function timeout(props) {
            var pt =
              process.env.NODE_ENV !== "production"
                ? _PropTypes.timeoutsShape
                : {};
            if (!props.addEndListener) pt = pt.isRequired;
            for (
              var _len = arguments.length,
                args = new Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key];
            }
            return pt.apply(void 0, [props].concat(args));
          },
          addEndListener: PropTypes.func,
          onEnter: PropTypes.func,
          onEntering: PropTypes.func,
          onEntered: PropTypes.func,
          onExit: PropTypes.func,
          onExiting: PropTypes.func,
          onExited: PropTypes.func
        }
      : {};
    function noop() {}
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop,
      onEntering: noop,
      onEntered: noop,
      onExit: noop,
      onExiting: noop,
      onExited: noop
    };
    Transition.UNMOUNTED = 0;
    Transition.EXITED = 1;
    Transition.ENTERING = 2;
    Transition.ENTERED = 3;
    Transition.EXITING = 4;
    var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);
    exports.default = _default;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _propTypes = _interopRequireDefault(__webpack_require__(2));
    var _react = _interopRequireDefault(__webpack_require__(1));
    var _reactLifecyclesCompat = __webpack_require__(96);
    var _ChildMapping = __webpack_require__(237);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _extends() {
      _extends =
        Object.assign ||
        function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return self;
    }
    var values =
      Object.values ||
      function(obj) {
        return Object.keys(obj).map(function(k) {
          return obj[k];
        });
      };
    var propTypes = false
      ? {
          component: _propTypes.default.any,
          children: _propTypes.default.node,
          appear: _propTypes.default.bool,
          enter: _propTypes.default.bool,
          exit: _propTypes.default.bool,
          childFactory: _propTypes.default.func
        }
      : {};
    var defaultProps = {
      component: "div",
      childFactory: function childFactory(child) {
        return child;
      }
    };
    var TransitionGroup = (function(_React$Component) {
      _inheritsLoose(TransitionGroup, _React$Component);
      function TransitionGroup(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(
          _assertThisInitialized(_assertThisInitialized(_this))
        );
        _this.state = { handleExited: handleExited, firstRender: true };
        return _this;
      }
      var _proto = TransitionGroup.prototype;
      _proto.getChildContext = function getChildContext() {
        return { transitionGroup: { isMounting: !this.appeared } };
      };
      _proto.componentDidMount = function componentDidMount() {
        this.appeared = true;
        this.mounted = true;
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };
      TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(
        nextProps,
        _ref
      ) {
        var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
        return {
          children: firstRender
            ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited)
            : (0, _ChildMapping.getNextChildMapping)(
                nextProps,
                prevChildMapping,
                handleExited
              ),
          firstRender: false
        };
      };
      _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = (0, _ChildMapping.getChildMapping)(
          this.props.children
        );
        if (child.key in currentChildMapping) return;
        if (child.props.onExited) {
          child.props.onExited(node);
        }
        if (this.mounted) {
          this.setState(function(state) {
            var children = _extends({}, state.children);
            delete children[child.key];
            return { children: children };
          });
        }
      };
      _proto.render = function render() {
        var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose(_this$props, [
            "component",
            "childFactory"
          ]);
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
          return children;
        }
        return _react.default.createElement(Component, props, children);
      };
      return TransitionGroup;
    })(_react.default.Component);
    TransitionGroup.childContextTypes = {
      transitionGroup: _propTypes.default.object.isRequired
    };
    TransitionGroup.propTypes = false ? propTypes : {};
    TransitionGroup.defaultProps = defaultProps;
    var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);
    exports.default = _default;
    module.exports = exports["default"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.transitionTimeout = transitionTimeout;
    exports.classNamesShape = exports.timeoutsShape = void 0;
    var _propTypes = _interopRequireDefault(__webpack_require__(2));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function transitionTimeout(transitionType) {
      var timeoutPropName = "transition" + transitionType + "Timeout";
      var enabledPropName = "transition" + transitionType;
      return function(props) {
        if (props[enabledPropName]) {
          if (props[timeoutPropName] == null) {
            return new Error(
              timeoutPropName +
                " wasn't supplied to CSSTransitionGroup: " +
                "this can cause unreliable animations and won't be supported in " +
                "a future version of React. See " +
                "https://fb.me/react-animation-transition-group-timeout for more " +
                "information."
            );
          } else if (typeof props[timeoutPropName] !== "number") {
            return new Error(
              timeoutPropName + " must be a number (in milliseconds)"
            );
          }
        }
        return null;
      };
    }
    var timeoutsShape = _propTypes.default.oneOfType([
      _propTypes.default.number,
      _propTypes.default.shape({
        enter: _propTypes.default.number,
        exit: _propTypes.default.number
      }).isRequired
    ]);
    exports.timeoutsShape = timeoutsShape;
    var classNamesShape = _propTypes.default.oneOfType([
      _propTypes.default.string,
      _propTypes.default.shape({
        enter: _propTypes.default.string,
        exit: _propTypes.default.string,
        active: _propTypes.default.string
      }),
      _propTypes.default.shape({
        enter: _propTypes.default.string,
        enterDone: _propTypes.default.string,
        enterActive: _propTypes.default.string,
        exit: _propTypes.default.string,
        exitDone: _propTypes.default.string,
        exitActive: _propTypes.default.string
      })
    ]);
    exports.classNamesShape = classNamesShape;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(29),
      _assign = __webpack_require__(6);
    var ReactNoopUpdateQueue = __webpack_require__(103);
    var canDefineProperty = __webpack_require__(104);
    var emptyObject = __webpack_require__(30);
    var invariant = __webpack_require__(0);
    var lowPriorityWarning = __webpack_require__(247);
    function ReactComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.isReactComponent = {};
    ReactComponent.prototype.setState = function(partialState, callback) {
      !(
        typeof partialState === "object" ||
        typeof partialState === "function" ||
        partialState == null
      )
        ? false
          ? invariant(
              false,
              "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
            )
          : _prodInvariant("85")
        : void 0;
      this.updater.enqueueSetState(this, partialState);
      if (callback) {
        this.updater.enqueueCallback(this, callback, "setState");
      }
    };
    ReactComponent.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this);
      if (callback) {
        this.updater.enqueueCallback(this, callback, "forceUpdate");
      }
    };
    if (false) {
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in " +
            "componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see " +
            "https://github.com/facebook/react/issues/3236)."
        ]
      };
      var defineDeprecationWarning = function(methodName, info) {
        if (canDefineProperty) {
          Object.defineProperty(ReactComponent.prototype, methodName, {
            get: function() {
              lowPriorityWarning(
                false,
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
              return undefined;
            }
          });
        }
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    function ReactPureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    ComponentDummy.prototype = ReactComponent.prototype;
    ReactPureComponent.prototype = new ComponentDummy();
    ReactPureComponent.prototype.constructor = ReactPureComponent;
    _assign(ReactPureComponent.prototype, ReactComponent.prototype);
    ReactPureComponent.prototype.isPureReactComponent = true;
    module.exports = {
      Component: ReactComponent,
      PureComponent: ReactPureComponent
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(29);
    var ReactCurrentOwner = __webpack_require__(13);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    function isNative(fn) {
      var funcToString = Function.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var reIsNative = RegExp(
        "^" +
          funcToString
            .call(hasOwnProperty)
            .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              "$1.*?"
            ) +
          "$"
      );
      try {
        var source = funcToString.call(fn);
        return reIsNative.test(source);
      } catch (err) {
        return false;
      }
    }
    var canUseCollections =
      typeof Array.from === "function" &&
      typeof Map === "function" &&
      isNative(Map) &&
      Map.prototype != null &&
      typeof Map.prototype.keys === "function" &&
      isNative(Map.prototype.keys) &&
      typeof Set === "function" &&
      isNative(Set) &&
      Set.prototype != null &&
      typeof Set.prototype.keys === "function" &&
      isNative(Set.prototype.keys);
    var setItem;
    var getItem;
    var removeItem;
    var getItemIDs;
    var addRoot;
    var removeRoot;
    var getRootIDs;
    if (canUseCollections) {
      var itemMap = new Map();
      var rootIDSet = new Set();
      setItem = function(id, item) {
        itemMap.set(id, item);
      };
      getItem = function(id) {
        return itemMap.get(id);
      };
      removeItem = function(id) {
        itemMap["delete"](id);
      };
      getItemIDs = function() {
        return Array.from(itemMap.keys());
      };
      addRoot = function(id) {
        rootIDSet.add(id);
      };
      removeRoot = function(id) {
        rootIDSet["delete"](id);
      };
      getRootIDs = function() {
        return Array.from(rootIDSet.keys());
      };
    } else {
      var itemByKey = {};
      var rootByKey = {};
      var getKeyFromID = function(id) {
        return "." + id;
      };
      var getIDFromKey = function(key) {
        return parseInt(key.substr(1), 10);
      };
      setItem = function(id, item) {
        var key = getKeyFromID(id);
        itemByKey[key] = item;
      };
      getItem = function(id) {
        var key = getKeyFromID(id);
        return itemByKey[key];
      };
      removeItem = function(id) {
        var key = getKeyFromID(id);
        delete itemByKey[key];
      };
      getItemIDs = function() {
        return Object.keys(itemByKey).map(getIDFromKey);
      };
      addRoot = function(id) {
        var key = getKeyFromID(id);
        rootByKey[key] = true;
      };
      removeRoot = function(id) {
        var key = getKeyFromID(id);
        delete rootByKey[key];
      };
      getRootIDs = function() {
        return Object.keys(rootByKey).map(getIDFromKey);
      };
    }
    var unmountedIDs = [];
    function purgeDeep(id) {
      var item = getItem(id);
      if (item) {
        var childIDs = item.childIDs;
        removeItem(id);
        childIDs.forEach(purgeDeep);
      }
    }
    function describeComponentFrame(name, source, ownerName) {
      return (
        "\n    in " +
        (name || "Unknown") +
        (source
          ? " (at " +
            source.fileName.replace(/^.*[\\\/]/, "") +
            ":" +
            source.lineNumber +
            ")"
          : ownerName
          ? " (created by " + ownerName + ")"
          : "")
      );
    }
    function getDisplayName(element) {
      if (element == null) {
        return "#empty";
      } else if (typeof element === "string" || typeof element === "number") {
        return "#text";
      } else if (typeof element.type === "string") {
        return element.type;
      } else {
        return element.type.displayName || element.type.name || "Unknown";
      }
    }
    function describeID(id) {
      var name = ReactComponentTreeHook.getDisplayName(id);
      var element = ReactComponentTreeHook.getElement(id);
      var ownerID = ReactComponentTreeHook.getOwnerID(id);
      var ownerName;
      if (ownerID) {
        ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
      }
      false
        ? warning(
            element,
            "ReactComponentTreeHook: Missing React element for debugID %s when " +
              "building stack",
            id
          )
        : void 0;
      return describeComponentFrame(
        name,
        element && element._source,
        ownerName
      );
    }
    var ReactComponentTreeHook = {
      onSetChildren: function(id, nextChildIDs) {
        var item = getItem(id);
        !item
          ? false
            ? invariant(false, "Item must have been set")
            : _prodInvariant("144")
          : void 0;
        item.childIDs = nextChildIDs;
        for (var i = 0; i < nextChildIDs.length; i++) {
          var nextChildID = nextChildIDs[i];
          var nextChild = getItem(nextChildID);
          !nextChild
            ? false
              ? invariant(
                  false,
                  "Expected hook events to fire for the child before its parent includes it in onSetChildren()."
                )
              : _prodInvariant("140")
            : void 0;
          !(
            nextChild.childIDs != null ||
            typeof nextChild.element !== "object" ||
            nextChild.element == null
          )
            ? false
              ? invariant(
                  false,
                  "Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren()."
                )
              : _prodInvariant("141")
            : void 0;
          !nextChild.isMounted
            ? false
              ? invariant(
                  false,
                  "Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren()."
                )
              : _prodInvariant("71")
            : void 0;
          if (nextChild.parentID == null) {
            nextChild.parentID = id;
          }
          !(nextChild.parentID === id)
            ? false
              ? invariant(
                  false,
                  "Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).",
                  nextChildID,
                  nextChild.parentID,
                  id
                )
              : _prodInvariant("142", nextChildID, nextChild.parentID, id)
            : void 0;
        }
      },
      onBeforeMountComponent: function(id, element, parentID) {
        var item = {
          element: element,
          parentID: parentID,
          text: null,
          childIDs: [],
          isMounted: false,
          updateCount: 0
        };
        setItem(id, item);
      },
      onBeforeUpdateComponent: function(id, element) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.element = element;
      },
      onMountComponent: function(id) {
        var item = getItem(id);
        !item
          ? false
            ? invariant(false, "Item must have been set")
            : _prodInvariant("144")
          : void 0;
        item.isMounted = true;
        var isRoot = item.parentID === 0;
        if (isRoot) {
          addRoot(id);
        }
      },
      onUpdateComponent: function(id) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.updateCount++;
      },
      onUnmountComponent: function(id) {
        var item = getItem(id);
        if (item) {
          item.isMounted = false;
          var isRoot = item.parentID === 0;
          if (isRoot) {
            removeRoot(id);
          }
        }
        unmountedIDs.push(id);
      },
      purgeUnmountedComponents: function() {
        if (ReactComponentTreeHook._preventPurging) {
          return;
        }
        for (var i = 0; i < unmountedIDs.length; i++) {
          var id = unmountedIDs[i];
          purgeDeep(id);
        }
        unmountedIDs.length = 0;
      },
      isMounted: function(id) {
        var item = getItem(id);
        return item ? item.isMounted : false;
      },
      getCurrentStackAddendum: function(topElement) {
        var info = "";
        if (topElement) {
          var name = getDisplayName(topElement);
          var owner = topElement._owner;
          info += describeComponentFrame(
            name,
            topElement._source,
            owner && owner.getName()
          );
        }
        var currentOwner = ReactCurrentOwner.current;
        var id = currentOwner && currentOwner._debugID;
        info += ReactComponentTreeHook.getStackAddendumByID(id);
        return info;
      },
      getStackAddendumByID: function(id) {
        var info = "";
        while (id) {
          info += describeID(id);
          id = ReactComponentTreeHook.getParentID(id);
        }
        return info;
      },
      getChildIDs: function(id) {
        var item = getItem(id);
        return item ? item.childIDs : [];
      },
      getDisplayName: function(id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element) {
          return null;
        }
        return getDisplayName(element);
      },
      getElement: function(id) {
        var item = getItem(id);
        return item ? item.element : null;
      },
      getOwnerID: function(id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element || !element._owner) {
          return null;
        }
        return element._owner._debugID;
      },
      getParentID: function(id) {
        var item = getItem(id);
        return item ? item.parentID : null;
      },
      getSource: function(id) {
        var item = getItem(id);
        var element = item ? item.element : null;
        var source = element != null ? element._source : null;
        return source;
      },
      getText: function(id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (typeof element === "string") {
          return element;
        } else if (typeof element === "number") {
          return "" + element;
        } else {
          return null;
        }
      },
      getUpdateCount: function(id) {
        var item = getItem(id);
        return item ? item.updateCount : 0;
      },
      getRootIDs: getRootIDs,
      getRegisteredIDs: getItemIDs,
      pushNonStandardWarningStack: function(isCreatingElement, currentSource) {
        if (typeof console.reactStack !== "function") {
          return;
        }
        var stack = [];
        var currentOwner = ReactCurrentOwner.current;
        var id = currentOwner && currentOwner._debugID;
        try {
          if (isCreatingElement) {
            stack.push({
              name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
              fileName: currentSource ? currentSource.fileName : null,
              lineNumber: currentSource ? currentSource.lineNumber : null
            });
          }
          while (id) {
            var element = ReactComponentTreeHook.getElement(id);
            var parentID = ReactComponentTreeHook.getParentID(id);
            var ownerID = ReactComponentTreeHook.getOwnerID(id);
            var ownerName = ownerID
              ? ReactComponentTreeHook.getDisplayName(ownerID)
              : null;
            var source = element && element._source;
            stack.push({
              name: ownerName,
              fileName: source ? source.fileName : null,
              lineNumber: source ? source.lineNumber : null
            });
            id = parentID;
          }
        } catch (err) {}
        console.reactStack(stack);
      },
      popNonStandardWarningStack: function() {
        if (typeof console.reactStackEnd !== "function") {
          return;
        }
        console.reactStackEnd();
      }
    };
    module.exports = ReactComponentTreeHook;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var REACT_ELEMENT_TYPE =
      (typeof Symbol === "function" &&
        Symbol["for"] &&
        Symbol["for"]("react.element")) ||
      0xeac7;
    module.exports = REACT_ELEMENT_TYPE;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var warning = __webpack_require__(4);
    function warnNoop(publicInstance, callerName) {
      if (false) {
        var constructor = publicInstance.constructor;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "%s(...): Can only update a mounted or mounting component. " +
                "This usually means you called %s() on an unmounted component. " +
                "This is a no-op. Please check the code for the %s component.",
              callerName,
              callerName,
              (constructor && (constructor.displayName || constructor.name)) ||
                "ReactClass"
            )
          : void 0;
      }
    }
    var ReactNoopUpdateQueue = {
      isMounted: function(publicInstance) {
        return false;
      },
      enqueueCallback: function(publicInstance, callback) {},
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance, partialState) {
        warnNoop(publicInstance, "setState");
      }
    };
    module.exports = ReactNoopUpdateQueue;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var canDefineProperty = false;
    if (false) {
      try {
        Object.defineProperty({}, "x", { get: function() {} });
        canDefineProperty = true;
      } catch (x) {}
    }
    module.exports = canDefineProperty;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _reactDom = __webpack_require__(31);
    var _reactDom2 = _interopRequireDefault(_reactDom);
    var _Main = __webpack_require__(111);
    var _Main2 = _interopRequireDefault(_Main);
    var _cameras = __webpack_require__(131);
    var _utils = __webpack_require__(15);
    var _entity = __webpack_require__(14);
    var _GLTFExporter = __webpack_require__(136);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __webpack_require__(137);
    var Events = __webpack_require__(5);
    var Viewport = __webpack_require__(135);
    var AssetsLoader = __webpack_require__(129);
    var Shortcuts = __webpack_require__(134);
    __webpack_require__(252);
    function Inspector() {
      var _this = this;
      this.assetsLoader = new AssetsLoader();
      this.exporters = { gltf: new THREE.GLTFExporter() };
      this.history = __webpack_require__(132);
      this.isFirstOpen = true;
      this.modules = {};
      this.on = Events.on;
      this.opened = false;
      var doInit = function doInit() {
        if (!AFRAME.scenes.length) {
          setTimeout(function() {
            doInit();
          }, 100);
          return;
        }
        _this.sceneEl = AFRAME.scenes[0];
        if (_this.sceneEl.hasLoaded) {
          _this.init();
          return;
        }
        _this.sceneEl.addEventListener("loaded", _this.init.bind(_this), {
          once: true
        });
      };
      doInit();
    }
    Inspector.prototype = {
      init: function init() {
        var _this2 = this;
        if (!this.sceneEl.camera) {
          this.sceneEl.addEventListener(
            "camera-set-active",
            function() {
              _this2.init();
            },
            { once: true }
          );
          return;
        }
        this.container = document.querySelector(".a-canvas");
        (0, _cameras.initCameras)(this);
        this.initUI();
      },
      initUI: function initUI() {
        var _this3 = this;
        Shortcuts.init(this);
        this.initEvents();
        this.selected = null;
        var div = document.createElement("div");
        div.id = "aframeInspector";
        div.setAttribute("data-aframe-inspector", "app");
        document.body.appendChild(div);
        _reactDom2.default.render(
          _react2.default.createElement(_Main2.default, null),
          div
        );
        this.scene = this.sceneEl.object3D;
        this.helpers = {};
        this.sceneHelpers = new THREE.Scene();
        this.sceneHelpers.userData.source = "INSPECTOR";
        this.sceneHelpers.visible = true;
        this.inspectorActive = false;
        this.viewport = new Viewport(this);
        Events.emit("windowresize");
        this.sceneEl.object3D.traverse(function(node) {
          _this3.addHelper(node);
        });
        this.scene.add(this.sceneHelpers);
        this.open();
      },
      removeObject: function removeObject(object) {
        this.removeHelpers(object);
        Events.emit("objectremove", object);
      },
      addHelper: (function() {
        var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
        var material = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          visible: false
        });
        return function(object) {
          var helper = void 0;
          if (object instanceof THREE.Camera) {
            this.cameraHelper = helper = new THREE.CameraHelper(object, 0.1);
          } else if (object instanceof THREE.PointLight) {
            helper = new THREE.PointLightHelper(object, 1);
          } else if (object instanceof THREE.DirectionalLight) {
            helper = new THREE.DirectionalLightHelper(object, 1);
          } else if (object instanceof THREE.SpotLight) {
            helper = new THREE.SpotLightHelper(object, 1);
          } else if (object instanceof THREE.HemisphereLight) {
            helper = new THREE.HemisphereLightHelper(object, 1);
          } else if (object instanceof THREE.SkinnedMesh) {
            helper = new THREE.SkeletonHelper(object);
          } else {
            return;
          }
          helper.visible = false;
          this.sceneHelpers.add(helper);
          this.helpers[object.uuid] = helper;
          helper.update();
        };
      })(),
      removeHelpers: function removeHelpers(object) {
        var _this4 = this;
        object.traverse(function(node) {
          var helper = _this4.helpers[node.uuid];
          if (helper) {
            _this4.sceneHelpers.remove(helper);
            delete _this4.helpers[node.uuid];
            Events.emit("helperremove", _this4.helpers[node.uuid]);
          }
        });
      },
      selectEntity: function selectEntity(entity, emit) {
        var _this5 = this;
        this.selectedEntity = entity;
        if (entity) {
          this.select(entity.object3D);
        } else {
          this.select(null);
        }
        if (entity && emit === undefined) {
          Events.emit("entityselect", entity);
        }
        for (var id in this.helpers) {
          this.helpers[id].visible = false;
        }
        if (entity === this.sceneEl) {
          return;
        }
        entity.object3D.traverse(function(node) {
          if (_this5.helpers[node.uuid]) {
            _this5.helpers[node.uuid].visible = true;
          }
        });
      },
      initEvents: function initEvents() {
        var _this6 = this;
        window.addEventListener("keydown", function(evt) {
          var shortcutPressed = evt.keyCode === 73 && evt.ctrlKey && evt.altKey;
          if (shortcutPressed) {
            _this6.toggle();
          }
        });
        Events.on("entityselect", function(entity) {
          _this6.selectEntity(entity, false);
        });
        Events.on("inspectortoggle", function(active) {
          _this6.inspectorActive = active;
          _this6.sceneHelpers.visible = _this6.inspectorActive;
        });
        Events.on("entitycreate", function(definition) {
          (0, _entity.createEntity)(definition, function(entity) {
            _this6.selectEntity(entity);
          });
        });
        document.addEventListener("child-detached", function(event) {
          var entity = event.detail.el;
          AFRAME.INSPECTOR.removeObject(entity.object3D);
        });
      },
      selectById: function selectById(id) {
        if (id === this.camera.id) {
          this.select(this.camera);
          return;
        }
        this.select(this.scene.getObjectById(id, true));
      },
      select: function select(object3D) {
        if (this.selected === object3D) {
          return;
        }
        this.selected = object3D;
        Events.emit("objectselect", object3D);
      },
      deselect: function deselect() {
        this.select(null);
      },
      toggle: function toggle() {
        if (this.opened) {
          this.close();
        } else {
          this.open();
        }
      },
      open: function open(focusEl) {
        this.opened = true;
        Events.emit("inspectortoggle", true);
        if (this.sceneEl.hasAttribute("embedded")) {
          this.sceneEl.removeAttribute("embedded");
          this.sceneEl.setAttribute("aframe-inspector-removed-embedded");
        }
        document.body.classList.add("aframe-inspector-opened");
        this.sceneEl.resize();
        this.sceneEl.pause();
        this.sceneEl.exitVR();
        Shortcuts.enable();
        this.sceneEl.isPlaying = true;
        this.cursor.play();
        if (
          !focusEl &&
          this.isFirstOpen &&
          AFRAME.utils.getUrlParameter("inspector")
        ) {
          focusEl = document.getElementById(
            AFRAME.utils.getUrlParameter("inspector")
          );
        }
        if (focusEl) {
          this.selectEntity(focusEl);
          Events.emit("objectfocus", focusEl.object3D);
        }
        this.isFirstOpen = false;
      },
      close: function close() {
        this.opened = false;
        Events.emit("inspectortoggle", false);
        this.sceneEl.isPlaying = false;
        this.sceneEl.play();
        this.cursor.pause();
        if (this.sceneEl.hasAttribute("aframe-inspector-removed-embedded")) {
          this.sceneEl.setAttribute("embedded", "");
          this.sceneEl.removeAttribute("aframe-inspector-removed-embedded");
        }
        document.body.classList.remove("aframe-inspector-opened");
        this.sceneEl.resize();
        Shortcuts.disable();
      }
    };
    var inspector = (AFRAME.INSPECTOR = new Inspector());
  },
  function(module, exports) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = _interopRequireDefault;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function murmurhash2_32_gc(str) {
      var l = str.length,
        h = l ^ l,
        i = 0,
        k;
      while (l >= 4) {
        k =
          (str.charCodeAt(i) & 0xff) |
          ((str.charCodeAt(++i) & 0xff) << 8) |
          ((str.charCodeAt(++i) & 0xff) << 16) |
          ((str.charCodeAt(++i) & 0xff) << 24);
        k =
          (k & 0xffff) * 0x5bd1e995 +
          ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);
        k ^= k >>> 24;
        k =
          (k & 0xffff) * 0x5bd1e995 +
          ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);
        h =
          ((h & 0xffff) * 0x5bd1e995 +
            ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^
          k;
        l -= 4;
        ++i;
      }
      switch (l) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
          h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
          h ^= str.charCodeAt(i) & 0xff;
          h =
            (h & 0xffff) * 0x5bd1e995 +
            ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);
      }
      h ^= h >>> 13;
      h =
        (h & 0xffff) * 0x5bd1e995 +
        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);
      h ^= h >>> 15;
      return (h >>> 0).toString(36);
    }
    __webpack_exports__["a"] = murmurhash2_32_gc;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function memoize(fn) {
      var cache = {};
      return function(arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
      };
    }
    __webpack_exports__["a"] = memoize;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function stylis_min(W) {
      function M(d, c, e, h, a) {
        for (
          var m = 0,
            b = 0,
            v = 0,
            n = 0,
            q,
            g,
            x = 0,
            K = 0,
            k,
            u = (k = q = 0),
            l = 0,
            r = 0,
            I = 0,
            t = 0,
            B = e.length,
            J = B - 1,
            y,
            f = "",
            p = "",
            F = "",
            G = "",
            C;
          l < B;

        ) {
          g = e.charCodeAt(l);
          l === J &&
            0 !== b + n + v + m &&
            (0 !== b && (g = 47 === b ? 10 : 47), (n = v = m = 0), B++, J++);
          if (0 === b + n + v + m) {
            if (
              l === J &&
              (0 < r && (f = f.replace(N, "")), 0 < f.trim().length)
            ) {
              switch (g) {
                case 32:
                case 9:
                case 59:
                case 13:
                case 10:
                  break;
                default:
                  f += e.charAt(l);
              }
              g = 59;
            }
            switch (g) {
              case 123:
                f = f.trim();
                q = f.charCodeAt(0);
                k = 1;
                for (t = ++l; l < B; ) {
                  switch ((g = e.charCodeAt(l))) {
                    case 123:
                      k++;
                      break;
                    case 125:
                      k--;
                      break;
                    case 47:
                      switch ((g = e.charCodeAt(l + 1))) {
                        case 42:
                        case 47:
                          a: {
                            for (u = l + 1; u < J; ++u) {
                              switch (e.charCodeAt(u)) {
                                case 47:
                                  if (
                                    42 === g &&
                                    42 === e.charCodeAt(u - 1) &&
                                    l + 2 !== u
                                  ) {
                                    l = u + 1;
                                    break a;
                                  }
                                  break;
                                case 10:
                                  if (47 === g) {
                                    l = u + 1;
                                    break a;
                                  }
                              }
                            }
                            l = u;
                          }
                      }
                      break;
                    case 91:
                      g++;
                    case 40:
                      g++;
                    case 34:
                    case 39:
                      for (; l++ < J && e.charCodeAt(l) !== g; ) {}
                  }
                  if (0 === k) break;
                  l++;
                }
                k = e.substring(t, l);
                0 === q && (q = (f = f.replace(ca, "").trim()).charCodeAt(0));
                switch (q) {
                  case 64:
                    0 < r && (f = f.replace(N, ""));
                    g = f.charCodeAt(1);
                    switch (g) {
                      case 100:
                      case 109:
                      case 115:
                      case 45:
                        r = c;
                        break;
                      default:
                        r = O;
                    }
                    k = M(c, r, k, g, a + 1);
                    t = k.length;
                    0 < A &&
                      ((r = X(O, f, I)),
                      (C = H(3, k, r, c, D, z, t, g, a, h)),
                      (f = r.join("")),
                      void 0 !== C &&
                        0 === (t = (k = C.trim()).length) &&
                        ((g = 0), (k = "")));
                    if (0 < t)
                      switch (g) {
                        case 115:
                          f = f.replace(da, ea);
                        case 100:
                        case 109:
                        case 45:
                          k = f + "{" + k + "}";
                          break;
                        case 107:
                          f = f.replace(fa, "$1 $2");
                          k = f + "{" + k + "}";
                          k =
                            1 === w || (2 === w && L("@" + k, 3))
                              ? "@-webkit-" + k + "@" + k
                              : "@" + k;
                          break;
                        default:
                          (k = f + k), 112 === h && (k = ((p += k), ""));
                      }
                    else k = "";
                    break;
                  default:
                    k = M(c, X(c, f, I), k, h, a + 1);
                }
                F += k;
                k = I = r = u = q = 0;
                f = "";
                g = e.charCodeAt(++l);
                break;
              case 125:
              case 59:
                f = (0 < r ? f.replace(N, "") : f).trim();
                if (1 < (t = f.length))
                  switch (
                    (0 === u &&
                      ((q = f.charCodeAt(0)),
                      45 === q || (96 < q && 123 > q)) &&
                      (t = (f = f.replace(" ", ":")).length),
                    0 < A &&
                      void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) &&
                      0 === (t = (f = C.trim()).length) &&
                      (f = "\x00\x00"),
                    (q = f.charCodeAt(0)),
                    (g = f.charCodeAt(1)),
                    q)
                  ) {
                    case 0:
                      break;
                    case 64:
                      if (105 === g || 99 === g) {
                        G += f + e.charAt(l);
                        break;
                      }
                    default:
                      58 !== f.charCodeAt(t - 1) &&
                        (p += P(f, q, g, f.charCodeAt(2)));
                  }
                I = r = u = q = 0;
                f = "";
                g = e.charCodeAt(++l);
            }
          }
          switch (g) {
            case 13:
            case 10:
              47 === b
                ? (b = 0)
                : 0 === 1 + q &&
                  107 !== h &&
                  0 < f.length &&
                  ((r = 1), (f += "\x00"));
              0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
              z = 1;
              D++;
              break;
            case 59:
            case 125:
              if (0 === b + n + v + m) {
                z++;
                break;
              }
            default:
              z++;
              y = e.charAt(l);
              switch (g) {
                case 9:
                case 32:
                  if (0 === n + m + b)
                    switch (x) {
                      case 44:
                      case 58:
                      case 9:
                      case 32:
                        y = "";
                        break;
                      default:
                        32 !== g && (y = " ");
                    }
                  break;
                case 0:
                  y = "\\0";
                  break;
                case 12:
                  y = "\\f";
                  break;
                case 11:
                  y = "\\v";
                  break;
                case 38:
                  0 === n + b + m && ((r = I = 1), (y = "\f" + y));
                  break;
                case 108:
                  if (0 === n + b + m + E && 0 < u)
                    switch (l - u) {
                      case 2:
                        112 === x && 58 === e.charCodeAt(l - 3) && (E = x);
                      case 8:
                        111 === K && (E = K);
                    }
                  break;
                case 58:
                  0 === n + b + m && (u = l);
                  break;
                case 44:
                  0 === b + v + n + m && ((r = 1), (y += "\r"));
                  break;
                case 34:
                case 39:
                  0 === b && (n = n === g ? 0 : 0 === n ? g : n);
                  break;
                case 91:
                  0 === n + b + v && m++;
                  break;
                case 93:
                  0 === n + b + v && m--;
                  break;
                case 41:
                  0 === n + b + m && v--;
                  break;
                case 40:
                  if (0 === n + b + m) {
                    if (0 === q)
                      switch (2 * x + 3 * K) {
                        case 533:
                          break;
                        default:
                          q = 1;
                      }
                    v++;
                  }
                  break;
                case 64:
                  0 === b + v + n + m + u + k && (k = 1);
                  break;
                case 42:
                case 47:
                  if (!(0 < n + m + v))
                    switch (b) {
                      case 0:
                        switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                          case 235:
                            b = 47;
                            break;
                          case 220:
                            (t = l), (b = 42);
                        }
                        break;
                      case 42:
                        47 === g &&
                          42 === x &&
                          t + 2 !== l &&
                          (33 === e.charCodeAt(t + 2) &&
                            (p += e.substring(t, l + 1)),
                          (y = ""),
                          (b = 0));
                    }
              }
              0 === b && (f += y);
          }
          K = x;
          x = g;
          l++;
        }
        t = p.length;
        if (0 < t) {
          r = c;
          if (
            0 < A &&
            ((C = H(2, p, r, d, D, z, t, h, a, h)),
            void 0 !== C && 0 === (p = C).length)
          )
            return G + p + F;
          p = r.join(",") + "{" + p + "}";
          if (0 !== w * E) {
            2 !== w || L(p, 2) || (E = 0);
            switch (E) {
              case 111:
                p = p.replace(ha, ":-moz-$1") + p;
                break;
              case 112:
                p =
                  p.replace(Q, "::-webkit-input-$1") +
                  p.replace(Q, "::-moz-$1") +
                  p.replace(Q, ":-ms-input-$1") +
                  p;
            }
            E = 0;
          }
        }
        return G + p + F;
      }
      function X(d, c, e) {
        var h = c.trim().split(ia);
        c = h;
        var a = h.length,
          m = d.length;
        switch (m) {
          case 0:
          case 1:
            var b = 0;
            for (d = 0 === m ? "" : d[0] + " "; b < a; ++b) {
              c[b] = Z(d, c[b], e, m).trim();
            }
            break;
          default:
            var v = (b = 0);
            for (c = []; b < a; ++b) {
              for (var n = 0; n < m; ++n) {
                c[v++] = Z(d[n] + " ", h[b], e, m).trim();
              }
            }
        }
        return c;
      }
      function Z(d, c, e) {
        var h = c.charCodeAt(0);
        33 > h && (h = (c = c.trim()).charCodeAt(0));
        switch (h) {
          case 38:
            return c.replace(F, "$1" + d.trim());
          case 58:
            return d.trim() + c.replace(F, "$1" + d.trim());
          default:
            if (0 < 1 * e && 0 < c.indexOf("\f"))
              return c.replace(
                F,
                (58 === d.charCodeAt(0) ? "" : "$1") + d.trim()
              );
        }
        return d + c;
      }
      function P(d, c, e, h) {
        var a = d + ";",
          m = 2 * c + 3 * e + 4 * h;
        if (944 === m) {
          d = a.indexOf(":", 9) + 1;
          var b = a.substring(d, a.length - 1).trim();
          b = a.substring(0, d).trim() + b + ";";
          return 1 === w || (2 === w && L(b, 1)) ? "-webkit-" + b + b : b;
        }
        if (0 === w || (2 === w && !L(a, 1))) return a;
        switch (m) {
          case 1015:
            return 97 === a.charCodeAt(10) ? "-webkit-" + a + a : a;
          case 951:
            return 116 === a.charCodeAt(3) ? "-webkit-" + a + a : a;
          case 963:
            return 110 === a.charCodeAt(5) ? "-webkit-" + a + a : a;
          case 1009:
            if (100 !== a.charCodeAt(4)) break;
          case 969:
          case 942:
            return "-webkit-" + a + a;
          case 978:
            return "-webkit-" + a + "-moz-" + a + a;
          case 1019:
          case 983:
            return "-webkit-" + a + "-moz-" + a + "-ms-" + a + a;
          case 883:
            if (45 === a.charCodeAt(8)) return "-webkit-" + a + a;
            if (0 < a.indexOf("image-set(", 11))
              return a.replace(ja, "$1-webkit-$2") + a;
            break;
          case 932:
            if (45 === a.charCodeAt(4))
              switch (a.charCodeAt(5)) {
                case 103:
                  return (
                    "-webkit-box-" +
                    a.replace("-grow", "") +
                    "-webkit-" +
                    a +
                    "-ms-" +
                    a.replace("grow", "positive") +
                    a
                  );
                case 115:
                  return (
                    "-webkit-" +
                    a +
                    "-ms-" +
                    a.replace("shrink", "negative") +
                    a
                  );
                case 98:
                  return (
                    "-webkit-" +
                    a +
                    "-ms-" +
                    a.replace("basis", "preferred-size") +
                    a
                  );
              }
            return "-webkit-" + a + "-ms-" + a + a;
          case 964:
            return "-webkit-" + a + "-ms-flex-" + a + a;
          case 1023:
            if (99 !== a.charCodeAt(8)) break;
            b = a
              .substring(a.indexOf(":", 15))
              .replace("flex-", "")
              .replace("space-between", "justify");
            return (
              "-webkit-box-pack" + b + "-webkit-" + a + "-ms-flex-pack" + b + a
            );
          case 1005:
            return ka.test(a)
              ? a.replace(aa, ":-webkit-") + a.replace(aa, ":-moz-") + a
              : a;
          case 1e3:
            b = a.substring(13).trim();
            c = b.indexOf("-") + 1;
            switch (b.charCodeAt(0) + b.charCodeAt(c)) {
              case 226:
                b = a.replace(G, "tb");
                break;
              case 232:
                b = a.replace(G, "tb-rl");
                break;
              case 220:
                b = a.replace(G, "lr");
                break;
              default:
                return a;
            }
            return "-webkit-" + a + "-ms-" + b + a;
          case 1017:
            if (-1 === a.indexOf("sticky", 9)) break;
          case 975:
            c = (a = d).length - 10;
            b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a)
              .substring(d.indexOf(":", 7) + 1)
              .trim();
            switch ((m = b.charCodeAt(0) + (b.charCodeAt(7) | 0))) {
              case 203:
                if (111 > b.charCodeAt(8)) break;
              case 115:
                a = a.replace(b, "-webkit-" + b) + ";" + a;
                break;
              case 207:
              case 102:
                a =
                  a.replace(
                    b,
                    "-webkit-" + (102 < m ? "inline-" : "") + "box"
                  ) +
                  ";" +
                  a.replace(b, "-webkit-" + b) +
                  ";" +
                  a.replace(b, "-ms-" + b + "box") +
                  ";" +
                  a;
            }
            return a + ";";
          case 938:
            if (45 === a.charCodeAt(5))
              switch (a.charCodeAt(6)) {
                case 105:
                  return (
                    (b = a.replace("-items", "")),
                    "-webkit-" + a + "-webkit-box-" + b + "-ms-flex-" + b + a
                  );
                case 115:
                  return (
                    "-webkit-" + a + "-ms-flex-item-" + a.replace(ba, "") + a
                  );
                default:
                  return (
                    "-webkit-" +
                    a +
                    "-ms-flex-line-pack" +
                    a.replace("align-content", "").replace(ba, "") +
                    a
                  );
              }
            break;
          case 973:
          case 989:
            if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;
          case 931:
          case 953:
            if (!0 === la.test(d))
              return 115 === (b = d.substring(d.indexOf(":") + 1)).charCodeAt(0)
                ? P(d.replace("stretch", "fill-available"), c, e, h).replace(
                    ":fill-available",
                    ":stretch"
                  )
                : a.replace(b, "-webkit-" + b) +
                    a.replace(b, "-moz-" + b.replace("fill-", "")) +
                    a;
            break;
          case 962:
            if (
              ((a =
                "-webkit-" +
                a +
                (102 === a.charCodeAt(5) ? "-ms-" + a : "") +
                a),
              211 === e + h &&
                105 === a.charCodeAt(13) &&
                0 < a.indexOf("transform", 10))
            )
              return (
                a
                  .substring(0, a.indexOf(";", 27) + 1)
                  .replace(ma, "$1-webkit-$2") + a
              );
        }
        return a;
      }
      function L(d, c) {
        var e = d.indexOf(1 === c ? ":" : "{"),
          h = d.substring(0, 3 !== c ? e : 10);
        e = d.substring(e + 1, d.length - 1);
        return R(2 !== c ? h : h.replace(na, "$1"), e, c);
      }
      function ea(d, c) {
        var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
        return e !== c + ";"
          ? e.replace(oa, " or ($1)").substring(4)
          : "(" + c + ")";
      }
      function H(d, c, e, h, a, m, b, v, n, q) {
        for (var g = 0, x = c, w; g < A; ++g) {
          switch ((w = S[g].call(B, d, x, e, h, a, m, b, v, n, q))) {
            case void 0:
            case !1:
            case !0:
            case null:
              break;
            default:
              x = w;
          }
        }
        if (x !== c) return x;
      }
      function T(d) {
        switch (d) {
          case void 0:
          case null:
            A = S.length = 0;
            break;
          default:
            switch (d.constructor) {
              case Array:
                for (var c = 0, e = d.length; c < e; ++c) {
                  T(d[c]);
                }
                break;
              case Function:
                S[A++] = d;
                break;
              case Boolean:
                Y = !!d | 0;
            }
        }
        return T;
      }
      function U(d) {
        d = d.prefix;
        void 0 !== d &&
          ((R = null),
          d
            ? "function" !== typeof d
              ? (w = 1)
              : ((w = 2), (R = d))
            : (w = 0));
        return U;
      }
      function B(d, c) {
        var e = d;
        33 > e.charCodeAt(0) && (e = e.trim());
        V = e;
        e = [V];
        if (0 < A) {
          var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
          void 0 !== h && "string" === typeof h && (c = h);
        }
        var a = M(O, e, c, 0, 0);
        0 < A &&
          ((h = H(-2, a, e, e, D, z, a.length, 0, 0, 0)),
          void 0 !== h && (a = h));
        V = "";
        E = 0;
        z = D = 1;
        return a;
      }
      var ca = /^\0+/g,
        N = /[\0\r\f]/g,
        aa = /: */g,
        ka = /zoo|gra/,
        ma = /([,: ])(transform)/g,
        ia = /,\r+?/g,
        F = /([\t\r\n ])*\f?&/g,
        fa = /@(k\w+)\s*(\S*)\s*/,
        Q = /::(place)/g,
        ha = /:(read-only)/g,
        G = /[svh]\w+-[tblr]{2}/,
        da = /\(\s*(.*)\s*\)/g,
        oa = /([\s\S]*?);/g,
        ba = /-self|flex-/g,
        na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
        la = /stretch|:\s*\w+\-(?:conte|avail)/,
        ja = /([^-])(image-set\()/,
        z = 1,
        D = 1,
        E = 0,
        w = 1,
        O = [],
        S = [],
        A = 0,
        R = null,
        Y = 0,
        V = "";
      B.use = T;
      B.set = U;
      void 0 !== W && U(W);
      return B;
    }
    __webpack_exports__["a"] = stylis_min;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    __webpack_exports__["a"] = unitlessKeys;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _Sidebar = __webpack_require__(117);
    var _Sidebar2 = _interopRequireDefault(_Sidebar);
    var _ModalTextures = __webpack_require__(119);
    var _ModalTextures2 = _interopRequireDefault(_ModalTextures);
    var _ModalHelp = __webpack_require__(118);
    var _ModalHelp2 = _interopRequireDefault(_ModalHelp);
    var _SceneGraph = __webpack_require__(121);
    var _SceneGraph2 = _interopRequireDefault(_SceneGraph);
    var _CameraToolbar = __webpack_require__(123);
    var _CameraToolbar2 = _interopRequireDefault(_CameraToolbar);
    var _TransformToolBar = __webpack_require__(124);
    var _TransformToolBar2 = _interopRequireDefault(_TransformToolBar);
    var _ViewportHUD = __webpack_require__(125);
    var _ViewportHUD2 = _interopRequireDefault(_ViewportHUD);
    var _utils = __webpack_require__(15);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    THREE.ImageUtils.crossOrigin = "";
    var Events = __webpack_require__(5);
    (0, _utils.injectCSS)(
      "https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"
    );
    var Main = (function(_React$Component) {
      _inherits(Main, _React$Component);
      function Main(props) {
        _classCallCheck(this, Main);
        var _this = _possibleConstructorReturn(
          this,
          (Main.__proto__ || Object.getPrototypeOf(Main)).call(this, props)
        );
        _this.onCloseHelpModal = function(value) {
          _this.setState({ isHelpOpen: false });
        };
        _this.onModalTextureOnClose = function(value) {
          _this.setState({ isModalTexturesOpen: false });
          if (_this.state.textureOnClose) {
            _this.state.textureOnClose(value);
          }
        };
        _this.toggleEdit = function() {
          if (_this.state.inspectorEnabled) {
            AFRAME.INSPECTOR.close();
          } else {
            AFRAME.INSPECTOR.open();
          }
        };
        _this.state = {
          entity: null,
          inspectorEnabled: true,
          isModalTexturesOpen: false,
          sceneEl: AFRAME.scenes[0],
          visible: { scenegraph: true, attributes: true }
        };
        Events.on("togglesidebar", function(event) {
          if (event.which === "all") {
            if (
              _this.state.visible.scenegraph ||
              _this.state.visible.attributes
            ) {
              _this.setState({
                visible: { scenegraph: false, attributes: false }
              });
            } else {
              _this.setState({
                visible: { scenegraph: true, attributes: true }
              });
            }
          } else if (event.which === "attributes") {
            _this.setState(function(prevState) {
              return { visible: { attributes: !prevState.visible.attributes } };
            });
          } else if (event.which === "scenegraph") {
            _this.setState(function(prevState) {
              return { visible: { scenegraph: !prevState.visible.scenegraph } };
            });
          }
          _this.forceUpdate();
        });
        return _this;
      }
      _createClass(Main, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            Events.on(
              "opentexturesmodal",
              function(selectedTexture, textureOnClose) {
                this.setState({
                  selectedTexture: selectedTexture,
                  isModalTexturesOpen: true,
                  textureOnClose: textureOnClose
                });
              }.bind(this)
            );
            Events.on("entityselect", function(entity) {
              _this2.setState({ entity: entity });
            });
            Events.on("inspectortoggle", function(enabled) {
              _this2.setState({ inspectorEnabled: enabled });
            });
            Events.on("openhelpmodal", function() {
              _this2.setState({ isHelpOpen: true });
            });
          }
        },
        {
          key: "renderComponentsToggle",
          value: function renderComponentsToggle() {
            var _this3 = this;
            if (!this.state.entity || this.state.visible.attributes) {
              return null;
            }
            return _react2.default.createElement(
              "div",
              { className: "toggle-sidebar right" },
              _react2.default.createElement("a", {
                onClick: function onClick() {
                  _this3.setState({ visible: { attributes: true } });
                  _this3.forceUpdate();
                },
                className: "fa fa-plus",
                title: "Show components"
              })
            );
          }
        },
        {
          key: "renderSceneGraphToggle",
          value: function renderSceneGraphToggle() {
            var _this4 = this;
            if (this.state.visible.scenegraph) {
              return null;
            }
            return _react2.default.createElement(
              "div",
              { className: "toggle-sidebar left" },
              _react2.default.createElement("a", {
                onClick: function onClick() {
                  _this4.setState({ visible: { scenegraph: true } });
                  _this4.forceUpdate();
                },
                className: "fa fa-plus",
                title: "Show scenegraph"
              })
            );
          }
        },
        {
          key: "render",
          value: function render() {
            var scene = this.state.sceneEl;
            var toggleButtonText = this.state.inspectorEnabled
              ? "Back to Scene"
              : "Inspect Scene";
            return _react2.default.createElement(
              "div",
              null,
              _react2.default.createElement(
                "a",
                { className: "toggle-edit", onClick: this.toggleEdit },
                toggleButtonText
              ),
              this.renderSceneGraphToggle(),
              this.renderComponentsToggle(),
              _react2.default.createElement(
                "div",
                {
                  id: "inspectorContainer",
                  className: this.state.inspectorEnabled ? "" : "hidden"
                },
                _react2.default.createElement(_SceneGraph2.default, {
                  scene: scene,
                  selectedEntity: this.state.entity,
                  visible: this.state.visible.scenegraph
                }),
                _react2.default.createElement(
                  "div",
                  { id: "viewportBar" },
                  _react2.default.createElement(_CameraToolbar2.default, null),
                  _react2.default.createElement(_ViewportHUD2.default, null),
                  _react2.default.createElement(
                    _TransformToolBar2.default,
                    null
                  )
                ),
                _react2.default.createElement(
                  "div",
                  { id: "rightPanel" },
                  _react2.default.createElement(_Sidebar2.default, {
                    entity: this.state.entity,
                    visible: this.state.visible.attributes
                  })
                )
              ),
              _react2.default.createElement(_ModalHelp2.default, {
                isOpen: this.state.isHelpOpen,
                onClose: this.onCloseHelpModal
              }),
              _react2.default.createElement(_ModalTextures2.default, {
                ref: "modaltextures",
                isOpen: this.state.isModalTexturesOpen,
                selectedTexture: this.state.selectedTexture,
                onClose: this.onModalTextureOnClose
              })
            );
          }
        }
      ]);
      return Main;
    })(_react2.default.Component);
    exports.default = Main;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    var _reactSelect = __webpack_require__(37);
    var _reactSelect2 = _interopRequireDefault(_reactSelect);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var DELIMITER = " ";
    var AddComponent = (function(_React$Component) {
      _inherits(AddComponent, _React$Component);
      function AddComponent() {
        var _ref;
        var _temp, _this, _ret;
        _classCallCheck(this, AddComponent);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = _possibleConstructorReturn(
                this,
                (_ref =
                  AddComponent.__proto__ ||
                  Object.getPrototypeOf(AddComponent)).call.apply(
                  _ref,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.addComponent = function(value) {
              var componentName = value.value;
              var entity = _this.props.entity;
              var packageName;
              var selectedOption = _this.options.filter(function(option) {
                return option.value === componentName;
              })[0];
              if (AFRAME.components[componentName].multiple) {
                var id = prompt(
                  "Provide an ID for this component (e.g., 'foo' for " +
                    componentName +
                    "__foo)."
                );
                componentName = id ? componentName + "__" + id : componentName;
              }
              entity.setAttribute(componentName, "");
              _Events2.default.emit("componentadd", {
                entity: entity,
                component: componentName
              });
              ga("send", "event", "Components", "addComponent", componentName);
            }),
            _temp)),
          _possibleConstructorReturn(_this, _ret)
        );
      }
      _createClass(AddComponent, [
        {
          key: "getComponentsOptions",
          value: function getComponentsOptions() {
            var usedComponents = Object.keys(this.props.entity.components);
            var commonOptions = Object.keys(AFRAME.components)
              .filter(function(componentName) {
                return (
                  AFRAME.components[componentName].multiple ||
                  usedComponents.indexOf(componentName) === -1
                );
              })
              .sort()
              .map(function(value) {
                return { value: value, label: value, origin: "loaded" };
              });
            this.options = commonOptions;
            this.options = this.options.sort(function(a, b) {
              return a.label === b.label ? 0 : a.label < b.label ? -1 : 1;
            });
          }
        },
        {
          key: "renderOption",
          value: function renderOption(option) {
            var bullet = _react2.default.createElement(
              "span",
              { title: "Component already loaded in the scene" },
              "\u25CF"
            );
            return _react2.default.createElement(
              "strong",
              { className: "option" },
              option.label,
              " ",
              option.origin === "loaded" ? bullet : ""
            );
          }
        },
        {
          key: "render",
          value: function render() {
            var entity = this.props.entity;
            if (!entity) {
              return _react2.default.createElement("div", null);
            }
            this.getComponentsOptions();
            return _react2.default.createElement(
              "div",
              { id: "addComponentContainer" },
              _react2.default.createElement(
                "p",
                { id: "addComponentHeader" },
                "COMPONENTS"
              ),
              _react2.default.createElement(_reactSelect2.default, {
                id: "addComponent",
                className: "addComponent",
                classNamePrefix: "select",
                ref: "select",
                options: this.options,
                simpleValue: true,
                clearable: true,
                placeholder: "Add component...",
                noResultsText: "No components found",
                onChange: this.addComponent,
                optionRenderer: this.renderOption,
                searchable: true
              })
            );
          }
        }
      ]);
      return AddComponent;
    })(_react2.default.Component);
    AddComponent.propTypes = { entity: _propTypes2.default.object };
    exports.default = AddComponent;
    function isComponentInstanced(entity, componentName) {
      for (var component in entity.components) {
        if (component.substr(0, component.indexOf("__")) === componentName) {
          return true;
        }
      }
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _widgets = __webpack_require__(126);
    var _DefaultComponents = __webpack_require__(58);
    var _DefaultComponents2 = _interopRequireDefault(_DefaultComponents);
    var _PropertyRow = __webpack_require__(59);
    var _PropertyRow2 = _interopRequireDefault(_PropertyRow);
    var _Collapsible = __webpack_require__(57);
    var _Collapsible2 = _interopRequireDefault(_Collapsible);
    var _Mixins = __webpack_require__(116);
    var _Mixins2 = _interopRequireDefault(_Mixins);
    var _entity = __webpack_require__(14);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    var _clipboard = __webpack_require__(69);
    var _clipboard2 = _interopRequireDefault(_clipboard);
    var _utils = __webpack_require__(15);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    function changeId(componentName, value) {
      var entity = AFRAME.INSPECTOR.selectedEntity;
      if (entity.id !== value) {
        entity.id = value;
        _Events2.default.emit("entityidchange", entity);
      }
    }
    var CommonComponents = (function(_React$Component) {
      _inherits(CommonComponents, _React$Component);
      function CommonComponents() {
        _classCallCheck(this, CommonComponents);
        return _possibleConstructorReturn(
          this,
          (
            CommonComponents.__proto__ ||
            Object.getPrototypeOf(CommonComponents)
          ).apply(this, arguments)
        );
      }
      _createClass(CommonComponents, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            _Events2.default.on("entityupdate", function(detail) {
              if (detail.entity !== _this2.props.entity) {
                return;
              }
              if (
                _DefaultComponents2.default.indexOf(detail.component) !== -1
              ) {
                _this2.forceUpdate();
              }
            });
            _Events2.default.on("refreshsidebarobject3d", function() {
              _this2.forceUpdate();
            });
            var clipboard = new _clipboard2.default(
              '[data-action="copy-entity-to-clipboard"]',
              {
                text: function text(trigger) {
                  return (0, _entity.getEntityClipboardRepresentation)(
                    _this2.props.entity
                  );
                }
              }
            );
            clipboard.on("error", function(e) {});
          }
        },
        {
          key: "renderCommonAttributes",
          value: function renderCommonAttributes() {
            var entity = this.props.entity;
            var components = entity ? entity.components : {};
            return ["position", "rotation", "scale", "visible"].map(function(
              componentName
            ) {
              var schema = AFRAME.components[componentName].schema;
              var data = entity.object3D[componentName];
              if (componentName === "rotation") {
                data = {
                  x: THREE.Math.radToDeg(entity.object3D.rotation.x),
                  y: THREE.Math.radToDeg(entity.object3D.rotation.y),
                  z: THREE.Math.radToDeg(entity.object3D.rotation.z)
                };
              }
              return _react2.default.createElement(_PropertyRow2.default, {
                onChange: _entity.updateEntity,
                key: componentName,
                name: componentName,
                showHelp: true,
                schema: schema,
                data: data,
                isSingle: true,
                componentname: componentName,
                entity: entity
              });
            });
          }
        },
        {
          key: "exportToGLTF",
          value: function exportToGLTF() {
            var entity = this.props.entity;
            AFRAME.INSPECTOR.exporters.gltf.parse(
              entity.object3D,
              function(buffer) {
                var blob = new Blob([buffer], {
                  type: "application/octet-stream"
                });
                (0, _utils.saveBlob)(blob, (entity.id || "entity") + ".glb");
              },
              { binary: true }
            );
          }
        },
        {
          key: "render",
          value: function render() {
            var _this3 = this;
            var entity = this.props.entity;
            if (!entity) {
              return _react2.default.createElement("div", null);
            }
            var entityButtons = _react2.default.createElement(
              "div",
              null,
              _react2.default.createElement(
                "a",
                {
                  title: "Export entity to GLTF",
                  className: "gltfIcon",
                  onClick: function onClick(event) {
                    _this3.exportToGLTF();
                    event.stopPropagation();
                  }
                },
                _react2.default.createElement("img", {
                  src: true
                    ? "https://aframe.io/aframe-inspector/assets/gltf.svg"
                    : "../assets/gltf.svg"
                })
              ),
              _react2.default.createElement("a", {
                href: "#",
                title: "Copy entity HTML to clipboard",
                "data-action": "copy-entity-to-clipboard",
                className: "button fa fa-clipboard",
                onClick: function onClick(event) {
                  return event.stopPropagation();
                }
              })
            );
            return _react2.default.createElement(
              _Collapsible2.default,
              { id: "componentEntityHeader", className: "commonComponents" },
              _react2.default.createElement(
                "div",
                { className: "collapsible-header" },
                (0, _entity.printEntity)(entity),
                entityButtons
              ),
              _react2.default.createElement(
                "div",
                { className: "collapsible-content" },
                _react2.default.createElement(
                  "div",
                  { className: "propertyRow" },
                  _react2.default.createElement(
                    "label",
                    { htmlFor: "id", className: "text" },
                    "ID"
                  ),
                  _react2.default.createElement(_widgets.InputWidget, {
                    onChange: changeId,
                    entity: entity,
                    name: "id",
                    value: entity.id
                  })
                ),
                _react2.default.createElement(
                  "div",
                  { className: "propertyRow" },
                  _react2.default.createElement(
                    "label",
                    { className: "text" },
                    "class"
                  ),
                  _react2.default.createElement(
                    "span",
                    null,
                    entity.getAttribute("class")
                  )
                ),
                this.renderCommonAttributes(),
                _react2.default.createElement(_Mixins2.default, {
                  entity: entity
                })
              )
            );
          }
        }
      ]);
      return CommonComponents;
    })(_react2.default.Component);
    CommonComponents.propTypes = { entity: _propTypes2.default.object };
    exports.default = CommonComponents;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _PropertyRow = __webpack_require__(59);
    var _PropertyRow2 = _interopRequireDefault(_PropertyRow);
    var _Collapsible = __webpack_require__(57);
    var _Collapsible2 = _interopRequireDefault(_Collapsible);
    var _clipboard = __webpack_require__(69);
    var _clipboard2 = _interopRequireDefault(_clipboard);
    var _entity = __webpack_require__(14);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var isSingleProperty = AFRAME.schema.isSingleProperty;
    var Component = (function(_React$Component) {
      _inherits(Component, _React$Component);
      function Component(props) {
        _classCallCheck(this, Component);
        var _this = _possibleConstructorReturn(
          this,
          (Component.__proto__ || Object.getPrototypeOf(Component)).call(
            this,
            props
          )
        );
        _this.removeComponent = function(event) {
          var componentName = _this.props.name;
          event.stopPropagation();
          if (
            confirm(
              "Do you really want to remove component `" + componentName + "`?"
            )
          ) {
            _this.props.entity.removeAttribute(componentName);
            _Events2.default.emit("componentremove", {
              entity: _this.props.entity,
              component: componentName
            });
            ga("send", "event", "Components", "removeComponent", componentName);
          }
        };
        _this.renderPropertyRows = function() {
          var componentData = _this.props.component;
          if (isSingleProperty(componentData.schema)) {
            var componentName = _this.props.name;
            var schema = AFRAME.components[componentName.split("__")[0]].schema;
            return _react2.default.createElement(_PropertyRow2.default, {
              key: componentName,
              name: componentName,
              schema: schema,
              data: componentData.data,
              componentname: componentName,
              isSingle: true,
              entity: _this.props.entity
            });
          }
          return Object.keys(componentData.schema)
            .sort()
            .map(function(propertyName) {
              return _react2.default.createElement(_PropertyRow2.default, {
                key: propertyName,
                name: propertyName,
                schema: componentData.schema[propertyName],
                data: componentData.data[propertyName],
                componentname: _this.props.name,
                isSingle: false,
                entity: _this.props.entity
              });
            });
        };
        _this.state = { entity: _this.props.entity, name: _this.props.name };
        return _this;
      }
      _createClass(Component, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            var clipboard = new _clipboard2.default(
              '[data-action="copy-component-to-clipboard"]',
              {
                text: function text(trigger) {
                  var componentName = trigger
                    .getAttribute("data-component")
                    .toLowerCase();
                  ga(
                    "send",
                    "event",
                    "Components",
                    "copyComponentToClipboard",
                    componentName
                  );
                  return (0, _entity.getComponentClipboardRepresentation)(
                    _this2.state.entity,
                    componentName
                  );
                }
              }
            );
            clipboard.on("error", function(e) {
              console.error(e);
            });
            _Events2.default.on("entityupdate", function(detail) {
              if (detail.entity !== _this2.props.entity) {
                return;
              }
              if (detail.component === _this2.props.name) {
                _this2.forceUpdate();
              }
            });
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (this.state.entity !== newProps.entity) {
              this.setState({ entity: newProps.entity });
            }
            if (this.state.name !== newProps.name) {
              this.setState({ name: newProps.name });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            var componentName = this.props.name;
            var subComponentName = "";
            if (componentName.indexOf("__") !== -1) {
              subComponentName = componentName;
              componentName = componentName.substr(
                0,
                componentName.indexOf("__")
              );
            }
            return _react2.default.createElement(
              _Collapsible2.default,
              { collapsed: this.props.isCollapsed },
              _react2.default.createElement(
                "div",
                { className: "componentHeader collapsible-header" },
                _react2.default.createElement(
                  "span",
                  {
                    className: "componentTitle",
                    title: subComponentName || componentName
                  },
                  _react2.default.createElement(
                    "span",
                    null,
                    subComponentName || componentName
                  )
                ),
                _react2.default.createElement(
                  "div",
                  { className: "componentHeaderActions" },
                  _react2.default.createElement("a", {
                    title: "Copy to clipboard",
                    "data-action": "copy-component-to-clipboard",
                    "data-component": subComponentName || componentName,
                    className: "button fa fa-clipboard",
                    href: "#"
                  }),
                  _react2.default.createElement("a", {
                    title: "Remove component",
                    className: "button fa fa-trash-o",
                    onClick: this.removeComponent
                  })
                )
              ),
              _react2.default.createElement(
                "div",
                { className: "collapsible-content" },
                this.renderPropertyRows()
              )
            );
          }
        }
      ]);
      return Component;
    })(_react2.default.Component);
    Component.propTypes = {
      component: _propTypes2.default.any,
      entity: _propTypes2.default.object,
      isCollapsed: _propTypes2.default.bool,
      name: _propTypes2.default.string
    };
    exports.default = Component;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _AddComponent = __webpack_require__(112);
    var _AddComponent2 = _interopRequireDefault(_AddComponent);
    var _Component = __webpack_require__(114);
    var _Component2 = _interopRequireDefault(_Component);
    var _CommonComponents = __webpack_require__(113);
    var _CommonComponents2 = _interopRequireDefault(_CommonComponents);
    var _DefaultComponents = __webpack_require__(58);
    var _DefaultComponents2 = _interopRequireDefault(_DefaultComponents);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var ComponentsContainer = (function(_React$Component) {
      _inherits(ComponentsContainer, _React$Component);
      function ComponentsContainer() {
        var _ref;
        var _temp, _this, _ret;
        _classCallCheck(this, ComponentsContainer);
        for (
          var _len = arguments.length, args = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return (
          (_ret =
            ((_temp =
              ((_this = _possibleConstructorReturn(
                this,
                (_ref =
                  ComponentsContainer.__proto__ ||
                  Object.getPrototypeOf(ComponentsContainer)).call.apply(
                  _ref,
                  [this].concat(args)
                )
              )),
              _this)),
            (_this.refresh = function() {
              _this.forceUpdate();
            }),
            _temp)),
          _possibleConstructorReturn(_this, _ret)
        );
      }
      _createClass(ComponentsContainer, [
        {
          key: "render",
          value: function render() {
            var entity = this.props.entity;
            var components = entity ? entity.components : {};
            var definedComponents = Object.keys(components).filter(function(
              key
            ) {
              return _DefaultComponents2.default.indexOf(key) === -1;
            });
            var renderedComponents = definedComponents
              .sort()
              .map(function(key) {
                return _react2.default.createElement(_Component2.default, {
                  isCollapsed: definedComponents.length > 2,
                  component: components[key],
                  entity: entity,
                  key: key,
                  name: key
                });
              });
            return _react2.default.createElement(
              "div",
              { className: "components" },
              _react2.default.createElement(_CommonComponents2.default, {
                entity: entity
              }),
              _react2.default.createElement(_AddComponent2.default, {
                entity: entity
              }),
              renderedComponents
            );
          }
        }
      ]);
      return ComponentsContainer;
    })(_react2.default.Component);
    ComponentsContainer.propTypes = { entity: _propTypes2.default.object };
    exports.default = ComponentsContainer;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _reactSelect = __webpack_require__(37);
    var _reactSelect2 = _interopRequireDefault(_reactSelect);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Events = __webpack_require__(5);
    function trim(s) {
      s = s.replace(/(^\s*)|(\s*$)/gi, "");
      s = s.replace(/[ ]{2,}/gi, " ");
      s = s.replace(/\n /, "\n");
      return s;
    }
    var Mixin = (function(_React$Component) {
      _inherits(Mixin, _React$Component);
      function Mixin(props) {
        _classCallCheck(this, Mixin);
        var _this = _possibleConstructorReturn(
          this,
          (Mixin.__proto__ || Object.getPrototypeOf(Mixin)).call(this, props)
        );
        _this.getMixinOptions = function() {
          var mixinIds = _this.props.entity.mixinEls.map(function(mixin) {
            return mixin.id;
          });
          return Array.prototype.slice
            .call(document.querySelectorAll("a-mixin"))
            .filter(function(mixin) {
              return mixinIds.indexOf(mixin.id) === -1;
            })
            .sort()
            .map(function(mixin) {
              return { value: mixin.id, label: mixin.id };
            });
        };
        _this.updateMixins = function(value) {
          var entity = _this.props.entity;
          _this.setState({ mixins: value });
          var mixinStr = value
            .map(function(v) {
              return v.value;
            })
            .join(" ");
          console.log(mixinStr);
          entity.setAttribute("mixin", mixinStr);
          Events.emit("entityupdate", {
            component: "mixin",
            entity: entity,
            property: "",
            value: mixinStr
          });
          ga("send", "event", "Components", "addMixin");
        };
        _this.state = { mixins: _this.getMixinValue() };
        return _this;
      }
      _createClass(Mixin, [
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps, prevState) {
            if (this.props.entity === prevProps.entity) {
              return;
            }
            this.setState({ mixins: this.getMixinValue() });
          }
        },
        {
          key: "getMixinValue",
          value: function getMixinValue() {
            return (this.props.entity.getAttribute("mixin") || "")
              .split(/\s+/g)
              .filter(function(v) {
                return !!v;
              })
              .map(function(v) {
                return { label: v, value: v };
              });
          }
        },
        {
          key: "render",
          value: function render() {
            return _react2.default.createElement(
              "div",
              { className: "mixinOptions" },
              _react2.default.createElement(
                "div",
                { className: "propertyRow" },
                _react2.default.createElement(
                  "span",
                  { className: "text" },
                  "mixins"
                ),
                _react2.default.createElement(
                  "span",
                  { className: "mixinValue" },
                  _react2.default.createElement(_reactSelect2.default, {
                    id: "mixinSelect",
                    classNamePrefix: "select",
                    ref: "select",
                    options: this.getMixinOptions(),
                    isMulti: true,
                    placeholder: "Add mixin...",
                    noResultsText: "No mixins found",
                    onChange: this.updateMixins.bind(this),
                    simpleValue: true,
                    value: this.state.mixins
                  })
                )
              )
            );
          }
        }
      ]);
      return Mixin;
    })(_react2.default.Component);
    Mixin.propTypes = { entity: _propTypes2.default.object.isRequired };
    exports.default = Mixin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _ComponentsContainer = __webpack_require__(115);
    var _ComponentsContainer2 = _interopRequireDefault(_ComponentsContainer);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Sidebar = (function(_React$Component) {
      _inherits(Sidebar, _React$Component);
      function Sidebar(props) {
        _classCallCheck(this, Sidebar);
        var _this = _possibleConstructorReturn(
          this,
          (Sidebar.__proto__ || Object.getPrototypeOf(Sidebar)).call(
            this,
            props
          )
        );
        _this.handleToggle = function() {
          _this.setState({ open: !_this.state.open });
          ga("send", "event", "Components", "toggleSidebar");
        };
        _this.state = { open: false };
        return _this;
      }
      _createClass(Sidebar, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            _Events2.default.on("componentremove", function(event) {
              _this2.forceUpdate();
            });
            _Events2.default.on("componentadd", function(event) {
              _this2.forceUpdate();
            });
          }
        },
        {
          key: "render",
          value: function render() {
            var entity = this.props.entity;
            var visible = this.props.visible;
            if (entity && visible) {
              return _react2.default.createElement(
                "div",
                { id: "sidebar" },
                _react2.default.createElement(_ComponentsContainer2.default, {
                  entity: entity
                })
              );
            } else {
              return _react2.default.createElement("div", null);
            }
          }
        }
      ]);
      return Sidebar;
    })(_react2.default.Component);
    Sidebar.propTypes = {
      entity: _propTypes2.default.object,
      visible: _propTypes2.default.bool
    };
    exports.default = Sidebar;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _Modal = __webpack_require__(60);
    var _Modal2 = _interopRequireDefault(_Modal);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var ModalHelp = (function(_React$Component) {
      _inherits(ModalHelp, _React$Component);
      function ModalHelp(props) {
        _classCallCheck(this, ModalHelp);
        var _this = _possibleConstructorReturn(
          this,
          (ModalHelp.__proto__ || Object.getPrototypeOf(ModalHelp)).call(
            this,
            props
          )
        );
        _this.onClose = function(value) {
          if (_this.props.onClose) {
            _this.props.onClose();
          }
        };
        _this.state = { isOpen: _this.props.isOpen };
        return _this;
      }
      _createClass(ModalHelp, [
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (this.state.isOpen !== newProps.isOpen) {
              this.setState({ isOpen: newProps.isOpen });
            }
          }
        },
        {
          key: "render",
          value: function render() {
            var shortcuts = [
              [
                { key: ["w"], description: "Translate" },
                { key: ["e"], description: "Rotate" },
                { key: ["r"], description: "Scale" },
                { key: ["d"], description: "Duplicate selected entity" },
                { key: ["f"], description: "Focus on selected entity" },
                { key: ["g"], description: "Toggle grid visibility" },
                { key: ["n"], description: "Add new entity" },
                {
                  key: ["o"],
                  description: "Toggle local between global transform"
                },
                {
                  key: ["supr | backspace"],
                  description: "Delete selected entity"
                }
              ],
              [
                { key: ["0"], description: "Toggle panels" },
                { key: ["1"], description: "Perspective view" },
                { key: ["2"], description: "Left view" },
                { key: ["3"], description: "Right view" },
                { key: ["4"], description: "Top view" },
                { key: ["5"], description: "Bottom view" },
                { key: ["6"], description: "Back view" },
                { key: ["7"], description: "Front view" },
                {
                  key: ["ctrl | cmd", "x"],
                  description: "Cut selected entity"
                },
                {
                  key: ["ctrl | cmd", "c"],
                  description: "Copy selected entity"
                },
                { key: ["ctrl | cmd", "v"], description: "Paste entity" },
                { key: ["h"], description: "Show this help" },
                { key: ["Esc"], description: "Unselect entity" },
                {
                  key: ["ctrl", "alt", "i"],
                  description: "Switch Edit and VR Modes"
                }
              ]
            ];
            return _react2.default.createElement(
              _Modal2.default,
              {
                title: "Shortcuts",
                isOpen: this.state.isOpen,
                onClose: this.onClose,
                extraCloseKeyCode: 72
              },
              _react2.default.createElement(
                "div",
                { className: "help-lists" },
                shortcuts.map(function(column, idx) {
                  return _react2.default.createElement(
                    "ul",
                    { className: "help-list", key: idx },
                    column.map(function(shortcut) {
                      return _react2.default.createElement(
                        "li",
                        { key: shortcut.key, className: "help-key-unit" },
                        shortcut.key.map(function(key) {
                          return _react2.default.createElement(
                            "kbd",
                            { key: key, className: "help-key" },
                            _react2.default.createElement("span", null, key)
                          );
                        }),
                        _react2.default.createElement(
                          "span",
                          { className: "help-key-def" },
                          shortcut.description
                        )
                      );
                    })
                  );
                })
              )
            );
          }
        }
      ]);
      return ModalHelp;
    })(_react2.default.Component);
    ModalHelp.propTypes = {
      isOpen: _propTypes2.default.bool,
      onClose: _propTypes2.default.func
    };
    exports.default = ModalHelp;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _Modal = __webpack_require__(60);
    var _Modal2 = _interopRequireDefault(_Modal);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var insertNewAsset = __webpack_require__(130).insertNewAsset;
    function getFilename(url) {
      var converted =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : false;
      var filename = url.split("/").pop();
      if (converted) {
        filename = getValidId(filename);
      }
      return filename;
    }
    function isValidId(id) {
      var re = /^[A-Za-z]+[\w\-]*$/;
      return re.test(id);
    }
    function getValidId(name) {
      return name
        .split(".")
        .shift()
        .replace(/\s/, "-")
        .replace(/^\d+\s*/, "")
        .replace(/[\W]/, "")
        .toLowerCase();
    }
    var ModalTextures = (function(_React$Component) {
      _inherits(ModalTextures, _React$Component);
      function ModalTextures(props) {
        _classCallCheck(this, ModalTextures);
        var _this = _possibleConstructorReturn(
          this,
          (
            ModalTextures.__proto__ || Object.getPrototypeOf(ModalTextures)
          ).call(this, props)
        );
        _this.onClose = function(value) {
          if (_this.props.onClose) {
            _this.props.onClose();
          }
        };
        _this.selectTexture = function(value) {
          if (_this.props.onClose) {
            _this.props.onClose(value);
          }
        };
        _this.generateFromRegistry = function() {
          var self = _this;
          AFRAME.INSPECTOR.assetsLoader.images.forEach(function(imageData) {
            var image = new Image();
            image.addEventListener("load", function() {
              self.state.registryImages.push({
                id: imageData.id,
                src: imageData.fullPath,
                width: imageData.width,
                height: imageData.height,
                name: imageData.id,
                type: "registry",
                tags: imageData.tags,
                value: "url(" + imageData.fullPath + ")"
              });
              self.setState({
                registryImages: self.state.registryImages.slice()
              });
            });
            image.src = imageData.fullThumbPath;
          });
        };
        _this.generateFromAssets = function() {
          _this.setState({ assetsImages: [] });
          var self = _this;
          Array.prototype.slice
            .call(document.querySelectorAll("a-assets img"))
            .map(function(asset) {
              var image = new Image();
              image.addEventListener("load", function() {
                self.state.assetsImages.push({
                  id: asset.id,
                  src: image.src,
                  width: image.width,
                  height: image.height,
                  name: asset.id,
                  type: "asset",
                  value: "#" + asset.id
                });
                self.setState({ assetsImages: self.state.assetsImages });
              });
              image.src = asset.src;
            });
        };
        _this.onNewUrl = function(event) {
          if (event.keyCode !== 13) {
            return;
          }
          var self = _this;
          function onImageLoaded(img) {
            var src = self.refs.preview.src;
            self.setState({
              preview: {
                width: self.refs.preview.naturalWidth,
                height: self.refs.preview.naturalHeight,
                src: src,
                id: "",
                name: getFilename(src, true),
                filename: getFilename(src),
                type: "new",
                loaded: true,
                value: "url(" + src + ")"
              }
            });
            self.refs.preview.removeEventListener("load", onImageLoaded);
          }
          _this.refs.preview.addEventListener("load", onImageLoaded);
          _this.refs.preview.src = event.target.value;
          _this.refs.imageName.focus();
        };
        _this.onNameKeyUp = function(event) {
          if (event.keyCode === 13 && _this.isValidAsset()) {
            _this.addNewAsset();
          }
        };
        _this.onNameChanged = function(event) {
          var state = _this.state.preview;
          state.name = event.target.value;
          _this.setState({ preview: state });
        };
        _this.toggleNewDialog = function() {
          _this.setState({
            addNewDialogOpened: !_this.state.addNewDialogOpened
          });
        };
        _this.onUrlChange = function(e) {
          _this.setState({ newUrl: e.target.value });
        };
        _this.addNewAsset = function() {
          var self = _this;
          insertNewAsset(
            "img",
            _this.state.preview.name,
            _this.state.preview.src,
            true,
            function() {
              self.generateFromAssets();
              self.setState({ addNewDialogOpened: false });
              self.clear();
            }
          );
        };
        _this.onChangeFilter = function(e) {
          _this.setState({ filterText: e.target.value });
        };
        _this.state = {
          filterText: "",
          isOpen: _this.props.isOpen,
          loadedTextures: [],
          assetsImages: [],
          registryImages: [],
          addNewDialogOpened: false,
          newUrl: "",
          preview: {
            width: 0,
            height: 0,
            src: "",
            id: "",
            name: "",
            filename: "",
            type: "",
            value: "",
            loaded: false
          }
        };
        return _this;
      }
      _createClass(ModalTextures, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            _Events2.default.on("assetsimagesload", function(images) {
              _this2.generateFromRegistry();
            });
            this.generateFromAssets();
          }
        },
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate() {
            if (this.state.isOpen && !AFRAME.INSPECTOR.assetsLoader.hasLoaded) {
              AFRAME.INSPECTOR.assetsLoader.load();
            }
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(newProps) {
            if (this.state.isOpen !== newProps.isOpen) {
              this.setState({ isOpen: newProps.isOpen });
              if (newProps.isOpen) {
                this.generateFromAssets();
              }
            }
          }
        },
        {
          key: "clear",
          value: function clear() {
            this.setState({
              preview: {
                width: 0,
                height: 0,
                src: "",
                id: "",
                filename: "",
                name: "",
                type: "",
                loaded: false,
                value: ""
              },
              newUrl: ""
            });
          }
        },
        {
          key: "isValidAsset",
          value: function isValidAsset() {
            var validUrl = isValidId(this.state.preview.name);
            var validAsset = this.state.preview.loaded && validUrl;
            return validAsset;
          }
        },
        {
          key: "renderRegistryImages",
          value: function renderRegistryImages() {
            var self = this;
            var selectSample = function selectSample(image) {
              self.setState({
                preview: {
                  width: image.width,
                  height: image.height,
                  src: image.src,
                  id: "",
                  name: getFilename(image.name, true),
                  filename: getFilename(image.src),
                  type: "registry",
                  loaded: true,
                  value: "url(" + image.src + ")"
                }
              });
              self.refs.imageName.focus();
            };
            var filterText = this.state.filterText.toUpperCase();
            return this.state.registryImages
              .filter(function(image) {
                return (
                  image.id.toUpperCase().indexOf(filterText) > -1 ||
                  image.name.toUpperCase().indexOf(filterText) > -1 ||
                  image.tags.indexOf(filterText) > -1
                );
              })
              .map(function(image) {
                var imageClick = selectSample.bind(this, image);
                return _react2.default.createElement(
                  "li",
                  { key: image.src, onClick: imageClick },
                  _react2.default.createElement("img", {
                    width: "155px",
                    height: "155px",
                    src: image.src
                  }),
                  _react2.default.createElement(
                    "div",
                    { className: "detail" },
                    _react2.default.createElement(
                      "span",
                      { className: "title" },
                      image.name
                    ),
                    _react2.default.createElement(
                      "span",
                      null,
                      getFilename(image.src)
                    ),
                    _react2.default.createElement(
                      "span",
                      null,
                      image.width,
                      " x ",
                      image.height
                    )
                  )
                );
              });
          }
        },
        {
          key: "render",
          value: function render() {
            var isOpen = this.state.isOpen;
            var loadedTextures = this.state.loadedTextures;
            var preview = this.state.preview;
            var validUrl = isValidId(this.state.preview.name);
            var validAsset = this.isValidAsset();
            var addNewAssetButton = this.state.addNewDialogOpened
              ? "BACK"
              : "LOAD TEXTURE";
            return _react2.default.createElement(
              _Modal2.default,
              {
                id: "textureModal",
                title: "Textures",
                isOpen: isOpen,
                onClose: this.onClose,
                closeOnClickOutside: false
              },
              _react2.default.createElement(
                "button",
                { onClick: this.toggleNewDialog },
                addNewAssetButton
              ),
              _react2.default.createElement(
                "div",
                { className: this.state.addNewDialogOpened ? "" : "hide" },
                _react2.default.createElement(
                  "div",
                  { className: "newimage" },
                  _react2.default.createElement(
                    "div",
                    { className: "new_asset_options" },
                    _react2.default.createElement(
                      "span",
                      null,
                      "Load a new texture from one of these sources:"
                    ),
                    _react2.default.createElement(
                      "ul",
                      null,
                      _react2.default.createElement(
                        "li",
                        null,
                        _react2.default.createElement(
                          "span",
                          null,
                          "From URL (and press Enter):"
                        ),
                        " ",
                        _react2.default.createElement("input", {
                          type: "text",
                          className: "imageUrl",
                          value: this.state.newUrl,
                          onChange: this.onUrlChange,
                          onKeyUp: this.onNewUrl
                        })
                      ),
                      _react2.default.createElement(
                        "li",
                        null,
                        _react2.default.createElement(
                          "span",
                          null,
                          "From assets registry: "
                        ),
                        _react2.default.createElement(
                          "div",
                          { className: "assets search" },
                          _react2.default.createElement("input", {
                            placeholder: "Filter...",
                            value: this.state.filterText,
                            onChange: this.onChangeFilter
                          }),
                          _react2.default.createElement("span", {
                            className: "fa fa-search"
                          })
                        ),
                        _react2.default.createElement(
                          "ul",
                          { ref: "registryGallery", className: "gallery" },
                          this.renderRegistryImages()
                        )
                      )
                    )
                  ),
                  _react2.default.createElement(
                    "div",
                    { className: "preview" },
                    "Name:",
                    " ",
                    _react2.default.createElement("input", {
                      ref: "imageName",
                      className:
                        this.state.preview.name.length > 0 && !validUrl
                          ? "error"
                          : "",
                      type: "text",
                      value: this.state.preview.name,
                      onChange: this.onNameChanged,
                      onKeyUp: this.onNameKeyUp
                    }),
                    _react2.default.createElement("img", {
                      ref: "preview",
                      width: "155px",
                      height: "155px",
                      src: preview.src
                    }),
                    this.state.preview.loaded
                      ? _react2.default.createElement(
                          "div",
                          { className: "detail" },
                          _react2.default.createElement(
                            "span",
                            { className: "title", title: preview.filename },
                            preview.filename
                          ),
                          _react2.default.createElement("br", null),
                          _react2.default.createElement(
                            "span",
                            null,
                            preview.width,
                            " x ",
                            preview.height
                          )
                        )
                      : _react2.default.createElement("span", null),
                    _react2.default.createElement("br", null),
                    _react2.default.createElement(
                      "button",
                      { disabled: !validAsset, onClick: this.addNewAsset },
                      "LOAD THIS TEXTURE"
                    )
                  )
                )
              ),
              _react2.default.createElement(
                "div",
                { className: this.state.addNewDialogOpened ? "hide" : "" },
                _react2.default.createElement(
                  "ul",
                  { className: "gallery" },
                  this.state.assetsImages
                    .sort(function(a, b) {
                      return a.id > b.id;
                    })
                    .map(
                      function(image) {
                        var textureClick = this.selectTexture.bind(this, image);
                        var selectedClass =
                          this.props.selectedTexture === "#" + image.id
                            ? "selected"
                            : "";
                        return _react2.default.createElement(
                          "li",
                          {
                            key: image.id,
                            onClick: textureClick,
                            className: selectedClass
                          },
                          _react2.default.createElement("img", {
                            width: "155px",
                            height: "155px",
                            src: image.src
                          }),
                          _react2.default.createElement(
                            "div",
                            { className: "detail" },
                            _react2.default.createElement(
                              "span",
                              { className: "title" },
                              image.name
                            ),
                            _react2.default.createElement(
                              "span",
                              null,
                              getFilename(image.src)
                            ),
                            _react2.default.createElement(
                              "span",
                              null,
                              image.width,
                              " x ",
                              image.height
                            )
                          )
                        );
                      }.bind(this)
                    ),
                  loadedTextures.map(function(texture) {
                    var image = texture.image;
                    var textureClick = this.selectTexture.bind(this, texture);
                    return _react2.default.createElement(
                      "li",
                      { key: texture.uuid, onClick: textureClick },
                      _react2.default.createElement("img", {
                        width: "155px",
                        height: "155px",
                        src: image.src
                      }),
                      _react2.default.createElement(
                        "div",
                        { className: "detail" },
                        _react2.default.createElement(
                          "span",
                          { className: "title" },
                          "Name:"
                        ),
                        " ",
                        _react2.default.createElement("span", null, image.name),
                        _react2.default.createElement(
                          "span",
                          { className: "title" },
                          "Filename:"
                        ),
                        " ",
                        _react2.default.createElement(
                          "span",
                          null,
                          getFilename(image.src)
                        ),
                        _react2.default.createElement(
                          "span",
                          null,
                          image.width,
                          " x ",
                          image.height
                        )
                      )
                    );
                  })
                )
              )
            );
          }
        }
      ]);
      return ModalTextures;
    })(_react2.default.Component);
    ModalTextures.propTypes = {
      isOpen: _propTypes2.default.bool,
      onClose: _propTypes2.default.func,
      selectedTexture: _propTypes2.default.string
    };
    exports.default = ModalTextures;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _classnames = __webpack_require__(16);
    var _classnames2 = _interopRequireDefault(_classnames);
    var _entity = __webpack_require__(14);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Events = __webpack_require__(5);
    var Entity = (function(_React$Component) {
      _inherits(Entity, _React$Component);
      function Entity(props) {
        _classCallCheck(this, Entity);
        var _this = _possibleConstructorReturn(
          this,
          (Entity.__proto__ || Object.getPrototypeOf(Entity)).call(this, props)
        );
        _this.onClick = function() {
          return _this.props.selectEntity(_this.props.entity);
        };
        _this.onDoubleClick = function() {
          return Events.emit("objectfocus", _this.props.entity.object3D);
        };
        _this.toggleVisibility = function() {
          var entity = _this.props.entity;
          var visible =
            entity.tagName.toLowerCase() === "a-scene"
              ? entity.object3D.visible
              : entity.getAttribute("visible");
          entity.setAttribute("visible", !visible);
        };
        _this.state = {};
        return _this;
      }
      _createClass(Entity, [
        {
          key: "render",
          value: function render() {
            var _this2 = this;
            var isFiltering = this.props.isFiltering;
            var isExpanded = this.props.isExpanded;
            var entity = this.props.entity;
            var tagName = entity.tagName.toLowerCase();
            var cloneButton =
              tagName === "a-scene"
                ? null
                : _react2.default.createElement("a", {
                    onClick: function onClick() {
                      return (0, _entity.cloneEntity)(entity);
                    },
                    title: "Clone entity",
                    className: "button fa fa-clone"
                  });
            var removeButton =
              tagName === "a-scene"
                ? null
                : _react2.default.createElement("a", {
                    onClick: function onClick(event) {
                      event.stopPropagation();
                      (0, _entity.removeEntity)(entity);
                    },
                    title: "Remove entity",
                    className: "button fa fa-trash"
                  });
            var pad = "&nbsp;&nbsp;&nbsp;&nbsp;".repeat(this.props.depth);
            var collapse = void 0;
            if (entity.children.length > 0 && !isFiltering) {
              collapse = _react2.default.createElement("span", {
                onClick: function onClick() {
                  return _this2.props.toggleExpandedCollapsed(entity);
                },
                className:
                  "collapsespace fa " +
                  (isExpanded ? "fa-caret-down" : "fa-caret-right")
              });
            } else {
              collapse = _react2.default.createElement("span", {
                className: "collapsespace"
              });
            }
            var visible =
              tagName === "a-scene"
                ? entity.object3D.visible
                : entity.getAttribute("visible");
            var visibilityButton = _react2.default.createElement("i", {
              title: "Toggle entity visibility",
              className: "fa " + (visible ? "fa-eye" : "fa-eye-slash"),
              onClick: this.toggleVisibility
            });
            var className = (0, _classnames2.default)({
              active: this.props.isSelected,
              entity: true,
              novisible: !visible,
              option: true
            });
            return _react2.default.createElement(
              "div",
              { className: className, onClick: this.onClick },
              _react2.default.createElement(
                "span",
                null,
                visibilityButton,
                _react2.default.createElement("span", {
                  className: "entityChildPadding",
                  dangerouslySetInnerHTML: { __html: pad }
                }),
                collapse,
                (0, _entity.printEntity)(entity, this.onDoubleClick)
              ),
              _react2.default.createElement(
                "span",
                { className: "entityActions" },
                cloneButton,
                removeButton
              )
            );
          }
        }
      ]);
      return Entity;
    })(_react2.default.Component);
    Entity.propTypes = {
      depth: _propTypes2.default.number,
      entity: _propTypes2.default.object,
      isExpanded: _propTypes2.default.bool,
      isFiltering: _propTypes2.default.bool,
      isSelected: _propTypes2.default.bool,
      selectEntity: _propTypes2.default.func,
      toggleExpandedCollapsed: _propTypes2.default.func
    };
    exports.default = Entity;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _classnames = __webpack_require__(16);
    var _classnames2 = _interopRequireDefault(_classnames);
    var _lodash = __webpack_require__(24);
    var _lodash2 = _interopRequireDefault(_lodash);
    var _Entity = __webpack_require__(120);
    var _Entity2 = _interopRequireDefault(_Entity);
    var _Toolbar = __webpack_require__(122);
    var _Toolbar2 = _interopRequireDefault(_Toolbar);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var Events = __webpack_require__(5);
    var SceneGraph = (function(_React$Component) {
      _inherits(SceneGraph, _React$Component);
      function SceneGraph(props) {
        _classCallCheck(this, SceneGraph);
        var _this = _possibleConstructorReturn(
          this,
          (SceneGraph.__proto__ || Object.getPrototypeOf(SceneGraph)).call(
            this,
            props
          )
        );
        _this.selectEntity = function(entity) {
          var found = false;
          for (var i = 0; i < _this.state.filteredEntities.length; i++) {
            var entityOption = _this.state.filteredEntities[i];
            if (entityOption.entity === entity) {
              _this.setState({ selectedEntity: entity, selectedIndex: i });
              _this.expandToRoot(entity);
              if (_this.props.onChange) {
                _this.props.onChange(entity);
              }
              Events.emit("entityselect", entity, true);
              found = true;
            }
          }
          if (!found) {
            _this.setState({ selectedEntity: null, selectedIndex: -1 });
          }
        };
        _this.rebuildEntityOptions = function() {
          var entities = [{ depth: 0, entity: _this.props.scene }];
          function treeIterate(element, depth) {
            if (!element) {
              return;
            }
            depth += 1;
            for (var i = 0; i < element.children.length; i++) {
              var entity = element.children[i];
              if (
                entity.dataset.isInspector ||
                !entity.isEntity ||
                entity.isInspector ||
                "aframeInspector" in entity.dataset
              ) {
                continue;
              }
              entities.push({ entity: entity, depth: depth });
              treeIterate(entity, depth);
            }
          }
          treeIterate(_this.props.scene, 0);
          _this.setState({
            entities: entities,
            filteredEntities: _this.getFilteredEntities(
              _this.state.filter,
              entities
            )
          });
        };
        _this.selectIndex = function(index) {
          if (index >= 0 && index < _this.state.entities.length) {
            _this.selectEntity(_this.state.entities[index].entity);
          }
        };
        _this.onFilterKeyUp = function(event) {
          if (event.keyCode === 27) {
            _this.clearFilter();
          }
        };
        _this.onKeyDown = function(event) {
          switch (event.keyCode) {
            case 37:
            case 38:
            case 39:
            case 40:
              event.preventDefault();
              event.stopPropagation();
              break;
          }
        };
        _this.onKeyUp = function(event) {
          if (_this.props.selectedEntity === null) {
            return;
          }
          switch (event.keyCode) {
            case 37:
              if (_this.isExpanded(_this.props.selectedEntity)) {
                _this.toggleExpandedCollapsed(_this.props.selectedEntity);
              }
              break;
            case 38:
              _this.selectIndex(
                _this.previousExpandedIndexTo(_this.state.selectedIndex)
              );
              break;
            case 39:
              if (!_this.isExpanded(_this.props.selectedEntity)) {
                _this.toggleExpandedCollapsed(_this.props.selectedEntity);
              }
              break;
            case 40:
              _this.selectIndex(
                _this.nextExpandedIndexTo(_this.state.selectedIndex)
              );
              break;
          }
        };
        _this.isVisibleInSceneGraph = function(x) {
          var curr = x.parentNode;
          if (!curr) {
            return false;
          }
          while (curr !== undefined && curr.isEntity) {
            if (!_this.isExpanded(curr)) {
              return false;
            }
            curr = curr.parentNode;
          }
          return true;
        };
        _this.isExpanded = function(x) {
          return _this.state.expandedElements.get(x) === true;
        };
        _this.toggleExpandedCollapsed = function(x) {
          _this.setState({
            expandedElements: _this.state.expandedElements.set(
              x,
              !_this.isExpanded(x)
            )
          });
        };
        _this.expandToRoot = function(x) {
          var curr = x.parentNode;
          while (curr !== undefined && curr.isEntity) {
            _this.state.expandedElements.set(curr, true);
            curr = curr.parentNode;
          }
          _this.setState({ expandedElements: _this.state.expandedElements });
        };
        _this.previousExpandedIndexTo = function(i) {
          for (var prevIter = i - 1; prevIter >= 0; prevIter--) {
            var prevEl = _this.state.entities[prevIter].entity;
            if (_this.isVisibleInSceneGraph(prevEl)) {
              return prevIter;
            }
          }
          return -1;
        };
        _this.nextExpandedIndexTo = function(i) {
          for (
            var nextIter = i + 1;
            nextIter < _this.state.entities.length;
            nextIter++
          ) {
            var nextEl = _this.state.entities[nextIter].entity;
            if (_this.isVisibleInSceneGraph(nextEl)) {
              return nextIter;
            }
          }
          return -1;
        };
        _this.onChangeFilter = function(evt) {
          var filter = evt.target.value;
          _this.setState({ filter: filter });
          _this.updateFilteredEntities(filter);
        };
        _this.clearFilter = function() {
          _this.setState({ filter: "" });
        };
        _this.renderEntities = function() {
          return _this.state.filteredEntities.map(function(entityOption, idx) {
            if (
              !_this.isVisibleInSceneGraph(entityOption.entity) &&
              !_this.state.filter
            ) {
              return null;
            }
            return _react2.default.createElement(
              _Entity2.default,
              _extends({}, entityOption, {
                key: idx,
                isFiltering: !!_this.state.filter,
                isExpanded: _this.isExpanded(entityOption.entity),
                isSelected: _this.props.selectedEntity === entityOption.entity,
                selectEntity: _this.selectEntity,
                toggleExpandedCollapsed: _this.toggleExpandedCollapsed
              })
            );
          });
        };
        _this.state = {
          entities: [],
          expandedElements: new WeakMap([[props.scene, true]]),
          filter: "",
          filteredEntities: [],
          selectedIndex: -1
        };
        _this.rebuildEntityOptions = (0, _lodash2.default)(
          _this.rebuildEntityOptions.bind(_this),
          1000
        );
        _this.updateFilteredEntities = (0, _lodash2.default)(
          _this.updateFilteredEntities.bind(_this),
          500
        );
        return _this;
      }
      _createClass(SceneGraph, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.rebuildEntityOptions();
            Events.on("entityidchange", this.rebuildEntityOptions);
            Events.on("entitycreated", this.rebuildEntityOptions);
          }
        },
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            if (prevProps.selectedEntity !== this.props.selectedEntity) {
              this.selectEntity(this.props.selectedEntity);
            }
          }
        },
        {
          key: "getFilteredEntities",
          value: function getFilteredEntities(filter, entities) {
            var _this2 = this;
            entities = entities || this.state.entities;
            if (!filter) {
              return entities;
            }
            return entities.filter(function(entityOption) {
              return filterEntity(
                entityOption.entity,
                filter || _this2.state.filter
              );
            });
          }
        },
        {
          key: "updateFilteredEntities",
          value: function updateFilteredEntities(filter) {
            this.setState({
              filteredEntities: this.getFilteredEntities(filter)
            });
          }
        },
        {
          key: "render",
          value: function render() {
            if (!this.props.visible) {
              return null;
            }
            var clearFilter = this.state.filter
              ? _react2.default.createElement("a", {
                  onClick: this.clearFilter,
                  className: "button fa fa-times"
                })
              : null;
            return _react2.default.createElement(
              "div",
              { id: "scenegraph", className: "scenegraph" },
              _react2.default.createElement(
                "div",
                { className: "scenegraph-toolbar" },
                _react2.default.createElement(_Toolbar2.default, null),
                _react2.default.createElement(
                  "div",
                  { className: "search" },
                  _react2.default.createElement("input", {
                    id: "filter",
                    placeholder: "Search...",
                    onChange: this.onChangeFilter,
                    onKeyUp: this.onFilterKeyUp
                  }),
                  clearFilter,
                  !this.state.filter &&
                    _react2.default.createElement("span", {
                      className: "fa fa-search"
                    })
                )
              ),
              _react2.default.createElement(
                "div",
                {
                  className: "outliner",
                  tabIndex: "0",
                  onKeyDown: this.onKeyDown,
                  onKeyUp: this.onKeyUp
                },
                this.renderEntities()
              )
            );
          }
        }
      ]);
      return SceneGraph;
    })(_react2.default.Component);
    SceneGraph.propTypes = {
      id: _propTypes2.default.string,
      onChange: _propTypes2.default.func,
      scene: _propTypes2.default.object,
      selectedEntity: _propTypes2.default.object,
      visible: _propTypes2.default.bool
    };
    SceneGraph.defaultProps = {
      selectedEntity: "",
      index: -1,
      id: "left-sidebar"
    };
    exports.default = SceneGraph;
    function filterEntity(entity, filter) {
      if (!filter) {
        return true;
      }
      if (
        entity.id.toUpperCase().indexOf(filter.toUpperCase()) !== -1 ||
        entity.tagName.toUpperCase().indexOf(filter.toUpperCase()) !== -1 ||
        entity.classList.contains(filter) ||
        entity.matches(filter)
      ) {
        return true;
      }
      return false;
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _classnames = __webpack_require__(16);
    var _classnames2 = _interopRequireDefault(_classnames);
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    var _utils = __webpack_require__(15);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var LOCALSTORAGE_MOCAP_UI = "aframeinspectormocapuienabled";
    function filterHelpers(scene, visible) {
      scene.traverse(function(o) {
        if (o.userData.source === "INSPECTOR") {
          o.visible = visible;
        }
      });
    }
    function getSceneName(scene) {
      return (
        scene.id || slugify(window.location.host + window.location.pathname)
      );
    }
    function slugify(text) {
      return text
        .toString()
        .toLowerCase()
        .replace(/\s+/g, "-")
        .replace(/[^\w\-]+/g, "-")
        .replace(/\-\-+/g, "-")
        .replace(/^-+/, "")
        .replace(/-+$/, "");
    }
    var Toolbar = (function(_React$Component) {
      _inherits(Toolbar, _React$Component);
      function Toolbar(props) {
        _classCallCheck(this, Toolbar);
        var _this = _possibleConstructorReturn(
          this,
          (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(
            this,
            props
          )
        );
        _this.writeChanges = function() {
          var xhr = new XMLHttpRequest();
          xhr.open("POST", "http://localhost:51234/save");
          xhr.onerror = function() {
            alert(
              "aframe-watcher not running. This feature requires a companion service running locally. npm install aframe-watcher to save changes back to file. Read more at supermedium.com/aframe-watcher"
            );
          };
          xhr.setRequestHeader("Content-Type", "application/json");
          xhr.send(JSON.stringify(AFRAME.INSPECTOR.history.updates));
        };
        _this.toggleScenePlaying = function() {
          if (_this.state.isPlaying) {
            AFRAME.scenes[0].pause();
            _this.setState({ isPlaying: false });
            AFRAME.scenes[0].isPlaying = true;
            document.getElementById("aframeInspectorMouseCursor").play();
            return;
          }
          AFRAME.scenes[0].isPlaying = false;
          AFRAME.scenes[0].play();
          _this.setState({ isPlaying: true });
        };
        _this.state = { isPlaying: false };
        return _this;
      }
      _createClass(Toolbar, [
        {
          key: "exportSceneToGLTF",
          value: function exportSceneToGLTF() {
            ga("send", "event", "SceneGraph", "exportGLTF");
            var sceneName = getSceneName(AFRAME.scenes[0]);
            var scene = AFRAME.scenes[0].object3D;
            filterHelpers(scene, false);
            AFRAME.INSPECTOR.exporters.gltf.parse(
              scene,
              function(buffer) {
                filterHelpers(scene, true);
                var blob = new Blob([buffer], {
                  type: "application/octet-stream"
                });
                (0, _utils.saveBlob)(blob, sceneName + ".glb");
              },
              { binary: true }
            );
          }
        },
        {
          key: "addEntity",
          value: function addEntity() {
            _Events2.default.emit("entitycreate", {
              element: "a-entity",
              components: {}
            });
          }
        },
        {
          key: "render",
          value: function render() {
            var watcherClassNames = (0, _classnames2.default)({
              button: true,
              fa: true,
              "fa-save": true
            });
            var watcherTitle = "Write changes with aframe-watcher.";
            return _react2.default.createElement(
              "div",
              { id: "toolbar" },
              _react2.default.createElement(
                "div",
                { className: "toolbarActions" },
                _react2.default.createElement("a", {
                  className: "button fa fa-plus",
                  title: "Add a new entity",
                  onClick: this.addEntity
                }),
                _react2.default.createElement("a", {
                  id: "playPauseScene",
                  className:
                    "button fa " +
                    (this.state.isPlaying ? "fa-pause" : "fa-play"),
                  title: this.state.isPlaying ? "Pause scene" : "Resume scene",
                  onClick: this.toggleScenePlaying
                }),
                _react2.default.createElement(
                  "a",
                  {
                    className: "gltfIcon",
                    title: "Export to GLTF",
                    onClick: this.exportSceneToGLTF
                  },
                  _react2.default.createElement("img", {
                    src: true
                      ? "https://aframe.io/aframe-inspector/assets/gltf.svg"
                      : "../assets/gltf.svg"
                  })
                ),
                _react2.default.createElement("a", {
                  className: watcherClassNames,
                  title: watcherTitle,
                  onClick: this.writeChanges
                })
              )
            );
          }
        }
      ]);
      return Toolbar;
    })(_react2.default.Component);
    exports.default = Toolbar;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _reactSelect = __webpack_require__(37);
    var _reactSelect2 = _interopRequireDefault(_reactSelect);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var Events = __webpack_require__(5);
    var classNames = __webpack_require__(16);
    var options = [
      {
        value: "perspective",
        event: "cameraperspectivetoggle",
        payload: null,
        label: "Perspective"
      },
      {
        value: "ortholeft",
        event: "cameraorthographictoggle",
        payload: "left",
        label: "Left View"
      },
      {
        value: "orthoright",
        event: "cameraorthographictoggle",
        payload: "right",
        label: "Right View"
      },
      {
        value: "orthotop",
        event: "cameraorthographictoggle",
        payload: "top",
        label: "Top View"
      },
      {
        value: "orthobottom",
        event: "cameraorthographictoggle",
        payload: "bottom",
        label: "Bottom View"
      },
      {
        value: "orthoback",
        event: "cameraorthographictoggle",
        payload: "back",
        label: "Back View"
      },
      {
        value: "orthofront",
        event: "cameraorthographictoggle",
        payload: "front",
        label: "Front View"
      }
    ];
    function getOption(value) {
      return options.filter(function(opt) {
        return opt.value === value;
      })[0];
    }
    var CameraToolbar = (function(_React$Component) {
      _inherits(CameraToolbar, _React$Component);
      function CameraToolbar(props) {
        _classCallCheck(this, CameraToolbar);
        var _this = _possibleConstructorReturn(
          this,
          (
            CameraToolbar.__proto__ || Object.getPrototypeOf(CameraToolbar)
          ).call(this, props)
        );
        _this.state = { selectedCamera: "perspective" };
        _this.justChangedCamera = false;
        return _this;
      }
      _createClass(CameraToolbar, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            Events.on("cameratoggle", function(data) {
              if (_this2.justChangedCamera) {
                _this2.justChangedCamera = false;
                return;
              }
              _this2.setState({ selectedCamera: data.value });
            });
          }
        },
        {
          key: "onChange",
          value: function onChange(option) {
            console.log(option);
            this.justChangedCamera = true;
            this.setState({ selectedCamera: option.value });
            Events.emit(option.event, option.payload);
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement(
              "div",
              { id: "cameraToolbar" },
              React.createElement(_reactSelect2.default, {
                id: "cameraSelect",
                classNamePrefix: "select",
                options: options,
                simpleValue: true,
                value: getOption(this.state.selectedCamera),
                isSearchable: false,
                onChange: this.onChange.bind(this)
              })
            );
          }
        }
      ]);
      return CameraToolbar;
    })(React.Component);
    exports.default = CameraToolbar;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var Events = __webpack_require__(5);
    var classNames = __webpack_require__(16);
    var TransformButtons = [
      { value: "translate", icon: "fa-arrows-alt" },
      { value: "rotate", icon: "fa-repeat" },
      { value: "scale", icon: "fa-expand" }
    ];
    var TransformToolbar = (function(_React$Component) {
      _inherits(TransformToolbar, _React$Component);
      function TransformToolbar(props) {
        _classCallCheck(this, TransformToolbar);
        var _this = _possibleConstructorReturn(
          this,
          (
            TransformToolbar.__proto__ ||
            Object.getPrototypeOf(TransformToolbar)
          ).call(this, props)
        );
        _this.changeTransformMode = function(mode) {
          _this.setState({ selectedTransform: mode });
          Events.emit("transformmodechange", mode);
          ga("send", "event", "Toolbar", "selectHelper", mode);
        };
        _this.onLocalChange = function(e) {
          var local = e.target.checked;
          _this.setState({ localSpace: local });
          Events.emit("transformspacechanged", local ? "local" : "world");
        };
        _this.renderTransformButtons = function() {
          return TransformButtons.map(
            function(option, i) {
              var _classNames;
              var selected = option.value === this.state.selectedTransform;
              var classes = classNames(
                ((_classNames = { button: true, fa: true }),
                _defineProperty(_classNames, option.icon, true),
                _defineProperty(_classNames, "active", selected),
                _classNames)
              );
              return React.createElement("a", {
                title: option.value,
                key: i,
                onClick: this.changeTransformMode.bind(this, option.value),
                className: classes
              });
            }.bind(_this)
          );
        };
        _this.state = { selectedTransform: "translate", localSpace: false };
        return _this;
      }
      _createClass(TransformToolbar, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            Events.on("transformmodechange", function(mode) {
              _this2.setState({ selectedTransform: mode });
            });
            Events.on("transformspacechange", function() {
              Events.emit(
                "transformspacechanged",
                _this2.state.localSpace ? "world" : "local"
              );
              _this2.setState({ localSpace: !_this2.state.localSpace });
            });
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement(
              "div",
              { id: "transformToolbar", className: "toolbarButtons" },
              this.renderTransformButtons(),
              React.createElement(
                "span",
                { className: "local-transform" },
                React.createElement("input", {
                  id: "local",
                  type: "checkbox",
                  title: "Toggle between local and world space transforms",
                  checked:
                    this.state.localSpace ||
                    this.state.selectedTransform === "scale",
                  disabled: this.state.selectedTransform === "scale",
                  onChange: this.onLocalChange
                }),
                React.createElement(
                  "label",
                  {
                    htmlFor: "local",
                    title: "Toggle between local and world space transforms"
                  },
                  "local"
                )
              )
            );
          }
        }
      ]);
      return TransformToolbar;
    })(React.Component);
    exports.default = TransformToolbar;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _entity = __webpack_require__(14);
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var React = __webpack_require__(1);
    var Events = __webpack_require__(5);
    var ViewportHUD = (function(_React$Component) {
      _inherits(ViewportHUD, _React$Component);
      function ViewportHUD(props) {
        _classCallCheck(this, ViewportHUD);
        var _this = _possibleConstructorReturn(
          this,
          (ViewportHUD.__proto__ || Object.getPrototypeOf(ViewportHUD)).call(
            this,
            props
          )
        );
        _this.state = { hoveredEntity: null, selectedEntity: null };
        return _this;
      }
      _createClass(ViewportHUD, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;
            Events.on("raycastermouseenter", function(el) {
              _this2.setState({ hoveredEntity: el });
            });
            Events.on("raycastermouseleave", function(el) {
              _this2.setState({ hoveredEntity: el });
            });
          }
        },
        {
          key: "render",
          value: function render() {
            return React.createElement(
              "div",
              { id: "viewportHud" },
              React.createElement(
                "p",
                null,
                (0, _entity.printEntity)(this.state.hoveredEntity)
              )
            );
          }
        }
      ]);
      return ViewportHUD;
    })(React.Component);
    exports.default = ViewportHUD;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
      BooleanWidget: __webpack_require__(61).default,
      ColorWidget: __webpack_require__(62).default,
      InputWidget: __webpack_require__(63).default,
      NumberWidget: __webpack_require__(23).default,
      SelectWidget: __webpack_require__(64).default,
      TextureWidget: __webpack_require__(65).default,
      Vec4Widget: __webpack_require__(68).default,
      Vec3Widget: __webpack_require__(67).default,
      Vec2Widget: __webpack_require__(66).default
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _lodash = __webpack_require__(24);
    var _lodash2 = _interopRequireDefault(_lodash);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    THREE.Box3.prototype.expandByObject = (function() {
      var scope, i, l;
      var v1 = new THREE.Vector3();
      function traverse(node) {
        var geometry = node.geometry;
        if (geometry !== undefined) {
          if (geometry.isGeometry) {
            var vertices = geometry.vertices;
            for (i = 0, l = vertices.length; i < l; i++) {
              v1.copy(vertices[i]);
              v1.applyMatrix4(node.matrixWorld);
              if (isNaN(v1.x) || isNaN(v1.y) || isNaN(v1.z)) {
                continue;
              }
              scope.expandByPoint(v1);
            }
          } else if (geometry.isBufferGeometry) {
            var attribute = geometry.attributes.position;
            if (attribute !== undefined) {
              for (i = 0, l = attribute.count; i < l; i++) {
                v1.fromBufferAttribute(attribute, i).applyMatrix4(
                  node.matrixWorld
                );
                if (isNaN(v1.x) || isNaN(v1.y) || isNaN(v1.z)) {
                  continue;
                }
                scope.expandByPoint(v1);
              }
            }
          }
        }
      }
      return function expandByObject(object) {
        scope = this;
        object.updateMatrixWorld(true);
        object.traverse(traverse);
        return this;
      };
    })();
    THREE.EditorControls = function(_object, domElement) {
      domElement = domElement !== undefined ? domElement : document;
      this.enabled = true;
      this.center = new THREE.Vector3();
      this.panSpeed = 0.001;
      this.zoomSpeed = 0.1;
      this.rotationSpeed = 0.005;
      var object = _object;
      var scope = this;
      var vector = new THREE.Vector3();
      var delta = new THREE.Vector3();
      var box = new THREE.Box3();
      var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
      var state = STATE.NONE;
      var center = this.center;
      var normalMatrix = new THREE.Matrix3();
      var pointer = new THREE.Vector2();
      var pointerOld = new THREE.Vector2();
      var spherical = new THREE.Spherical();
      var sphere = new THREE.Sphere();
      this.isOrthographic = false;
      this.rotationEnabled = true;
      this.setCamera = function(_object) {
        object = _object;
        if (object.type === "OrthographicCamera") {
          this.rotationEnabled = false;
          this.isOrthographic = true;
        } else {
          this.rotationEnabled = true;
          this.isOrthographic = false;
        }
      };
      this.setCamera(_object);
      var changeEvent = { type: "change" };
      this.dispatchChange = (0, _lodash2.default)(function() {
        scope.dispatchEvent(changeEvent);
      }, 100);
      this.focus = function(target) {
        var distance;
        box.setFromObject(target);
        if (box.isEmpty() === false && !isNaN(box.min.x)) {
          box.getCenter(center);
          distance = box.getBoundingSphere(sphere).radius;
        } else {
          center.setFromMatrixPosition(target.matrixWorld);
          distance = 0.1;
        }
        object.position.copy(
          target.localToWorld(new THREE.Vector3(0, 0, distance * 2))
        );
        object.lookAt(target.getWorldPosition(new THREE.Vector3()));
        scope.dispatchEvent(changeEvent);
      };
      this.pan = function(delta) {
        var distance;
        if (this.isOrthographic) {
          distance = Math.abs(object.right);
        } else {
          distance = object.position.distanceTo(center);
        }
        delta.multiplyScalar(distance * scope.panSpeed);
        delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
        object.position.add(delta);
        center.add(delta);
        scope.dispatchChange();
      };
      var ratio = 1;
      this.setAspectRatio = function(_ratio) {
        ratio = _ratio;
      };
      this.zoom = function(delta) {
        var distance = object.position.distanceTo(center);
        delta.multiplyScalar(distance * scope.zoomSpeed);
        if (delta.length() > distance) return;
        delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
        if (this.isOrthographic) {
          var factor = 1;
          if (delta.x + delta.y + delta.z < 0) {
            factor = -1;
          }
          delta = distance * scope.zoomSpeed * factor;
          object.left -= delta * ratio;
          object.bottom -= delta;
          object.right += delta * ratio;
          object.top += delta;
          if (object.left >= -0.0001) {
            return;
          }
          object.updateProjectionMatrix();
        } else {
          object.position.add(delta);
        }
        scope.dispatchChange();
      };
      this.rotate = function(delta) {
        if (!this.rotationEnabled) {
          return;
        }
        vector.copy(object.position).sub(center);
        spherical.setFromVector3(vector);
        spherical.theta += delta.x;
        spherical.phi += delta.y;
        spherical.makeSafe();
        vector.setFromSpherical(spherical);
        object.position.copy(center).add(vector);
        object.lookAt(center);
        scope.dispatchChange();
      };
      function onMouseDown(event) {
        if (scope.enabled === false) return;
        if (event.button === 0) {
          state = STATE.ROTATE;
        } else if (event.button === 1) {
          state = STATE.ZOOM;
        } else if (event.button === 2) {
          state = STATE.PAN;
        }
        pointerOld.set(event.clientX, event.clientY);
        domElement.addEventListener("mousemove", onMouseMove, false);
        domElement.addEventListener("mouseup", onMouseUp, false);
        domElement.addEventListener("mouseout", onMouseUp, false);
        domElement.addEventListener("dblclick", onMouseUp, false);
      }
      function onMouseMove(event) {
        if (scope.enabled === false) return;
        pointer.set(event.clientX, event.clientY);
        var movementX = pointer.x - pointerOld.x;
        var movementY = pointer.y - pointerOld.y;
        if (state === STATE.ROTATE) {
          scope.rotate(
            delta.set(
              -movementX * scope.rotationSpeed,
              -movementY * scope.rotationSpeed,
              0
            )
          );
        } else if (state === STATE.ZOOM) {
          scope.zoom(delta.set(0, 0, movementY));
        } else if (state === STATE.PAN) {
          scope.pan(delta.set(-movementX, movementY, 0));
        }
        pointerOld.set(event.clientX, event.clientY);
      }
      function onMouseUp(event) {
        domElement.removeEventListener("mousemove", onMouseMove, false);
        domElement.removeEventListener("mouseup", onMouseUp, false);
        domElement.removeEventListener("mouseout", onMouseUp, false);
        domElement.removeEventListener("dblclick", onMouseUp, false);
        state = STATE.NONE;
      }
      function onMouseWheel(event) {
        event.preventDefault();
        scope.zoom(delta.set(0, 0, event.deltaY > 0 ? 1 : -1));
      }
      function contextmenu(event) {
        event.preventDefault();
      }
      this.dispose = function() {
        domElement.removeEventListener("contextmenu", contextmenu, false);
        domElement.removeEventListener("mousedown", onMouseDown, false);
        domElement.removeEventListener("wheel", onMouseWheel, false);
        domElement.removeEventListener("mousemove", onMouseMove, false);
        domElement.removeEventListener("mouseup", onMouseUp, false);
        domElement.removeEventListener("mouseout", onMouseUp, false);
        domElement.removeEventListener("dblclick", onMouseUp, false);
        domElement.removeEventListener("touchstart", touchStart, false);
        domElement.removeEventListener("touchmove", touchMove, false);
      };
      domElement.addEventListener("contextmenu", contextmenu, false);
      domElement.addEventListener("mousedown", onMouseDown, false);
      domElement.addEventListener("wheel", onMouseWheel, false);
      var touches = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
      var prevTouches = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
      var prevDistance = null;
      function touchStart(event) {
        if (scope.enabled === false) return;
        switch (event.touches.length) {
          case 1:
            touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            break;
          case 2:
            touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
            prevDistance = touches[0].distanceTo(touches[1]);
            break;
        }
        prevTouches[0].copy(touches[0]);
        prevTouches[1].copy(touches[1]);
      }
      function touchMove(event) {
        if (scope.enabled === false) return;
        event.preventDefault();
        event.stopPropagation();
        function getClosest(touch, touches) {
          var closest = touches[0];
          for (var i in touches) {
            if (closest.distanceTo(touch) > touches[i].distanceTo(touch))
              closest = touches[i];
          }
          return closest;
        }
        switch (event.touches.length) {
          case 1:
            touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            scope.rotate(
              touches[0]
                .sub(getClosest(touches[0], prevTouches))
                .multiplyScalar(-scope.rotationSpeed)
            );
            break;
          case 2:
            touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
            touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
            var distance = touches[0].distanceTo(touches[1]);
            scope.zoom(delta.set(0, 0, prevDistance - distance));
            prevDistance = distance;
            var offset0 = touches[0]
              .clone()
              .sub(getClosest(touches[0], prevTouches));
            var offset1 = touches[1]
              .clone()
              .sub(getClosest(touches[1], prevTouches));
            offset0.x = -offset0.x;
            offset1.x = -offset1.x;
            scope.pan(offset0.add(offset1).multiplyScalar(0.5));
            break;
        }
        prevTouches[0].copy(touches[0]);
        prevTouches[1].copy(touches[1]);
      }
      domElement.addEventListener("touchstart", touchStart, false);
      domElement.addEventListener("touchmove", touchMove, false);
    };
    THREE.EditorControls.prototype = Object.create(
      THREE.EventDispatcher.prototype
    );
    THREE.EditorControls.prototype.constructor = THREE.EditorControls;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    (function() {
      "use strict";
      var GizmoMaterial = function GizmoMaterial(parameters) {
        THREE.MeshBasicMaterial.call(this);
        this.depthTest = false;
        this.depthWrite = false;
        this.fog = false;
        this.side = THREE.FrontSide;
        this.transparent = true;
        this.setValues(parameters);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(highlighted) {
          if (highlighted) {
            this.color.setRGB(1, 1, 0);
            this.opacity = 1;
          } else {
            this.color.copy(this.oldColor);
            this.opacity = this.oldOpacity;
          }
        };
      };
      GizmoMaterial.prototype = Object.create(
        THREE.MeshBasicMaterial.prototype
      );
      GizmoMaterial.prototype.constructor = GizmoMaterial;
      var GizmoLineMaterial = function GizmoLineMaterial(parameters) {
        THREE.LineBasicMaterial.call(this);
        this.depthTest = false;
        this.depthWrite = false;
        this.fog = false;
        this.transparent = true;
        this.linewidth = 1;
        this.setValues(parameters);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(highlighted) {
          if (highlighted) {
            this.color.setRGB(1, 1, 0);
            this.opacity = 1;
          } else {
            this.color.copy(this.oldColor);
            this.opacity = this.oldOpacity;
          }
        };
      };
      GizmoLineMaterial.prototype = Object.create(
        THREE.LineBasicMaterial.prototype
      );
      GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;
      var pickerMaterial = new GizmoMaterial({
        visible: false,
        transparent: false
      });
      THREE.TransformGizmo = function() {
        this.init = function() {
          THREE.Object3D.call(this);
          this.handles = new THREE.Object3D();
          this.pickers = new THREE.Object3D();
          this.planes = new THREE.Object3D();
          this.add(this.handles);
          this.add(this.pickers);
          this.add(this.planes);
          var planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);
          var planeMaterial = new THREE.MeshBasicMaterial({
            visible: false,
            side: THREE.DoubleSide
          });
          var planes = {
            XY: new THREE.Mesh(planeGeometry, planeMaterial),
            YZ: new THREE.Mesh(planeGeometry, planeMaterial),
            XZ: new THREE.Mesh(planeGeometry, planeMaterial),
            XYZE: new THREE.Mesh(planeGeometry, planeMaterial)
          };
          this.activePlane = planes["XYZE"];
          planes["YZ"].rotation.set(0, Math.PI / 2, 0);
          planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);
          for (var i in planes) {
            planes[i].name = i;
            this.planes.add(planes[i]);
            this.planes[i] = planes[i];
          }
          var setupGizmos = function setupGizmos(gizmoMap, parent) {
            for (var name in gizmoMap) {
              for (i = gizmoMap[name].length; i--; ) {
                var object = gizmoMap[name][i][0];
                var position = gizmoMap[name][i][1];
                var rotation = gizmoMap[name][i][2];
                object.name = name;
                object.renderOrder = Infinity;
                if (position)
                  object.position.set(position[0], position[1], position[2]);
                if (rotation)
                  object.rotation.set(rotation[0], rotation[1], rotation[2]);
                parent.add(object);
              }
            }
          };
          setupGizmos(this.handleGizmos, this.handles);
          setupGizmos(this.pickerGizmos, this.pickers);
          this.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.updateMatrix();
              var tempGeometry = child.geometry.clone();
              tempGeometry.applyMatrix(child.matrix);
              child.geometry = tempGeometry;
              child.position.set(0, 0, 0);
              child.rotation.set(0, 0, 0);
              child.scale.set(1, 1, 1);
            }
          });
        };
        this.highlight = function(axis) {
          this.traverse(function(child) {
            if (child.material && child.material.highlight) {
              if (child.name === axis) {
                child.material.highlight(true);
              } else {
                child.material.highlight(false);
              }
            }
          });
        };
      };
      THREE.TransformGizmo.prototype = Object.create(THREE.Object3D.prototype);
      THREE.TransformGizmo.prototype.constructor = THREE.TransformGizmo;
      THREE.TransformGizmo.prototype.update = function(rotation, eye) {
        var vec1 = new THREE.Vector3(0, 0, 0);
        var vec2 = new THREE.Vector3(0, 1, 0);
        var lookAtMatrix = new THREE.Matrix4();
        this.traverse(function(child) {
          if (child.name.search("E") !== -1) {
            child.quaternion.setFromRotationMatrix(
              lookAtMatrix.lookAt(eye, vec1, vec2)
            );
          } else if (
            child.name.search("X") !== -1 ||
            child.name.search("Y") !== -1 ||
            child.name.search("Z") !== -1
          ) {
            child.quaternion.setFromEuler(rotation);
          }
        });
      };
      THREE.TransformGizmoTranslate = function() {
        THREE.TransformGizmo.call(this);
        var arrowGeometry = new THREE.ConeBufferGeometry(
          0.05,
          0.2,
          12,
          1,
          false
        );
        arrowGeometry.translate(0, 0.5, 0);
        var lineXGeometry = new THREE.BufferGeometry();
        lineXGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3)
        );
        var lineYGeometry = new THREE.BufferGeometry();
        lineYGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        );
        var lineZGeometry = new THREE.BufferGeometry();
        lineZGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
        );
        this.handleGizmos = {
          X: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0xff0000 })
              ),
              [0.5, 0, 0],
              [0, 0, -Math.PI / 2]
            ],
            [
              new THREE.Line(
                lineXGeometry,
                new GizmoLineMaterial({ color: 0xff0000 })
              )
            ]
          ],
          Y: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0x00ff00 })
              ),
              [0, 0.5, 0]
            ],
            [
              new THREE.Line(
                lineYGeometry,
                new GizmoLineMaterial({ color: 0x00ff00 })
              )
            ]
          ],
          Z: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0x0000ff })
              ),
              [0, 0, 0.5],
              [Math.PI / 2, 0, 0]
            ],
            [
              new THREE.Line(
                lineZGeometry,
                new GizmoLineMaterial({ color: 0x0000ff })
              )
            ]
          ],
          XYZ: [
            [
              new THREE.Mesh(
                new THREE.OctahedronGeometry(0.1, 0),
                new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })
              ),
              [0, 0, 0],
              [0, 0, 0]
            ]
          ],
          XY: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.29, 0.29),
                new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })
              ),
              [0.15, 0.15, 0]
            ]
          ],
          YZ: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.29, 0.29),
                new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })
              ),
              [0, 0.15, 0.15],
              [0, Math.PI / 2, 0]
            ]
          ],
          XZ: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.29, 0.29),
                new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })
              ),
              [0.15, 0, 0.15],
              [-Math.PI / 2, 0, 0]
            ]
          ]
        };
        this.pickerGizmos = {
          X: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0.6, 0, 0],
              [0, 0, -Math.PI / 2]
            ]
          ],
          Y: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0, 0.6, 0]
            ]
          ],
          Z: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0, 0, 0.6],
              [Math.PI / 2, 0, 0]
            ]
          ],
          XYZ: [
            [
              new THREE.Mesh(
                new THREE.OctahedronGeometry(0.2, 0),
                pickerMaterial
              )
            ]
          ],
          XY: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.4, 0.4),
                pickerMaterial
              ),
              [0.2, 0.2, 0]
            ]
          ],
          YZ: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.4, 0.4),
                pickerMaterial
              ),
              [0, 0.2, 0.2],
              [0, Math.PI / 2, 0]
            ]
          ],
          XZ: [
            [
              new THREE.Mesh(
                new THREE.PlaneBufferGeometry(0.4, 0.4),
                pickerMaterial
              ),
              [0.2, 0, 0.2],
              [-Math.PI / 2, 0, 0]
            ]
          ]
        };
        this.setActivePlane = function(axis, eye) {
          var tempMatrix = new THREE.Matrix4();
          eye.applyMatrix4(
            tempMatrix.getInverse(
              tempMatrix.extractRotation(this.planes["XY"].matrixWorld)
            )
          );
          if (axis === "X") {
            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.y) > Math.abs(eye.z))
              this.activePlane = this.planes["XZ"];
          }
          if (axis === "Y") {
            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.x) > Math.abs(eye.z))
              this.activePlane = this.planes["YZ"];
          }
          if (axis === "Z") {
            this.activePlane = this.planes["XZ"];
            if (Math.abs(eye.x) > Math.abs(eye.y))
              this.activePlane = this.planes["YZ"];
          }
          if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
          if (axis === "XY") this.activePlane = this.planes["XY"];
          if (axis === "YZ") this.activePlane = this.planes["YZ"];
          if (axis === "XZ") this.activePlane = this.planes["XZ"];
        };
        this.init();
      };
      THREE.TransformGizmoTranslate.prototype = Object.create(
        THREE.TransformGizmo.prototype
      );
      THREE.TransformGizmoTranslate.prototype.constructor =
        THREE.TransformGizmoTranslate;
      THREE.TransformGizmoRotate = function() {
        THREE.TransformGizmo.call(this);
        var CircleGeometry = function CircleGeometry(radius, facing, arc) {
          var geometry = new THREE.BufferGeometry();
          var vertices = [];
          arc = arc ? arc : 1;
          for (var i = 0; i <= 64 * arc; ++i) {
            if (facing === "x")
              vertices.push(
                0,
                Math.cos((i / 32) * Math.PI) * radius,
                Math.sin((i / 32) * Math.PI) * radius
              );
            if (facing === "y")
              vertices.push(
                Math.cos((i / 32) * Math.PI) * radius,
                0,
                Math.sin((i / 32) * Math.PI) * radius
              );
            if (facing === "z")
              vertices.push(
                Math.sin((i / 32) * Math.PI) * radius,
                Math.cos((i / 32) * Math.PI) * radius,
                0
              );
          }
          geometry.addAttribute(
            "position",
            new THREE.Float32BufferAttribute(vertices, 3)
          );
          return geometry;
        };
        this.handleGizmos = {
          X: [
            [
              new THREE.Line(
                new CircleGeometry(1, "x", 0.5),
                new GizmoLineMaterial({ color: 0xff0000 })
              )
            ]
          ],
          Y: [
            [
              new THREE.Line(
                new CircleGeometry(1, "y", 0.5),
                new GizmoLineMaterial({ color: 0x00ff00 })
              )
            ]
          ],
          Z: [
            [
              new THREE.Line(
                new CircleGeometry(1, "z", 0.5),
                new GizmoLineMaterial({ color: 0x0000ff })
              )
            ]
          ],
          E: [
            [
              new THREE.Line(
                new CircleGeometry(1.25, "z", 1),
                new GizmoLineMaterial({ color: 0xcccc00 })
              )
            ]
          ],
          XYZE: [
            [
              new THREE.Line(
                new CircleGeometry(1, "z", 1),
                new GizmoLineMaterial({ color: 0x787878 })
              )
            ]
          ]
        };
        this.pickerGizmos = {
          X: [
            [
              new THREE.Mesh(
                new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI),
                pickerMaterial
              ),
              [0, 0, 0],
              [0, -Math.PI / 2, -Math.PI / 2]
            ]
          ],
          Y: [
            [
              new THREE.Mesh(
                new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI),
                pickerMaterial
              ),
              [0, 0, 0],
              [Math.PI / 2, 0, 0]
            ]
          ],
          Z: [
            [
              new THREE.Mesh(
                new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI),
                pickerMaterial
              ),
              [0, 0, 0],
              [0, 0, -Math.PI / 2]
            ]
          ],
          E: [
            [
              new THREE.Mesh(
                new THREE.TorusBufferGeometry(1.25, 0.12, 2, 24),
                pickerMaterial
              )
            ]
          ],
          XYZE: [
            [
              new THREE.Mesh(
                new THREE.TorusBufferGeometry(1, 0.12, 2, 24),
                pickerMaterial
              )
            ]
          ]
        };
        this.pickerGizmos.XYZE[0][0].visible = false;
        this.setActivePlane = function(axis) {
          if (axis === "E") this.activePlane = this.planes["XYZE"];
          if (axis === "X") this.activePlane = this.planes["YZ"];
          if (axis === "Y") this.activePlane = this.planes["XZ"];
          if (axis === "Z") this.activePlane = this.planes["XY"];
        };
        this.update = function(rotation, eye2) {
          THREE.TransformGizmo.prototype.update.apply(this, arguments);
          var tempMatrix = new THREE.Matrix4();
          var worldRotation = new THREE.Euler(0, 0, 1);
          var tempQuaternion = new THREE.Quaternion();
          var unitX = new THREE.Vector3(1, 0, 0);
          var unitY = new THREE.Vector3(0, 1, 0);
          var unitZ = new THREE.Vector3(0, 0, 1);
          var quaternionX = new THREE.Quaternion();
          var quaternionY = new THREE.Quaternion();
          var quaternionZ = new THREE.Quaternion();
          var eye = eye2.clone();
          worldRotation.copy(this.planes["XY"].rotation);
          tempQuaternion.setFromEuler(worldRotation);
          tempMatrix
            .makeRotationFromQuaternion(tempQuaternion)
            .getInverse(tempMatrix);
          eye.applyMatrix4(tempMatrix);
          this.traverse(function(child) {
            tempQuaternion.setFromEuler(worldRotation);
            if (child.name === "X") {
              quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
              child.quaternion.copy(tempQuaternion);
            }
            if (child.name === "Y") {
              quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
              child.quaternion.copy(tempQuaternion);
            }
            if (child.name === "Z") {
              quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
              child.quaternion.copy(tempQuaternion);
            }
          });
        };
        this.init();
      };
      THREE.TransformGizmoRotate.prototype = Object.create(
        THREE.TransformGizmo.prototype
      );
      THREE.TransformGizmoRotate.prototype.constructor =
        THREE.TransformGizmoRotate;
      THREE.TransformGizmoScale = function() {
        THREE.TransformGizmo.call(this);
        var arrowGeometry = new THREE.BoxBufferGeometry(0.125, 0.125, 0.125);
        arrowGeometry.translate(0, 0.5, 0);
        var lineXGeometry = new THREE.BufferGeometry();
        lineXGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3)
        );
        var lineYGeometry = new THREE.BufferGeometry();
        lineYGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        );
        var lineZGeometry = new THREE.BufferGeometry();
        lineZGeometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
        );
        this.handleGizmos = {
          X: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0xff0000 })
              ),
              [0.5, 0, 0],
              [0, 0, -Math.PI / 2]
            ],
            [
              new THREE.Line(
                lineXGeometry,
                new GizmoLineMaterial({ color: 0xff0000 })
              )
            ]
          ],
          Y: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0x00ff00 })
              ),
              [0, 0.5, 0]
            ],
            [
              new THREE.Line(
                lineYGeometry,
                new GizmoLineMaterial({ color: 0x00ff00 })
              )
            ]
          ],
          Z: [
            [
              new THREE.Mesh(
                arrowGeometry,
                new GizmoMaterial({ color: 0x0000ff })
              ),
              [0, 0, 0.5],
              [Math.PI / 2, 0, 0]
            ],
            [
              new THREE.Line(
                lineZGeometry,
                new GizmoLineMaterial({ color: 0x0000ff })
              )
            ]
          ],
          XYZ: [
            [
              new THREE.Mesh(
                new THREE.BoxBufferGeometry(0.125, 0.125, 0.125),
                new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })
              )
            ]
          ]
        };
        this.pickerGizmos = {
          X: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0.6, 0, 0],
              [0, 0, -Math.PI / 2]
            ]
          ],
          Y: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0, 0.6, 0]
            ]
          ],
          Z: [
            [
              new THREE.Mesh(
                new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false),
                pickerMaterial
              ),
              [0, 0, 0.6],
              [Math.PI / 2, 0, 0]
            ]
          ],
          XYZ: [
            [
              new THREE.Mesh(
                new THREE.BoxBufferGeometry(0.4, 0.4, 0.4),
                pickerMaterial
              )
            ]
          ]
        };
        this.setActivePlane = function(axis, eye) {
          var tempMatrix = new THREE.Matrix4();
          eye.applyMatrix4(
            tempMatrix.getInverse(
              tempMatrix.extractRotation(this.planes["XY"].matrixWorld)
            )
          );
          if (axis === "X") {
            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.y) > Math.abs(eye.z))
              this.activePlane = this.planes["XZ"];
          }
          if (axis === "Y") {
            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.x) > Math.abs(eye.z))
              this.activePlane = this.planes["YZ"];
          }
          if (axis === "Z") {
            this.activePlane = this.planes["XZ"];
            if (Math.abs(eye.x) > Math.abs(eye.y))
              this.activePlane = this.planes["YZ"];
          }
          if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
        };
        this.init();
      };
      THREE.TransformGizmoScale.prototype = Object.create(
        THREE.TransformGizmo.prototype
      );
      THREE.TransformGizmoScale.prototype.constructor =
        THREE.TransformGizmoScale;
      THREE.TransformControls = function(_camera, domElement) {
        THREE.Object3D.call(this);
        domElement = domElement !== undefined ? domElement : document;
        this.object = undefined;
        this.visible = false;
        this.translationSnap = null;
        this.rotationSnap = null;
        this.space = "world";
        this.size = 1;
        this.axis = null;
        var camera = _camera;
        var scope = this;
        var _mode = "translate";
        var _dragging = false;
        var _gizmo = {
          translate: new THREE.TransformGizmoTranslate(),
          rotate: new THREE.TransformGizmoRotate(),
          scale: new THREE.TransformGizmoScale()
        };
        for (var type in _gizmo) {
          var gizmoObj = _gizmo[type];
          gizmoObj.visible = type === _mode;
          this.add(gizmoObj);
        }
        var changeEvent = { type: "change" };
        var mouseDownEvent = { type: "mouseDown" };
        var mouseUpEvent = { type: "mouseUp", mode: _mode };
        var objectChangeEvent = { type: "objectChange" };
        var ray = new THREE.Raycaster();
        var pointerVector = new THREE.Vector2();
        var point = new THREE.Vector3();
        var offset = new THREE.Vector3();
        var rotation = new THREE.Vector3();
        var offsetRotation = new THREE.Vector3();
        var scale = 1;
        var lookAtMatrix = new THREE.Matrix4();
        var eye = new THREE.Vector3();
        var tempMatrix = new THREE.Matrix4();
        var tempVector = new THREE.Vector3();
        var tempQuaternion = new THREE.Quaternion();
        var unitX = new THREE.Vector3(1, 0, 0);
        var unitY = new THREE.Vector3(0, 1, 0);
        var unitZ = new THREE.Vector3(0, 0, 1);
        var quaternionXYZ = new THREE.Quaternion();
        var quaternionX = new THREE.Quaternion();
        var quaternionY = new THREE.Quaternion();
        var quaternionZ = new THREE.Quaternion();
        var quaternionE = new THREE.Quaternion();
        var oldPosition = new THREE.Vector3();
        var oldScale = new THREE.Vector3();
        var oldRotationMatrix = new THREE.Matrix4();
        var parentRotationMatrix = new THREE.Matrix4();
        var parentScale = new THREE.Vector3();
        var worldPosition = new THREE.Vector3();
        var worldRotation = new THREE.Euler();
        var worldRotationMatrix = new THREE.Matrix4();
        var camPosition = new THREE.Vector3();
        var camRotation = new THREE.Euler();
        this.setCamera = function(_camera) {
          camera = _camera;
        };
        this.activate = function() {
          domElement.addEventListener("mousedown", onPointerDown, false);
          domElement.addEventListener("touchstart", onPointerDown, false);
          domElement.addEventListener("mousemove", onPointerHover, false);
          domElement.addEventListener("touchmove", onPointerHover, false);
          domElement.addEventListener("mousemove", onPointerMove, false);
          domElement.addEventListener("touchmove", onPointerMove, false);
          domElement.addEventListener("mouseup", onPointerUp, false);
          domElement.addEventListener("mouseout", onPointerUp, false);
          domElement.addEventListener("touchend", onPointerUp, false);
          domElement.addEventListener("touchcancel", onPointerUp, false);
          domElement.addEventListener("touchleave", onPointerUp, false);
        };
        this.activate();
        this.dispose = function() {
          domElement.removeEventListener("mousedown", onPointerDown);
          domElement.removeEventListener("touchstart", onPointerDown);
          domElement.removeEventListener("mousemove", onPointerHover);
          domElement.removeEventListener("touchmove", onPointerHover);
          domElement.removeEventListener("mousemove", onPointerMove);
          domElement.removeEventListener("touchmove", onPointerMove);
          domElement.removeEventListener("mouseup", onPointerUp);
          domElement.removeEventListener("mouseout", onPointerUp);
          domElement.removeEventListener("touchend", onPointerUp);
          domElement.removeEventListener("touchcancel", onPointerUp);
          domElement.removeEventListener("touchleave", onPointerUp);
        };
        this.attach = function(object) {
          this.object = object;
          this.visible = true;
          this.update(true);
        };
        this.detach = function() {
          this.object = undefined;
          this.visible = false;
          this.axis = null;
        };
        this.getMode = function() {
          return _mode;
        };
        this.setMode = function(mode) {
          _mode = mode ? mode : _mode;
          if (_mode === "scale") scope.space = "local";
          for (var type in _gizmo) {
            _gizmo[type].visible = type === _mode;
          }
          this.update();
          scope.dispatchEvent(changeEvent);
        };
        this.setTranslationSnap = function(translationSnap) {
          scope.translationSnap = translationSnap;
        };
        this.setRotationSnap = function(rotationSnap) {
          scope.rotationSnap = rotationSnap;
        };
        this.setSize = function(size) {
          scope.size = size;
          this.update(true);
          scope.dispatchEvent(changeEvent);
        };
        this.setSpace = function(space) {
          scope.space = space;
          this.update();
          scope.dispatchEvent(changeEvent);
        };
        this.update = function(updateScale) {
          if (scope.object === undefined) return;
          scope.object.updateMatrixWorld();
          worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
          worldRotation.setFromRotationMatrix(
            tempMatrix.extractRotation(scope.object.matrixWorld)
          );
          camera.updateMatrixWorld();
          camPosition.setFromMatrixPosition(camera.matrixWorld);
          camRotation.setFromRotationMatrix(
            tempMatrix.extractRotation(camera.matrixWorld)
          );
          scale = (worldPosition.distanceTo(camPosition) / 6) * scope.size;
          this.position.copy(worldPosition);
          if (updateScale) {
            this.scale.set(scale, scale, scale);
          }
          if (camera instanceof THREE.PerspectiveCamera) {
            eye
              .copy(camPosition)
              .sub(worldPosition)
              .normalize();
          } else if (camera instanceof THREE.OrthographicCamera) {
            eye.copy(camPosition).normalize();
          }
          if (scope.space === "local") {
            _gizmo[_mode].update(worldRotation, eye);
          } else if (scope.space === "world") {
            _gizmo[_mode].update(new THREE.Euler(), eye);
          }
          _gizmo[_mode].highlight(scope.axis);
        };
        function onPointerHover(event) {
          if (
            scope.object === undefined ||
            _dragging === true ||
            (event.button !== undefined && event.button !== 0)
          )
            return;
          var pointer = event.changedTouches ? event.changedTouches[0] : event;
          var intersect = intersectObjects(
            pointer,
            _gizmo[_mode].pickers.children
          );
          var axis = null;
          if (intersect) {
            axis = intersect.object.name;
            event.preventDefault();
          }
          if (scope.axis !== axis) {
            scope.axis = axis;
            scope.update();
            scope.dispatchEvent(changeEvent);
          }
        }
        function onPointerDown(event) {
          if (
            scope.object === undefined ||
            _dragging === true ||
            (event.button !== undefined && event.button !== 0)
          )
            return;
          var pointer = event.changedTouches ? event.changedTouches[0] : event;
          if (pointer.button === 0 || pointer.button === undefined) {
            var intersect = intersectObjects(
              pointer,
              _gizmo[_mode].pickers.children
            );
            if (intersect) {
              event.preventDefault();
              event.stopPropagation();
              scope.axis = intersect.object.name;
              scope.dispatchEvent(mouseDownEvent);
              scope.update();
              eye
                .copy(camPosition)
                .sub(worldPosition)
                .normalize();
              _gizmo[_mode].setActivePlane(scope.axis, eye);
              var planeIntersect = intersectObjects(pointer, [
                _gizmo[_mode].activePlane
              ]);
              if (planeIntersect) {
                oldPosition.copy(scope.object.position);
                oldScale.copy(scope.object.scale);
                oldRotationMatrix.extractRotation(scope.object.matrix);
                worldRotationMatrix.extractRotation(scope.object.matrixWorld);
                parentRotationMatrix.extractRotation(
                  scope.object.parent.matrixWorld
                );
                parentScale.setFromMatrixScale(
                  tempMatrix.getInverse(scope.object.parent.matrixWorld)
                );
                offset.copy(planeIntersect.point);
              }
            }
          }
          _dragging = true;
        }
        function onPointerMove(event) {
          if (
            scope.object === undefined ||
            scope.axis === null ||
            _dragging === false ||
            (event.button !== undefined && event.button !== 0)
          )
            return;
          var pointer = event.changedTouches ? event.changedTouches[0] : event;
          var planeIntersect = intersectObjects(pointer, [
            _gizmo[_mode].activePlane
          ]);
          if (planeIntersect === false) return;
          event.preventDefault();
          event.stopPropagation();
          point.copy(planeIntersect.point);
          if (_mode === "translate") {
            point.sub(offset);
            point.multiply(parentScale);
            if (scope.space === "local") {
              point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
              if (scope.axis.search("X") === -1) point.x = 0;
              if (scope.axis.search("Y") === -1) point.y = 0;
              if (scope.axis.search("Z") === -1) point.z = 0;
              point.applyMatrix4(oldRotationMatrix);
              scope.object.position.copy(oldPosition);
              scope.object.position.add(point);
            }
            if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {
              if (scope.axis.search("X") === -1) point.x = 0;
              if (scope.axis.search("Y") === -1) point.y = 0;
              if (scope.axis.search("Z") === -1) point.z = 0;
              point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));
              scope.object.position.copy(oldPosition);
              scope.object.position.add(point);
            }
            if (scope.translationSnap !== null) {
              if (scope.space === "local") {
                scope.object.position.applyMatrix4(
                  tempMatrix.getInverse(worldRotationMatrix)
                );
              }
              if (scope.axis.search("X") !== -1)
                scope.object.position.x =
                  Math.round(scope.object.position.x / scope.translationSnap) *
                  scope.translationSnap;
              if (scope.axis.search("Y") !== -1)
                scope.object.position.y =
                  Math.round(scope.object.position.y / scope.translationSnap) *
                  scope.translationSnap;
              if (scope.axis.search("Z") !== -1)
                scope.object.position.z =
                  Math.round(scope.object.position.z / scope.translationSnap) *
                  scope.translationSnap;
              if (scope.space === "local") {
                scope.object.position.applyMatrix4(worldRotationMatrix);
              }
            }
          } else if (_mode === "scale") {
            point.sub(offset);
            point.multiply(parentScale);
            if (scope.space === "local") {
              if (scope.axis === "XYZ") {
                scale =
                  1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);
                scope.object.scale.x = oldScale.x * scale;
                scope.object.scale.y = oldScale.y * scale;
                scope.object.scale.z = oldScale.z * scale;
              } else {
                point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                if (scope.axis === "X")
                  scope.object.scale.x =
                    oldScale.x * (1 + point.x / oldScale.x);
                if (scope.axis === "Y")
                  scope.object.scale.y =
                    oldScale.y * (1 + point.y / oldScale.y);
                if (scope.axis === "Z")
                  scope.object.scale.z =
                    oldScale.z * (1 + point.z / oldScale.z);
              }
            }
          } else if (_mode === "rotate") {
            point.sub(worldPosition);
            point.multiply(parentScale);
            tempVector.copy(offset).sub(worldPosition);
            tempVector.multiply(parentScale);
            if (scope.axis === "E") {
              point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
              tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
              rotation.set(
                Math.atan2(point.z, point.y),
                Math.atan2(point.x, point.z),
                Math.atan2(point.y, point.x)
              );
              offsetRotation.set(
                Math.atan2(tempVector.z, tempVector.y),
                Math.atan2(tempVector.x, tempVector.z),
                Math.atan2(tempVector.y, tempVector.x)
              );
              tempQuaternion.setFromRotationMatrix(
                tempMatrix.getInverse(parentRotationMatrix)
              );
              quaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);
              quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
              scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.axis === "XYZE") {
              quaternionE.setFromEuler(
                point
                  .clone()
                  .cross(tempVector)
                  .normalize()
              );
              tempQuaternion.setFromRotationMatrix(
                tempMatrix.getInverse(parentRotationMatrix)
              );
              quaternionX.setFromAxisAngle(
                quaternionE,
                -point.clone().angleTo(tempVector)
              );
              quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
              scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.space === "local") {
              point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
              tempVector.applyMatrix4(
                tempMatrix.getInverse(worldRotationMatrix)
              );
              rotation.set(
                Math.atan2(point.z, point.y),
                Math.atan2(point.x, point.z),
                Math.atan2(point.y, point.x)
              );
              offsetRotation.set(
                Math.atan2(tempVector.z, tempVector.y),
                Math.atan2(tempVector.x, tempVector.z),
                Math.atan2(tempVector.y, tempVector.x)
              );
              quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);
              if (scope.rotationSnap !== null) {
                quaternionX.setFromAxisAngle(
                  unitX,
                  Math.round(
                    (rotation.x - offsetRotation.x) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
                quaternionY.setFromAxisAngle(
                  unitY,
                  Math.round(
                    (rotation.y - offsetRotation.y) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
                quaternionZ.setFromAxisAngle(
                  unitZ,
                  Math.round(
                    (rotation.z - offsetRotation.z) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
              } else {
                quaternionX.setFromAxisAngle(
                  unitX,
                  rotation.x - offsetRotation.x
                );
                quaternionY.setFromAxisAngle(
                  unitY,
                  rotation.y - offsetRotation.y
                );
                quaternionZ.setFromAxisAngle(
                  unitZ,
                  rotation.z - offsetRotation.z
                );
              }
              if (scope.axis === "X")
                quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
              if (scope.axis === "Y")
                quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
              if (scope.axis === "Z")
                quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);
              scope.object.quaternion.copy(quaternionXYZ);
            } else if (scope.space === "world") {
              rotation.set(
                Math.atan2(point.z, point.y),
                Math.atan2(point.x, point.z),
                Math.atan2(point.y, point.x)
              );
              offsetRotation.set(
                Math.atan2(tempVector.z, tempVector.y),
                Math.atan2(tempVector.x, tempVector.z),
                Math.atan2(tempVector.y, tempVector.x)
              );
              tempQuaternion.setFromRotationMatrix(
                tempMatrix.getInverse(parentRotationMatrix)
              );
              if (scope.rotationSnap !== null) {
                quaternionX.setFromAxisAngle(
                  unitX,
                  Math.round(
                    (rotation.x - offsetRotation.x) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
                quaternionY.setFromAxisAngle(
                  unitY,
                  Math.round(
                    (rotation.y - offsetRotation.y) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
                quaternionZ.setFromAxisAngle(
                  unitZ,
                  Math.round(
                    (rotation.z - offsetRotation.z) / scope.rotationSnap
                  ) * scope.rotationSnap
                );
              } else {
                quaternionX.setFromAxisAngle(
                  unitX,
                  rotation.x - offsetRotation.x
                );
                quaternionY.setFromAxisAngle(
                  unitY,
                  rotation.y - offsetRotation.y
                );
                quaternionZ.setFromAxisAngle(
                  unitZ,
                  rotation.z - offsetRotation.z
                );
              }
              quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
              if (scope.axis === "X")
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
              if (scope.axis === "Y")
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
              if (scope.axis === "Z")
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
              tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
              scope.object.quaternion.copy(tempQuaternion);
            }
          }
          if (_mode === "translate") {
            scope.object.position.x = parseFloat(
              scope.object.position.x.toFixed(5)
            );
            scope.object.position.y = parseFloat(
              scope.object.position.y.toFixed(5)
            );
            scope.object.position.z = parseFloat(
              scope.object.position.z.toFixed(5)
            );
          } else if (_mode === "rotate") {
            scope.object.rotation.x = parseFloat(
              scope.object.rotation.x.toFixed(5)
            );
            scope.object.rotation.y = parseFloat(
              scope.object.rotation.y.toFixed(5)
            );
            scope.object.rotation.z = parseFloat(
              scope.object.rotation.z.toFixed(5)
            );
          } else {
            scope.object.scale.x = parseFloat(scope.object.scale.x.toFixed(5));
            scope.object.scale.y = parseFloat(scope.object.scale.y.toFixed(5));
            scope.object.scale.z = parseFloat(scope.object.scale.z.toFixed(5));
          }
          scope.update();
          scope.dispatchEvent(changeEvent);
          objectChangeEvent.mode = _mode;
          scope.dispatchEvent(objectChangeEvent);
        }
        function onPointerUp(event) {
          event.preventDefault();
          if (event.button !== undefined && event.button !== 0) return;
          if (_dragging && scope.axis !== null) {
            mouseUpEvent.mode = _mode;
            scope.dispatchEvent(mouseUpEvent);
          }
          _dragging = false;
          if ("TouchEvent" in window && event instanceof TouchEvent) {
            scope.axis = null;
            scope.update();
            scope.dispatchEvent(changeEvent);
          } else {
            onPointerHover(event);
          }
        }
        function intersectObjects(pointer, objects) {
          var rect = domElement.getBoundingClientRect();
          var x = (pointer.clientX - rect.left) / rect.width;
          var y = (pointer.clientY - rect.top) / rect.height;
          pointerVector.set(x * 2 - 1, -(y * 2) + 1);
          ray.setFromCamera(pointerVector, camera);
          var intersections = ray.intersectObjects(objects, true);
          return intersections[0] ? intersections[0] : false;
        }
      };
      THREE.TransformControls.prototype = Object.create(
        THREE.Object3D.prototype
      );
      THREE.TransformControls.prototype.constructor = THREE.TransformControls;
    })();
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var assetsBaseUrl = "https://aframe.io/sample-assets/";
    var assetsRelativeUrl = { images: "dist/images.json" };
    function AssetsLoader() {
      this.images = [];
      this.hasLoaded = false;
    }
    AssetsLoader.prototype = {
      load: function load() {
        var _this = this;
        var xhr = new XMLHttpRequest();
        var url = assetsBaseUrl + assetsRelativeUrl["images"];
        xhr.open("GET", url);
        xhr.onload = function() {
          var data = JSON.parse(xhr.responseText);
          _this.images = data.images;
          _this.images.forEach(function(image) {
            image.fullPath = assetsBaseUrl + data.basepath.images + image.path;
            image.fullThumbPath =
              assetsBaseUrl + data.basepath.images_thumbnails + image.thumbnail;
          });
          _Events2.default.emit("assetsimagesload", _this.images);
        };
        xhr.onerror = function() {
          console.error("Error loading registry file.");
        };
        xhr.send();
        this.hasLoaded = true;
      }
    };
    module.exports = AssetsLoader;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function insertNewAsset(
      type,
      id,
      src,
      anonymousCrossOrigin,
      onLoadedCallback
    ) {
      var element = null;
      switch (type) {
        case "img":
          {
            element = document.createElement("img");
            element.id = id;
            element.src = src;
            if (anonymousCrossOrigin) {
              element.crossOrigin = "anonymous";
            }
          }
          break;
      }
      if (element) {
        element.onload = function() {
          if (onLoadedCallback) {
            onLoadedCallback();
          }
        };
        document.getElementsByTagName("a-assets")[0].appendChild(element);
      }
    }
    module.exports = { insertNewAsset: insertNewAsset };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initCameras = initCameras;
    var _Events = __webpack_require__(5);
    var _Events2 = _interopRequireDefault(_Events);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var currentOrthoDir = "";
    var orthoCameraMemory = {
      left: {
        position: new THREE.Vector3(-10, 0, 0),
        rotation: new THREE.Euler()
      },
      right: {
        position: new THREE.Vector3(10, 0, 0),
        rotation: new THREE.Euler()
      },
      top: {
        position: new THREE.Vector3(0, 10, 0),
        rotation: new THREE.Euler()
      },
      bottom: {
        position: new THREE.Vector3(0, -10, 0),
        rotation: new THREE.Euler()
      },
      back: {
        position: new THREE.Vector3(0, 0, -10),
        rotation: new THREE.Euler()
      },
      front: {
        position: new THREE.Vector3(0, 0, 10),
        rotation: new THREE.Euler()
      }
    };
    function initCameras(inspector) {
      var sceneEl = inspector.sceneEl;
      var originalCamera = (inspector.currentCameraEl = sceneEl.camera.el);
      inspector.currentCameraEl.setAttribute(
        "data-aframe-inspector-original-camera",
        ""
      );
      if (
        inspector.currentCameraEl.hasAttribute("data-aframe-default-camera")
      ) {
        inspector.currentCameraEl.removeAttribute("data-aframe-default-camera");
        inspector.currentCameraEl.setAttribute(
          "data-aframe-inspector",
          "default-camera"
        );
      }
      inspector.currentCameraEl.setAttribute("camera", "active", false);
      var perspectiveCamera = (inspector.camera = new THREE.PerspectiveCamera());
      perspectiveCamera.far = 10000;
      perspectiveCamera.near = 0.01;
      perspectiveCamera.position.set(0, 1.6, 2);
      perspectiveCamera.lookAt(new THREE.Vector3(0, 1.6, -1));
      perspectiveCamera.updateMatrixWorld();
      sceneEl.object3D.add(perspectiveCamera);
      sceneEl.camera = perspectiveCamera;
      var ratio = sceneEl.canvas.width / sceneEl.canvas.height;
      var orthoCamera = new THREE.OrthographicCamera(
        -10 * ratio,
        10 * ratio,
        10,
        -10
      );
      sceneEl.object3D.add(orthoCamera);
      var cameras = (inspector.cameras = {
        perspective: perspectiveCamera,
        original: originalCamera,
        ortho: orthoCamera
      });
      _Events2.default.on("cameraperspectivetoggle", function() {
        saveOrthoCamera(inspector.camera, currentOrthoDir);
        sceneEl.camera = inspector.camera = cameras.perspective;
        _Events2.default.emit("cameratoggle", {
          camera: inspector.camera,
          value: "perspective"
        });
      });
      _Events2.default.on("cameraorthographictoggle", function(dir) {
        saveOrthoCamera(inspector.camera, currentOrthoDir);
        sceneEl.camera = inspector.camera = cameras.ortho;
        currentOrthoDir = dir;
        setOrthoCamera(cameras.ortho, dir, ratio);
        if (
          cameras.ortho.rotation.x === 0 &&
          cameras.ortho.rotation.y === 0 &&
          cameras.ortho.rotation.z === 0
        ) {
          cameras.ortho.lookAt(0, 0, 0);
        }
        _Events2.default.emit("cameratoggle", {
          camera: inspector.camera,
          value: "ortho" + dir
        });
      });
      return inspector.cameras;
    }
    function saveOrthoCamera(camera, dir) {
      if (camera.type !== "OrthographicCamera") {
        return;
      }
      var info = orthoCameraMemory[dir];
      info.position.copy(camera.position);
      info.rotation.copy(camera.rotation);
      info.left = camera.left;
      info.right = camera.right;
      info.top = camera.top;
      info.bottom = camera.bottom;
    }
    function setOrthoCamera(camera, dir, ratio) {
      var info = orthoCameraMemory[dir];
      camera.left = info.left || -10 * ratio;
      camera.right = info.right || 10 * ratio;
      camera.top = info.top || 10;
      camera.bottom = info.bottom || -10;
      camera.position.copy(info.position);
      camera.rotation.copy(info.rotation);
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var Events = __webpack_require__(5);
    var updates = {};
    Events.on("entityupdate", function(payload) {
      var value = payload.value;
      var entity = payload.entity;
      updates[entity.id] = updates[entity.id] || {};
      var component = AFRAME.components[payload.component];
      if (component) {
        if (payload.property) {
          updates[entity.id][payload.component] =
            updates[entity.id][payload.component] || {};
          value = component.schema[payload.property].stringify(payload.value);
          updates[entity.id][payload.component][payload.property] = value;
        } else {
          value = component.schema.stringify(payload.value);
          updates[entity.id][payload.component] = value;
        }
      }
    });
    module.exports = { updates: updates };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var Events = __webpack_require__(5);
    var debounce = __webpack_require__(24);
    function initRaycaster(inspector) {
      var mouseCursor = document.createElement("a-entity");
      mouseCursor.setAttribute("id", "aframeInspectorMouseCursor");
      mouseCursor.setAttribute("cursor", "rayOrigin", "mouse");
      mouseCursor.setAttribute("data-aframe-inspector", "true");
      mouseCursor.setAttribute("raycaster", {
        interval: 100,
        objects: "a-scene :not([data-aframe-inspector])"
      });
      var raycaster = mouseCursor.components.raycaster;
      var refreshObjects = raycaster.refreshObjects;
      var overrideRefresh = function overrideRefresh() {
        refreshObjects.call(raycaster);
        var objects = raycaster.objects;
        raycaster.objects = objects.filter(function(node) {
          while (node) {
            if (!node.visible) {
              return false;
            }
            node = node.parent;
          }
          return true;
        });
      };
      raycaster.refreshObjects = overrideRefresh;
      inspector.sceneEl.appendChild(mouseCursor);
      inspector.cursor = mouseCursor;
      inspector.sceneEl.addEventListener(
        "child-attached",
        debounce(function() {
          mouseCursor.components.raycaster.refreshObjects();
        }, 250)
      );
      mouseCursor.addEventListener("click", handleClick);
      mouseCursor.addEventListener("mouseenter", onMouseEnter);
      mouseCursor.addEventListener("mouseleave", onMouseLeave);
      inspector.container.addEventListener("mousedown", onMouseDown);
      inspector.container.addEventListener("mouseup", onMouseUp);
      inspector.container.addEventListener("dblclick", onDoubleClick);
      inspector.sceneEl.canvas.addEventListener("mouseleave", function() {
        setTimeout(function() {
          Events.emit("raycastermouseleave", null);
        });
      });
      var onDownPosition = new THREE.Vector2();
      var onUpPosition = new THREE.Vector2();
      var onDoubleClickPosition = new THREE.Vector2();
      function onMouseEnter() {
        Events.emit(
          "raycastermouseenter",
          mouseCursor.components.cursor.intersectedEl
        );
      }
      function onMouseLeave() {
        Events.emit(
          "raycastermouseleave",
          mouseCursor.components.cursor.intersectedEl
        );
      }
      function handleClick(evt) {
        var DRAG_THRESHOLD = 0.03;
        if (onDownPosition.distanceTo(onUpPosition) >= DRAG_THRESHOLD) {
          return;
        }
        inspector.selectEntity(evt.detail.intersectedEl);
      }
      function onMouseDown(event) {
        if (event instanceof CustomEvent) {
          return;
        }
        event.preventDefault();
        var array = getMousePosition(
          inspector.container,
          event.clientX,
          event.clientY
        );
        onDownPosition.fromArray(array);
      }
      function onMouseUp(event) {
        if (event instanceof CustomEvent) {
          return;
        }
        event.preventDefault();
        var array = getMousePosition(
          inspector.container,
          event.clientX,
          event.clientY
        );
        onUpPosition.fromArray(array);
      }
      function onTouchStart(event) {
        var touch = event.changedTouches[0];
        var array = getMousePosition(
          inspector.container,
          touch.clientX,
          touch.clientY
        );
        onDownPosition.fromArray(array);
      }
      function onTouchEnd(event) {
        var touch = event.changedTouches[0];
        var array = getMousePosition(
          inspector.container,
          touch.clientX,
          touch.clientY
        );
        onUpPosition.fromArray(array);
      }
      function onDoubleClick(event) {
        var array = getMousePosition(
          inspector.container,
          event.clientX,
          event.clientY
        );
        onDoubleClickPosition.fromArray(array);
        var intersectedEl = mouseCursor.components.cursor.intersectedEl;
        if (!intersectedEl) {
          return;
        }
        Events.emit("objectfocus", intersectedEl.object3D);
      }
      return {
        el: mouseCursor,
        enable: function enable() {
          mouseCursor.setAttribute("raycaster", "enabled", true);
        },
        disable: function disable() {
          mouseCursor.setAttribute("raycaster", "enabled", false);
        }
      };
    }
    module.exports.initRaycaster = initRaycaster;
    function getMousePosition(dom, x, y) {
      var rect = dom.getBoundingClientRect();
      return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _entity = __webpack_require__(14);
    var _utils = __webpack_require__(15);
    var Events = __webpack_require__(5);
    function shouldCaptureKeyEvent(event) {
      if (event.metaKey) {
        return false;
      }
      return (
        event.target.closest("#cameraToolbar") ||
        (event.target.tagName !== "INPUT" &&
          event.target.tagName !== "TEXTAREA")
      );
    }
    var Shortcuts = {
      enabled: false,
      shortcuts: { default: {}, modules: {} },
      onKeyUp: function onKeyUp(event) {
        if (!shouldCaptureKeyEvent(event)) {
          return;
        }
        var keyCode = event.keyCode;
        if (keyCode === 72) {
          Events.emit("openhelpmodal");
        }
        if (keyCode === 27) {
          if (this.inspector.selectedEntity) {
            this.inspector.selectEntity(null);
          }
        }
        if (keyCode === 87) {
          Events.emit("transformmodechange", "translate");
        }
        if (keyCode === 69) {
          Events.emit("transformmodechange", "rotate");
        }
        if (keyCode === 82) {
          Events.emit("transformmodechange", "scale");
        }
        if (keyCode === 79) {
          Events.emit("transformspacechange");
        }
        if (keyCode === 71) {
          Events.emit("togglegrid");
        }
        if (keyCode === 77) {
          Events.emit("togglemotioncapture");
        }
        if (keyCode === 78) {
          Events.emit("entitycreate", { element: "a-entity", components: {} });
        }
        if (keyCode === 8 || keyCode === 46) {
          (0, _entity.removeSelectedEntity)();
        }
        if (keyCode === 68) {
          (0, _entity.cloneSelectedEntity)();
        }
        if (keyCode === 70) {
          var selectedEntity = AFRAME.INSPECTOR.selectedEntity;
          if (selectedEntity !== undefined && selectedEntity !== null) {
            Events.emit("objectfocus", selectedEntity.object3D);
          }
        }
        if (keyCode === 49) {
          Events.emit("cameraperspectivetoggle");
        } else if (keyCode === 50) {
          Events.emit("cameraorthographictoggle", "left");
        } else if (keyCode === 51) {
          Events.emit("cameraorthographictoggle", "right");
        } else if (keyCode === 52) {
          Events.emit("cameraorthographictoggle", "top");
        } else if (keyCode === 53) {
          Events.emit("cameraorthographictoggle", "bottom");
        } else if (keyCode === 54) {
          Events.emit("cameraorthographictoggle", "back");
        } else if (keyCode === 55) {
          Events.emit("cameraorthographictoggle", "front");
        }
        for (var moduleName in this.shortcuts.modules) {
          var shortcutsModule = this.shortcuts.modules[moduleName];
          if (
            shortcutsModule[keyCode] &&
            (!shortcutsModule[keyCode].mustBeActive ||
              (shortcutsModule[keyCode].mustBeActive &&
                AFRAME.INSPECTOR.modules[moduleName].active))
          ) {
            this.shortcuts.modules[moduleName][keyCode].callback();
          }
        }
      },
      onKeyDown: function onKeyDown(event) {
        if (!shouldCaptureKeyEvent(event)) {
          return;
        }
        if (
          (event.ctrlKey && _utils.os === "windows") ||
          (event.metaKey && _utils.os === "macos")
        ) {
          if (
            AFRAME.INSPECTOR.selectedEntity &&
            document.activeElement.tagName !== "INPUT"
          ) {
            if (event.keyCode === 88) {
              AFRAME.INSPECTOR.entityToCopy = AFRAME.INSPECTOR.selectedEntity;
              (0, _entity.removeSelectedEntity)(true);
            }
            if (event.keyCode === 67) {
              AFRAME.INSPECTOR.entityToCopy = AFRAME.INSPECTOR.selectedEntity;
            }
            if (event.keyCode === 86) {
              (0, _entity.cloneEntity)(AFRAME.INSPECTOR.entityToCopy);
            }
          }
          if (event.keyCode === 83) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById("filter").focus();
          }
        }
        if (event.keyCode === 48) {
          Events.emit("togglesidebar", { which: "all" });
          event.preventDefault();
          event.stopPropagation();
        }
      },
      enable: function enable() {
        if (this.enabled) {
          this.disable();
        }
        window.addEventListener("keydown", this.onKeyDown.bind(this), false);
        window.addEventListener("keyup", this.onKeyUp.bind(this), false);
        this.enabled = true;
      },
      disable: function disable() {
        window.removeEventListener("keydown", this.onKeyDown);
        window.removeEventListener("keyup", this.onKeyUp);
        this.enabled = false;
      },
      checkModuleShortcutCollision: function checkModuleShortcutCollision(
        keyCode,
        moduleName,
        mustBeActive
      ) {
        if (
          this.shortcuts.modules[moduleName] &&
          this.shortcuts.modules[moduleName][keyCode]
        ) {
          console.warn(
            "Keycode <%s> already registered as shorcut within the same module",
            keyCode
          );
        }
      },
      registerModuleShortcut: function registerModuleShortcut(
        keyCode,
        callback,
        moduleName,
        mustBeActive
      ) {
        if (
          this.checkModuleShortcutCollision(keyCode, moduleName, mustBeActive)
        ) {
          return;
        }
        if (!this.shortcuts.modules[moduleName]) {
          this.shortcuts.modules[moduleName] = {};
        }
        if (mustBeActive !== false) {
          mustBeActive = true;
        }
        this.shortcuts.modules[moduleName][keyCode] = {
          callback: callback,
          mustBeActive: mustBeActive
        };
      },
      init: function init(inspector) {
        this.inspector = inspector;
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
      }
    };
    module.exports = Shortcuts;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _lodash = __webpack_require__(24);
    var _lodash2 = _interopRequireDefault(_lodash);
    var _TransformControls = __webpack_require__(128);
    var _TransformControls2 = _interopRequireDefault(_TransformControls);
    var _EditorControls = __webpack_require__(127);
    var _EditorControls2 = _interopRequireDefault(_EditorControls);
    var _raycaster = __webpack_require__(133);
    var _utils = __webpack_require__(15);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Events = __webpack_require__(5);
    function Viewport(inspector) {
      var mouseCursor = (0, _raycaster.initRaycaster)(inspector);
      var sceneEl = inspector.sceneEl;
      var originalCamera = inspector.cameras.original;
      sceneEl.addEventListener("camera-set-active", function(event) {
        if (inspector.opened) {
          originalCamera = event.detail.cameraEl;
        }
      });
      var sceneHelpers = inspector.sceneHelpers;
      var grid = new THREE.GridHelper(30, 60, 0xaaaaaa, 0x262626);
      sceneHelpers.add(grid);
      var selectionBox = new THREE.BoxHelper();
      selectionBox.material.depthTest = false;
      selectionBox.material.transparent = true;
      selectionBox.material.color.set(0x1faaf2);
      selectionBox.visible = false;
      sceneHelpers.add(selectionBox);
      function updateHelpers(object) {
        object.traverse(function(node) {
          if (inspector.helpers[node.uuid]) {
            inspector.helpers[node.uuid].update();
          }
        });
      }
      var camera = inspector.camera;
      var transformControls = new THREE.TransformControls(
        camera,
        inspector.container
      );
      transformControls.size = 0.75;
      transformControls.addEventListener("objectChange", function(evt) {
        var object = transformControls.object;
        if (object === undefined) {
          return;
        }
        selectionBox.setFromObject(object).update();
        updateHelpers(object);
        Events.emit("refreshsidebarobject3d", object);
        var component = void 0;
        var value = void 0;
        if (evt.mode === "translate") {
          component = "position";
          value =
            object.position.x +
            " " +
            object.position.y +
            " " +
            object.position.z;
        } else if (evt.mode === "rotate") {
          component = "rotation";
          var d = THREE.Math.radToDeg;
          value =
            d(object.rotation.x) +
            " " +
            d(object.rotation.y) +
            " " +
            d(object.rotation.z);
        } else if (evt.mode === "scale") {
          component = "scale";
          value = object.scale.x + " " + object.scale.y + " " + object.scale.z;
        }
        Events.emit("entityupdate", {
          component: component,
          entity: transformControls.object.el,
          property: "",
          value: value
        });
        Events.emit("entitytransformed", transformControls.object.el);
      });
      transformControls.addEventListener("mouseDown", function() {
        controls.enabled = false;
      });
      transformControls.addEventListener("mouseUp", function() {
        controls.enabled = true;
      });
      sceneHelpers.add(transformControls);
      Events.on("entityupdate", function(detail) {
        if (inspector.selectedEntity.object3DMap["mesh"]) {
          selectionBox.update(inspector.selected);
        }
      });
      var controls = new THREE.EditorControls(camera, inspector.container);
      controls.center.set(0, 1.6, 0);
      controls.rotationSpeed = 0.0035;
      controls.zoomSpeed = 0.05;
      controls.setAspectRatio(sceneEl.canvas.width / sceneEl.canvas.height);
      Events.on("cameratoggle", function(data) {
        controls.setCamera(data.camera);
        transformControls.setCamera(data.camera);
      });
      function disableControls() {
        mouseCursor.disable();
        transformControls.dispose();
        controls.enabled = false;
      }
      function enableControls() {
        mouseCursor.enable();
        transformControls.activate();
        controls.enabled = true;
      }
      enableControls();
      Events.on("inspectorcleared", function() {
        controls.center.set(0, 0, 0);
      });
      Events.on("transformmodechange", function(mode) {
        transformControls.setMode(mode);
      });
      Events.on("snapchanged", function(dist) {
        transformControls.setTranslationSnap(dist);
      });
      Events.on("transformspacechanged", function(space) {
        transformControls.setSpace(space);
      });
      Events.on("objectselect", function(object) {
        selectionBox.visible = false;
        transformControls.detach();
        if (object && object.el) {
          if (object.el.getObject3D("mesh")) {
            selectionBox.setFromObject(object).update();
            selectionBox.visible = true;
          }
          transformControls.attach(object);
        }
      });
      Events.on("objectfocus", function(object) {
        controls.focus(object);
        transformControls.update();
      });
      Events.on("geometrychanged", function(object) {
        if (object !== null) {
          selectionBox.setFromObject(object).update();
        }
      });
      Events.on("entityupdate", function(detail) {
        var object = detail.entity.object3D;
        if (inspector.selected === object) {
          if (
            object.geometry &&
            ((object.geometry.vertices &&
              object.geometry.vertices.length > 0) ||
              (object.geometry.attributes &&
                object.geometry.attributes.position &&
                object.geometry.attributes.position.array.length))
          ) {
            selectionBox.setFromObject(object).update();
          }
        }
        transformControls.update();
        if (object instanceof THREE.PerspectiveCamera) {
          object.updateProjectionMatrix();
        }
        updateHelpers(object);
      });
      Events.on("windowresize", function() {
        camera.aspect =
          inspector.container.offsetWidth / inspector.container.offsetHeight;
        camera.updateProjectionMatrix();
      });
      Events.on("gridvisibilitychanged", function(showGrid) {
        grid.visible = showGrid;
      });
      Events.on("togglegrid", function() {
        grid.visible = !grid.visible;
      });
      Events.on("inspectortoggle", function(active) {
        if (active) {
          enableControls();
          AFRAME.scenes[0].camera = inspector.camera;
          Array.prototype.slice
            .call(document.querySelectorAll(".a-enter-vr,.rs-base"))
            .forEach(function(element) {
              element.style.display = "none";
            });
        } else {
          disableControls();
          inspector.cameras.original.setAttribute("camera", "active", "true");
          AFRAME.scenes[0].camera = inspector.cameras.original.getObject3D(
            "camera"
          );
          Array.prototype.slice
            .call(document.querySelectorAll(".a-enter-vr,.rs-base"))
            .forEach(function(element) {
              element.style.display = "block";
            });
        }
        ga("send", "event", "Viewport", "toggleEditor", active);
      });
    }
    module.exports = Viewport;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var WEBGL_CONSTANTS = {
      POINTS: 0x0000,
      LINES: 0x0001,
      LINE_LOOP: 0x0002,
      LINE_STRIP: 0x0003,
      TRIANGLES: 0x0004,
      TRIANGLE_STRIP: 0x0005,
      TRIANGLE_FAN: 0x0006,
      UNSIGNED_BYTE: 0x1401,
      UNSIGNED_SHORT: 0x1403,
      FLOAT: 0x1406,
      UNSIGNED_INT: 0x1405,
      ARRAY_BUFFER: 0x8892,
      ELEMENT_ARRAY_BUFFER: 0x8893,
      NEAREST: 0x2600,
      LINEAR: 0x2601,
      NEAREST_MIPMAP_NEAREST: 0x2700,
      LINEAR_MIPMAP_NEAREST: 0x2701,
      NEAREST_MIPMAP_LINEAR: 0x2702,
      LINEAR_MIPMAP_LINEAR: 0x2703
    };
    var THREE_TO_WEBGL = {
      1003: WEBGL_CONSTANTS.NEAREST,
      1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,
      1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,
      1006: WEBGL_CONSTANTS.LINEAR,
      1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,
      1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR
    };
    var PATH_PROPERTIES = {
      scale: "scale",
      position: "translation",
      quaternion: "rotation",
      morphTargetInfluences: "weights"
    };
    THREE.GLTFExporter = function() {};
    THREE.GLTFExporter.prototype = {
      constructor: THREE.GLTFExporter,
      parse: function parse(input, onDone, options) {
        var DEFAULT_OPTIONS = {
          binary: false,
          trs: false,
          onlyVisible: true,
          truncateDrawRange: true,
          embedImages: true,
          animations: [],
          forceIndices: false,
          forcePowerOfTwoTextures: false
        };
        options = Object.assign({}, DEFAULT_OPTIONS, options);
        if (options.animations.length > 0) {
          options.trs = true;
        }
        var outputJSON = {
          asset: { version: "2.0", generator: "THREE.GLTFExporter" }
        };
        var byteOffset = 0;
        var buffers = [];
        var pending = [];
        var nodeMap = new Map();
        var skins = [];
        var extensionsUsed = {};
        var cachedData = {
          attributes: new Map(),
          materials: new Map(),
          textures: new Map(),
          images: new Map()
        };
        var cachedCanvas;
        function equalArray(array1, array2) {
          return (
            array1.length === array2.length &&
            array1.every(function(element, index) {
              return element === array2[index];
            })
          );
        }
        function stringToArrayBuffer(text) {
          if (window.TextEncoder !== undefined) {
            return new TextEncoder().encode(text).buffer;
          }
          var array = new Uint8Array(new ArrayBuffer(text.length));
          for (var i = 0, il = text.length; i < il; i++) {
            var value = text.charCodeAt(i);
            array[i] = value > 0xff ? 0x20 : value;
          }
          return array.buffer;
        }
        function getMinMax(attribute, start, count) {
          var output = {
            min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
            max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
          };
          for (var i = start; i < start + count; i++) {
            for (var a = 0; a < attribute.itemSize; a++) {
              var value = attribute.array[i * attribute.itemSize + a];
              output.min[a] = Math.min(output.min[a], value);
              output.max[a] = Math.max(output.max[a], value);
            }
          }
          return output;
        }
        function isPowerOfTwo(image) {
          return (
            THREE.Math.isPowerOfTwo(image.width) &&
            THREE.Math.isPowerOfTwo(image.height)
          );
        }
        function isNormalizedNormalAttribute(normal) {
          if (cachedData.attributes.has(normal)) {
            return false;
          }
          var v = new THREE.Vector3();
          for (var i = 0, il = normal.count; i < il; i++) {
            if (
              Math.abs(v.fromArray(normal.array, i * 3).length() - 1.0) > 0.0005
            )
              return false;
          }
          return true;
        }
        function createNormalizedNormalAttribute(normal) {
          if (cachedData.attributes.has(normal)) {
            return cachedData.attributes.get(normal);
          }
          var attribute = normal.clone();
          var v = new THREE.Vector3();
          for (var i = 0, il = attribute.count; i < il; i++) {
            v.fromArray(attribute.array, i * 3);
            if (v.x === 0 && v.y === 0 && v.z === 0) {
              v.setX(1.0);
            } else {
              v.normalize();
            }
            v.toArray(attribute.array, i * 3);
          }
          cachedData.attributes.set(normal, attribute);
          return attribute;
        }
        function getPaddedBufferSize(bufferSize) {
          return Math.ceil(bufferSize / 4) * 4;
        }
        function getPaddedArrayBuffer(arrayBuffer, paddingByte) {
          paddingByte = paddingByte || 0;
          var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
          if (paddedLength !== arrayBuffer.byteLength) {
            var array = new Uint8Array(paddedLength);
            array.set(new Uint8Array(arrayBuffer));
            if (paddingByte !== 0) {
              for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {
                array[i] = paddingByte;
              }
            }
            return array.buffer;
          }
          return arrayBuffer;
        }
        function serializeUserData(object) {
          try {
            return JSON.parse(JSON.stringify(object.userData));
          } catch (error) {
            console.warn(
              "THREE.GLTFExporter: userData of '" +
                object.name +
                "' " +
                "won't be serialized because of JSON.stringify error - " +
                error.message
            );
            return {};
          }
        }
        function processBuffer(buffer) {
          if (!outputJSON.buffers) {
            outputJSON.buffers = [{ byteLength: 0 }];
          }
          buffers.push(buffer);
          return 0;
        }
        function processBufferView(
          attribute,
          componentType,
          start,
          count,
          target
        ) {
          if (!outputJSON.bufferViews) {
            outputJSON.bufferViews = [];
          }
          var componentSize;
          if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
            componentSize = 1;
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
            componentSize = 2;
          } else {
            componentSize = 4;
          }
          var byteLength = getPaddedBufferSize(
            count * attribute.itemSize * componentSize
          );
          var dataView = new DataView(new ArrayBuffer(byteLength));
          var offset = 0;
          for (var i = start; i < start + count; i++) {
            for (var a = 0; a < attribute.itemSize; a++) {
              var value = attribute.array[i * attribute.itemSize + a];
              if (componentType === WEBGL_CONSTANTS.FLOAT) {
                dataView.setFloat32(offset, value, true);
              } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
                dataView.setUint32(offset, value, true);
              } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
                dataView.setUint16(offset, value, true);
              } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
                dataView.setUint8(offset, value);
              }
              offset += componentSize;
            }
          }
          var gltfBufferView = {
            buffer: processBuffer(dataView.buffer),
            byteOffset: byteOffset,
            byteLength: byteLength
          };
          if (target !== undefined) gltfBufferView.target = target;
          if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
            gltfBufferView.byteStride = attribute.itemSize * componentSize;
          }
          byteOffset += byteLength;
          outputJSON.bufferViews.push(gltfBufferView);
          var output = { id: outputJSON.bufferViews.length - 1, byteLength: 0 };
          return output;
        }
        function processBufferViewImage(blob) {
          if (!outputJSON.bufferViews) {
            outputJSON.bufferViews = [];
          }
          return new Promise(function(resolve) {
            var reader = new window.FileReader();
            reader.readAsArrayBuffer(blob);
            reader.onloadend = function() {
              var buffer = getPaddedArrayBuffer(reader.result);
              var bufferView = {
                buffer: processBuffer(buffer),
                byteOffset: byteOffset,
                byteLength: buffer.byteLength
              };
              byteOffset += buffer.byteLength;
              outputJSON.bufferViews.push(bufferView);
              resolve(outputJSON.bufferViews.length - 1);
            };
          });
        }
        function processAccessor(attribute, geometry, start, count) {
          var types = {
            1: "SCALAR",
            2: "VEC2",
            3: "VEC3",
            4: "VEC4",
            16: "MAT4"
          };
          var componentType;
          if (attribute.array.constructor === Float32Array) {
            componentType = WEBGL_CONSTANTS.FLOAT;
          } else if (attribute.array.constructor === Uint32Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
          } else if (attribute.array.constructor === Uint16Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
          } else if (attribute.array.constructor === Uint8Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
          } else {
            throw new Error(
              "THREE.GLTFExporter: Unsupported bufferAttribute component type."
            );
          }
          if (start === undefined) start = 0;
          if (count === undefined) count = attribute.count;
          if (
            options.truncateDrawRange &&
            geometry !== undefined &&
            geometry.index === null
          ) {
            var end = start + count;
            var end2 =
              geometry.drawRange.count === Infinity
                ? attribute.count
                : geometry.drawRange.start + geometry.drawRange.count;
            start = Math.max(start, geometry.drawRange.start);
            count = Math.min(end, end2) - start;
            if (count < 0) count = 0;
          }
          if (count === 0) {
            return null;
          }
          var minMax = getMinMax(attribute, start, count);
          var bufferViewTarget;
          if (geometry !== undefined) {
            bufferViewTarget =
              attribute === geometry.index
                ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER
                : WEBGL_CONSTANTS.ARRAY_BUFFER;
          }
          var bufferView = processBufferView(
            attribute,
            componentType,
            start,
            count,
            bufferViewTarget
          );
          var gltfAccessor = {
            bufferView: bufferView.id,
            byteOffset: bufferView.byteOffset,
            componentType: componentType,
            count: count,
            max: minMax.max,
            min: minMax.min,
            type: types[attribute.itemSize]
          };
          if (!outputJSON.accessors) {
            outputJSON.accessors = [];
          }
          outputJSON.accessors.push(gltfAccessor);
          return outputJSON.accessors.length - 1;
        }
        function processImage(image, format, flipY) {
          if (!cachedData.images.has(image)) {
            cachedData.images.set(image, {});
          }
          var cachedImages = cachedData.images.get(image);
          var mimeType =
            format === THREE.RGBAFormat ? "image/png" : "image/jpeg";
          var key = mimeType + ":flipY/" + flipY.toString();
          if (cachedImages[key] !== undefined) {
            return cachedImages[key];
          }
          if (!outputJSON.images) {
            outputJSON.images = [];
          }
          var gltfImage = { mimeType: mimeType };
          if (options.embedImages) {
            var canvas = (cachedCanvas =
              cachedCanvas || document.createElement("canvas"));
            canvas.width = image.width;
            canvas.height = image.height;
            if (options.forcePowerOfTwoTextures && !isPowerOfTwo(image)) {
              console.warn(
                "GLTFExporter: Resized non-power-of-two image.",
                image
              );
              canvas.width = THREE.Math.floorPowerOfTwo(canvas.width);
              canvas.height = THREE.Math.floorPowerOfTwo(canvas.height);
            }
            var ctx = canvas.getContext("2d");
            if (flipY === true) {
              ctx.translate(0, canvas.height);
              ctx.scale(1, -1);
            }
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            if (options.binary === true) {
              pending.push(
                new Promise(function(resolve) {
                  canvas.toBlob(function(blob) {
                    processBufferViewImage(blob).then(function(
                      bufferViewIndex
                    ) {
                      gltfImage.bufferView = bufferViewIndex;
                      resolve();
                    });
                  }, mimeType);
                })
              );
            } else {
              gltfImage.uri = canvas.toDataURL(mimeType);
            }
          } else {
            gltfImage.uri = image.src;
          }
          outputJSON.images.push(gltfImage);
          var index = outputJSON.images.length - 1;
          cachedImages[key] = index;
          return index;
        }
        function processSampler(map) {
          if (!outputJSON.samplers) {
            outputJSON.samplers = [];
          }
          var gltfSampler = {
            magFilter: THREE_TO_WEBGL[map.magFilter],
            minFilter: THREE_TO_WEBGL[map.minFilter],
            wrapS: THREE_TO_WEBGL[map.wrapS],
            wrapT: THREE_TO_WEBGL[map.wrapT]
          };
          outputJSON.samplers.push(gltfSampler);
          return outputJSON.samplers.length - 1;
        }
        function processTexture(map) {
          if (cachedData.textures.has(map)) {
            return cachedData.textures.get(map);
          }
          if (!outputJSON.textures) {
            outputJSON.textures = [];
          }
          var gltfTexture = {
            sampler: processSampler(map),
            source: processImage(map.image, map.format, map.flipY)
          };
          outputJSON.textures.push(gltfTexture);
          var index = outputJSON.textures.length - 1;
          cachedData.textures.set(map, index);
          return index;
        }
        function processMaterial(material) {
          if (cachedData.materials.has(material)) {
            return cachedData.materials.get(material);
          }
          if (!outputJSON.materials) {
            outputJSON.materials = [];
          }
          if (material.isShaderMaterial) {
            console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
            return null;
          }
          var gltfMaterial = { pbrMetallicRoughness: {} };
          if (material.isMeshBasicMaterial) {
            gltfMaterial.extensions = { KHR_materials_unlit: {} };
            extensionsUsed["KHR_materials_unlit"] = true;
          } else if (!material.isMeshStandardMaterial) {
            console.warn(
              "GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."
            );
          }
          var color = material.color.toArray().concat([material.opacity]);
          if (!equalArray(color, [1, 1, 1, 1])) {
            gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;
          }
          if (material.isMeshStandardMaterial) {
            gltfMaterial.pbrMetallicRoughness.metallicFactor =
              material.metalness;
            gltfMaterial.pbrMetallicRoughness.roughnessFactor =
              material.roughness;
          } else if (material.isMeshBasicMaterial) {
            gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;
            gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;
          } else {
            gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
            gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;
          }
          if (material.metalnessMap || material.roughnessMap) {
            if (material.metalnessMap === material.roughnessMap) {
              gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {
                index: processTexture(material.metalnessMap)
              };
            } else {
              console.warn(
                "THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture."
              );
            }
          }
          if (material.map) {
            gltfMaterial.pbrMetallicRoughness.baseColorTexture = {
              index: processTexture(material.map)
            };
          }
          if (
            material.isMeshBasicMaterial ||
            material.isLineBasicMaterial ||
            material.isPointsMaterial
          ) {
          } else {
            var emissive = material.emissive
              .clone()
              .multiplyScalar(material.emissiveIntensity)
              .toArray();
            if (!equalArray(emissive, [0, 0, 0])) {
              gltfMaterial.emissiveFactor = emissive;
            }
            if (material.emissiveMap) {
              gltfMaterial.emissiveTexture = {
                index: processTexture(material.emissiveMap)
              };
            }
          }
          if (material.normalMap) {
            gltfMaterial.normalTexture = {
              index: processTexture(material.normalMap)
            };
            if (material.normalScale.x !== -1) {
              if (material.normalScale.x !== material.normalScale.y) {
                console.warn(
                  "THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."
                );
              }
              gltfMaterial.normalTexture.scale = material.normalScale.x;
            }
          }
          if (material.aoMap) {
            gltfMaterial.occlusionTexture = {
              index: processTexture(material.aoMap)
            };
            if (material.aoMapIntensity !== 1.0) {
              gltfMaterial.occlusionTexture.strength = material.aoMapIntensity;
            }
          }
          if (material.transparent || material.alphaTest > 0.0) {
            gltfMaterial.alphaMode = material.opacity < 1.0 ? "BLEND" : "MASK";
            if (material.alphaTest > 0.0 && material.alphaTest !== 0.5) {
              gltfMaterial.alphaCutoff = material.alphaTest;
            }
          }
          if (material.side === THREE.DoubleSide) {
            gltfMaterial.doubleSided = true;
          }
          if (material.name !== "") {
            gltfMaterial.name = material.name;
          }
          if (Object.keys(material.userData).length > 0) {
            gltfMaterial.extras = serializeUserData(material);
          }
          outputJSON.materials.push(gltfMaterial);
          var index = outputJSON.materials.length - 1;
          cachedData.materials.set(material, index);
          return index;
        }
        function processMesh(mesh) {
          var geometry = mesh.geometry;
          var mode;
          if (mesh.isLineSegments) {
            mode = WEBGL_CONSTANTS.LINES;
          } else if (mesh.isLineLoop) {
            mode = WEBGL_CONSTANTS.LINE_LOOP;
          } else if (mesh.isLine) {
            mode = WEBGL_CONSTANTS.LINE_STRIP;
          } else if (mesh.isPoints) {
            mode = WEBGL_CONSTANTS.POINTS;
          } else {
            if (!geometry.isBufferGeometry) {
              var geometryTemp = new THREE.BufferGeometry();
              geometryTemp.fromGeometry(geometry);
              geometry = geometryTemp;
            }
            if (mesh.drawMode === THREE.TriangleFanDrawMode) {
              console.warn(
                "GLTFExporter: TriangleFanDrawMode and wireframe incompatible."
              );
              mode = WEBGL_CONSTANTS.TRIANGLE_FAN;
            } else if (mesh.drawMode === THREE.TriangleStripDrawMode) {
              mode = mesh.material.wireframe
                ? WEBGL_CONSTANTS.LINE_STRIP
                : WEBGL_CONSTANTS.TRIANGLE_STRIP;
            } else {
              mode = mesh.material.wireframe
                ? WEBGL_CONSTANTS.LINES
                : WEBGL_CONSTANTS.TRIANGLES;
            }
          }
          var gltfMesh = {};
          var attributes = {};
          var primitives = [];
          var targets = [];
          var nameConversion = {
            uv: "TEXCOORD_0",
            uv2: "TEXCOORD_1",
            color: "COLOR_0",
            skinWeight: "WEIGHTS_0",
            skinIndex: "JOINTS_0"
          };
          var originalNormal = geometry.getAttribute("normal");
          if (
            originalNormal !== undefined &&
            !isNormalizedNormalAttribute(originalNormal)
          ) {
            console.warn(
              "THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."
            );
            geometry.addAttribute(
              "normal",
              createNormalizedNormalAttribute(originalNormal)
            );
          }
          for (var attributeName in geometry.attributes) {
            var attribute = geometry.attributes[attributeName];
            attributeName =
              nameConversion[attributeName] || attributeName.toUpperCase();
            var array = attribute.array;
            if (
              attributeName === "JOINTS_0" &&
              !(array instanceof Uint16Array) &&
              !(array instanceof Uint8Array)
            ) {
              console.warn(
                'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'
              );
              attribute = new THREE.BufferAttribute(
                new Uint16Array(array),
                attribute.itemSize,
                attribute.normalized
              );
            }
            if (attributeName.substr(0, 5) !== "MORPH") {
              var accessor = processAccessor(attribute, geometry);
              if (accessor !== null) {
                attributes[attributeName] = accessor;
              }
            }
          }
          if (originalNormal !== undefined)
            geometry.addAttribute("normal", originalNormal);
          if (Object.keys(attributes).length === 0) {
            return null;
          }
          if (
            mesh.morphTargetInfluences !== undefined &&
            mesh.morphTargetInfluences.length > 0
          ) {
            var weights = [];
            var targetNames = [];
            var reverseDictionary = {};
            if (mesh.morphTargetDictionary !== undefined) {
              for (var key in mesh.morphTargetDictionary) {
                reverseDictionary[mesh.morphTargetDictionary[key]] = key;
              }
            }
            for (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {
              var target = {};
              var warned = false;
              for (var attributeName in geometry.morphAttributes) {
                if (
                  attributeName !== "position" &&
                  attributeName !== "normal"
                ) {
                  if (!warned) {
                    console.warn(
                      "GLTFExporter: Only POSITION and NORMAL morph are supported."
                    );
                    warned = true;
                  }
                  continue;
                }
                var attribute = geometry.morphAttributes[attributeName][i];
                var baseAttribute = geometry.attributes[attributeName];
                var relativeAttribute = attribute.clone();
                for (var j = 0, jl = attribute.count; j < jl; j++) {
                  relativeAttribute.setXYZ(
                    j,
                    attribute.getX(j) - baseAttribute.getX(j),
                    attribute.getY(j) - baseAttribute.getY(j),
                    attribute.getZ(j) - baseAttribute.getZ(j)
                  );
                }
                target[attributeName.toUpperCase()] = processAccessor(
                  relativeAttribute,
                  geometry
                );
              }
              targets.push(target);
              weights.push(mesh.morphTargetInfluences[i]);
              if (mesh.morphTargetDictionary !== undefined)
                targetNames.push(reverseDictionary[i]);
            }
            gltfMesh.weights = weights;
            if (targetNames.length > 0) {
              gltfMesh.extras = {};
              gltfMesh.extras.targetNames = targetNames;
            }
          }
          var extras =
            Object.keys(geometry.userData).length > 0
              ? serializeUserData(geometry)
              : undefined;
          var forceIndices = options.forceIndices;
          var isMultiMaterial = Array.isArray(mesh.material);
          if (isMultiMaterial && geometry.groups.length === 0) return null;
          if (!forceIndices && geometry.index === null && isMultiMaterial) {
            console.warn(
              "THREE.GLTFExporter: Creating index for non-indexed multi-material mesh."
            );
            forceIndices = true;
          }
          var didForceIndices = false;
          if (geometry.index === null && forceIndices) {
            var indices = [];
            for (
              var i = 0, il = geometry.attributes.position.count;
              i < il;
              i++
            ) {
              indices[i] = i;
            }
            geometry.setIndex(indices);
            didForceIndices = true;
          }
          var materials = isMultiMaterial ? mesh.material : [mesh.material];
          var groups = isMultiMaterial
            ? geometry.groups
            : [{ materialIndex: 0, start: undefined, count: undefined }];
          for (var i = 0, il = groups.length; i < il; i++) {
            var primitive = { mode: mode, attributes: attributes };
            if (extras) primitive.extras = extras;
            if (targets.length > 0) primitive.targets = targets;
            if (geometry.index !== null) {
              primitive.indices = processAccessor(
                geometry.index,
                geometry,
                groups[i].start,
                groups[i].count
              );
            }
            var material = processMaterial(materials[groups[i].materialIndex]);
            if (material !== null) {
              primitive.material = material;
            }
            primitives.push(primitive);
          }
          if (didForceIndices) {
            geometry.setIndex(null);
          }
          gltfMesh.primitives = primitives;
          if (!outputJSON.meshes) {
            outputJSON.meshes = [];
          }
          outputJSON.meshes.push(gltfMesh);
          return outputJSON.meshes.length - 1;
        }
        function processCamera(camera) {
          if (!outputJSON.cameras) {
            outputJSON.cameras = [];
          }
          var isOrtho = camera.isOrthographicCamera;
          var gltfCamera = { type: isOrtho ? "orthographic" : "perspective" };
          if (isOrtho) {
            gltfCamera.orthographic = {
              xmag: camera.right * 2,
              ymag: camera.top * 2,
              zfar: camera.far <= 0 ? 0.001 : camera.far,
              znear: camera.near < 0 ? 0 : camera.near
            };
          } else {
            gltfCamera.perspective = {
              aspectRatio: camera.aspect,
              yfov: THREE.Math.degToRad(camera.fov) / camera.aspect,
              zfar: camera.far <= 0 ? 0.001 : camera.far,
              znear: camera.near < 0 ? 0 : camera.near
            };
          }
          if (camera.name !== "") {
            gltfCamera.name = camera.type;
          }
          outputJSON.cameras.push(gltfCamera);
          return outputJSON.cameras.length - 1;
        }
        function processAnimation(clip, root) {
          if (!outputJSON.animations) {
            outputJSON.animations = [];
          }
          var channels = [];
          var samplers = [];
          for (var i = 0; i < clip.tracks.length; ++i) {
            var track = clip.tracks[i];
            var trackBinding = THREE.PropertyBinding.parseTrackName(track.name);
            var trackNode = THREE.PropertyBinding.findNode(
              root,
              trackBinding.nodeName
            );
            var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
            if (trackBinding.objectName === "bones") {
              if (trackNode.isSkinnedMesh === true) {
                trackNode = trackNode.skeleton.getBoneByName(
                  trackBinding.objectIndex
                );
              } else {
                trackNode = undefined;
              }
            }
            if (!trackNode || !trackProperty) {
              console.warn(
                'THREE.GLTFExporter: Could not export animation track "%s".',
                track.name
              );
              return null;
            }
            var inputItemSize = 1;
            var outputItemSize = track.values.length / track.times.length;
            if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
              if (
                trackNode.morphTargetInfluences.length !== 1 &&
                trackBinding.propertyIndex !== undefined
              ) {
                console.warn(
                  'THREE.GLTFExporter: Skipping animation track "%s". ' +
                    "Morph target keyframe tracks must target all available morph targets " +
                    "for the given mesh.",
                  track.name
                );
                continue;
              }
              outputItemSize /= trackNode.morphTargetInfluences.length;
            }
            var interpolation;
            if (
              track.createInterpolant
                .isInterpolantFactoryMethodGLTFCubicSpline === true
            ) {
              interpolation = "CUBICSPLINE";
              outputItemSize /= 3;
            } else if (track.getInterpolation() === THREE.InterpolateDiscrete) {
              interpolation = "STEP";
            } else {
              interpolation = "LINEAR";
            }
            samplers.push({
              input: processAccessor(
                new THREE.BufferAttribute(track.times, inputItemSize)
              ),
              output: processAccessor(
                new THREE.BufferAttribute(track.values, outputItemSize)
              ),
              interpolation: interpolation
            });
            channels.push({
              sampler: samplers.length - 1,
              target: { node: nodeMap.get(trackNode), path: trackProperty }
            });
          }
          outputJSON.animations.push({
            name: clip.name || "clip_" + outputJSON.animations.length,
            samplers: samplers,
            channels: channels
          });
          return outputJSON.animations.length - 1;
        }
        function processSkin(object) {
          var node = outputJSON.nodes[nodeMap.get(object)];
          var skeleton = object.skeleton;
          var rootJoint = object.skeleton.bones[0];
          if (rootJoint === undefined) return null;
          var joints = [];
          var inverseBindMatrices = new Float32Array(
            skeleton.bones.length * 16
          );
          for (var i = 0; i < skeleton.bones.length; ++i) {
            joints.push(nodeMap.get(skeleton.bones[i]));
            skeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);
          }
          if (outputJSON.skins === undefined) {
            outputJSON.skins = [];
          }
          outputJSON.skins.push({
            inverseBindMatrices: processAccessor(
              new THREE.BufferAttribute(inverseBindMatrices, 16)
            ),
            joints: joints,
            skeleton: nodeMap.get(rootJoint)
          });
          var skinIndex = (node.skin = outputJSON.skins.length - 1);
          return skinIndex;
        }
        function processNode(object) {
          if (object.isLight) {
            console.warn(
              "GLTFExporter: Unsupported node type:",
              object.constructor.name
            );
            return null;
          }
          if (!outputJSON.nodes) {
            outputJSON.nodes = [];
          }
          var gltfNode = {};
          if (options.trs) {
            var rotation = object.quaternion.toArray();
            var position = object.position.toArray();
            var scale = object.scale.toArray();
            if (!equalArray(rotation, [0, 0, 0, 1])) {
              gltfNode.rotation = rotation;
            }
            if (!equalArray(position, [0, 0, 0])) {
              gltfNode.translation = position;
            }
            if (!equalArray(scale, [1, 1, 1])) {
              gltfNode.scale = scale;
            }
          } else {
            object.updateMatrix();
            if (
              !equalArray(object.matrix.elements, [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              ])
            ) {
              gltfNode.matrix = object.matrix.elements;
            }
          }
          if (object.name !== "") {
            gltfNode.name = String(object.name);
          }
          if (object.userData && Object.keys(object.userData).length > 0) {
            gltfNode.extras = serializeUserData(object);
          }
          if (object.isMesh || object.isLine || object.isPoints) {
            var mesh = processMesh(object);
            if (mesh !== null) {
              gltfNode.mesh = mesh;
            }
          } else if (object.isCamera) {
            gltfNode.camera = processCamera(object);
          }
          if (object.isSkinnedMesh) {
            skins.push(object);
          }
          if (object.children.length > 0) {
            var children = [];
            for (var i = 0, l = object.children.length; i < l; i++) {
              var child = object.children[i];
              if (child.visible || options.onlyVisible === false) {
                var node = processNode(child);
                if (node !== null) {
                  children.push(node);
                }
              }
            }
            if (children.length > 0) {
              gltfNode.children = children;
            }
          }
          outputJSON.nodes.push(gltfNode);
          var nodeIndex = outputJSON.nodes.length - 1;
          nodeMap.set(object, nodeIndex);
          return nodeIndex;
        }
        function processScene(scene) {
          if (!outputJSON.scenes) {
            outputJSON.scenes = [];
            outputJSON.scene = 0;
          }
          var gltfScene = { nodes: [] };
          if (scene.name !== "") {
            gltfScene.name = scene.name;
          }
          outputJSON.scenes.push(gltfScene);
          var nodes = [];
          for (var i = 0, l = scene.children.length; i < l; i++) {
            var child = scene.children[i];
            if (child.visible || options.onlyVisible === false) {
              var node = processNode(child);
              if (node !== null) {
                nodes.push(node);
              }
            }
          }
          if (nodes.length > 0) {
            gltfScene.nodes = nodes;
          }
        }
        function processObjects(objects) {
          var scene = new THREE.Scene();
          scene.name = "AuxScene";
          for (var i = 0; i < objects.length; i++) {
            scene.children.push(objects[i]);
          }
          processScene(scene);
        }
        function processInput(input) {
          input = input instanceof Array ? input : [input];
          var objectsWithoutScene = [];
          for (var i = 0; i < input.length; i++) {
            if (input[i] instanceof THREE.Scene) {
              processScene(input[i]);
            } else {
              objectsWithoutScene.push(input[i]);
            }
          }
          if (objectsWithoutScene.length > 0) {
            processObjects(objectsWithoutScene);
          }
          for (var i = 0; i < skins.length; ++i) {
            processSkin(skins[i]);
          }
          for (var i = 0; i < options.animations.length; ++i) {
            processAnimation(options.animations[i], input[0]);
          }
        }
        processInput(input);
        Promise.all(pending).then(function() {
          var blob = new Blob(buffers, { type: "application/octet-stream" });
          var extensionsUsedList = Object.keys(extensionsUsed);
          if (extensionsUsedList.length > 0)
            outputJSON.extensionsUsed = extensionsUsedList;
          if (outputJSON.buffers && outputJSON.buffers.length > 0) {
            outputJSON.buffers[0].byteLength = blob.size;
            var reader = new window.FileReader();
            if (options.binary === true) {
              var GLB_HEADER_BYTES = 12;
              var GLB_HEADER_MAGIC = 0x46546c67;
              var GLB_VERSION = 2;
              var GLB_CHUNK_PREFIX_BYTES = 8;
              var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
              var GLB_CHUNK_TYPE_BIN = 0x004e4942;
              reader.readAsArrayBuffer(blob);
              reader.onloadend = function() {
                var binaryChunk = getPaddedArrayBuffer(reader.result);
                var binaryChunkPrefix = new DataView(
                  new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES)
                );
                binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
                binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
                var jsonChunk = getPaddedArrayBuffer(
                  stringToArrayBuffer(JSON.stringify(outputJSON)),
                  0x20
                );
                var jsonChunkPrefix = new DataView(
                  new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES)
                );
                jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
                jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
                var header = new ArrayBuffer(GLB_HEADER_BYTES);
                var headerView = new DataView(header);
                headerView.setUint32(0, GLB_HEADER_MAGIC, true);
                headerView.setUint32(4, GLB_VERSION, true);
                var totalByteLength =
                  GLB_HEADER_BYTES +
                  jsonChunkPrefix.byteLength +
                  jsonChunk.byteLength +
                  binaryChunkPrefix.byteLength +
                  binaryChunk.byteLength;
                headerView.setUint32(8, totalByteLength, true);
                var glbBlob = new Blob(
                  [
                    header,
                    jsonChunkPrefix,
                    jsonChunk,
                    binaryChunkPrefix,
                    binaryChunk
                  ],
                  { type: "application/octet-stream" }
                );
                var glbReader = new window.FileReader();
                glbReader.readAsArrayBuffer(glbBlob);
                glbReader.onloadend = function() {
                  onDone(glbReader.result);
                };
              };
            } else {
              reader.readAsDataURL(blob);
              reader.onloadend = function() {
                var base64data = reader.result;
                outputJSON.buffers[0].uri = base64data;
                onDone(outputJSON);
              };
            }
          } else {
            onDone(outputJSON);
          }
        });
      }
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    (function(i, s, o, g, r, a, m) {
      i["GoogleAnalyticsObject"] = r;
      (i[r] =
        i[r] ||
        function() {
          (i[r].q = i[r].q || []).push(arguments);
        }),
        (i[r].l = 1 * new Date());
      (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
      a.async = 1;
      a.src = g;
      a.setAttribute("data-aframe-inspector", "");
      m.parentNode.insertBefore(a, m);
    })(
      window,
      document,
      "script",
      "https://www.google-analytics.com/analytics.js",
      "ga"
    );
    ga("create", "UA-80530812-1", "auto");
    ga("send", "pageview");
  },
  function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__,
      __WEBPACK_AMD_DEFINE_ARRAY__,
      __WEBPACK_AMD_DEFINE_RESULT__;
    (function(global, factory) {
      if (true) {
        !((__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(250)]),
        (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
        (__WEBPACK_AMD_DEFINE_RESULT__ =
          typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
            ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                exports,
                __WEBPACK_AMD_DEFINE_ARRAY__
              )
            : __WEBPACK_AMD_DEFINE_FACTORY__),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if (typeof exports !== "undefined") {
        factory(module, require("select"));
      } else {
        var mod = { exports: {} };
        factory(mod, global.select);
        global.clipboardAction = mod.exports;
      }
    })(this, function(module, _select) {
      "use strict";
      var _select2 = _interopRequireDefault(_select);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function(obj) {
              return typeof obj;
            }
          : function(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _createClass = (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      var ClipboardAction = (function() {
        function ClipboardAction(options) {
          _classCallCheck(this, ClipboardAction);
          this.resolveOptions(options);
          this.initSelection();
        }
        _createClass(ClipboardAction, [
          {
            key: "resolveOptions",
            value: function resolveOptions() {
              var options =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              this.action = options.action;
              this.container = options.container;
              this.emitter = options.emitter;
              this.target = options.target;
              this.text = options.text;
              this.trigger = options.trigger;
              this.selectedText = "";
            }
          },
          {
            key: "initSelection",
            value: function initSelection() {
              if (this.text) {
                this.selectFake();
              } else if (this.target) {
                this.selectTarget();
              }
            }
          },
          {
            key: "selectFake",
            value: function selectFake() {
              var _this = this;
              var isRTL = document.documentElement.getAttribute("dir") == "rtl";
              this.removeFake();
              this.fakeHandlerCallback = function() {
                return _this.removeFake();
              };
              this.fakeHandler =
                this.container.addEventListener(
                  "click",
                  this.fakeHandlerCallback
                ) || true;
              this.fakeElem = document.createElement("textarea");
              this.fakeElem.style.fontSize = "12pt";
              this.fakeElem.style.border = "0";
              this.fakeElem.style.padding = "0";
              this.fakeElem.style.margin = "0";
              this.fakeElem.style.position = "absolute";
              this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
              var yPosition =
                window.pageYOffset || document.documentElement.scrollTop;
              this.fakeElem.style.top = yPosition + "px";
              this.fakeElem.setAttribute("readonly", "");
              this.fakeElem.value = this.text;
              this.container.appendChild(this.fakeElem);
              this.selectedText = (0, _select2.default)(this.fakeElem);
              this.copyText();
            }
          },
          {
            key: "removeFake",
            value: function removeFake() {
              if (this.fakeHandler) {
                this.container.removeEventListener(
                  "click",
                  this.fakeHandlerCallback
                );
                this.fakeHandler = null;
                this.fakeHandlerCallback = null;
              }
              if (this.fakeElem) {
                this.container.removeChild(this.fakeElem);
                this.fakeElem = null;
              }
            }
          },
          {
            key: "selectTarget",
            value: function selectTarget() {
              this.selectedText = (0, _select2.default)(this.target);
              this.copyText();
            }
          },
          {
            key: "copyText",
            value: function copyText() {
              var succeeded = void 0;
              try {
                succeeded = document.execCommand(this.action);
              } catch (err) {
                succeeded = false;
              }
              this.handleResult(succeeded);
            }
          },
          {
            key: "handleResult",
            value: function handleResult(succeeded) {
              this.emitter.emit(succeeded ? "success" : "error", {
                action: this.action,
                text: this.selectedText,
                trigger: this.trigger,
                clearSelection: this.clearSelection.bind(this)
              });
            }
          },
          {
            key: "clearSelection",
            value: function clearSelection() {
              if (this.trigger) {
                this.trigger.focus();
              }
              window.getSelection().removeAllRanges();
            }
          },
          {
            key: "destroy",
            value: function destroy() {
              this.removeFake();
            }
          },
          {
            key: "action",
            set: function set() {
              var action =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : "copy";
              this._action = action;
              if (this._action !== "copy" && this._action !== "cut") {
                throw new Error(
                  'Invalid "action" value, use either "copy" or "cut"'
                );
              }
            },
            get: function get() {
              return this._action;
            }
          },
          {
            key: "target",
            set: function set(target) {
              if (target !== undefined) {
                if (
                  target &&
                  (typeof target === "undefined"
                    ? "undefined"
                    : _typeof(target)) === "object" &&
                  target.nodeType === 1
                ) {
                  if (
                    this.action === "copy" &&
                    target.hasAttribute("disabled")
                  ) {
                    throw new Error(
                      'Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'
                    );
                  }
                  if (
                    this.action === "cut" &&
                    (target.hasAttribute("readonly") ||
                      target.hasAttribute("disabled"))
                  ) {
                    throw new Error(
                      'Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes'
                    );
                  }
                  this._target = target;
                } else {
                  throw new Error(
                    'Invalid "target" value, use a valid Element'
                  );
                }
              }
            },
            get: function get() {
              return this._target;
            }
          }
        ]);
        return ClipboardAction;
      })();
      module.exports = ClipboardAction;
    });
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var __WEBPACK_IMPORTED_MODULE_0__emotion_memoize__ = __webpack_require__(
      108
    );
    var __WEBPACK_IMPORTED_MODULE_1__emotion_unitless__ = __webpack_require__(
      110
    );
    var __WEBPACK_IMPORTED_MODULE_2__emotion_hash__ = __webpack_require__(107);
    var __WEBPACK_IMPORTED_MODULE_3__emotion_stylis__ = __webpack_require__(
      109
    );
    var __WEBPACK_IMPORTED_MODULE_4_stylis_rule_sheet__ = __webpack_require__(
      253
    );
    var __WEBPACK_IMPORTED_MODULE_4_stylis_rule_sheet___default = __webpack_require__.n(
      __WEBPACK_IMPORTED_MODULE_4_stylis_rule_sheet__
    );
    var hyphenateRegex = /[A-Z]|^ms/g;
    var processStyleName = __webpack_require__.i(
      __WEBPACK_IMPORTED_MODULE_0__emotion_memoize__["a"]
    )(function(styleName) {
      return styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue(key, value) {
      if (value == null || typeof value === "boolean") {
        return "";
      }
      if (
        __WEBPACK_IMPORTED_MODULE_1__emotion_unitless__["a"][key] !== 1 &&
        key.charCodeAt(1) !== 45 &&
        !isNaN(value) &&
        value !== 0
      ) {
        return value + "px";
      }
      return value;
    };
    if (false) {
      var contentValuePattern = /(attr|calc|counters?|url)\(/;
      var contentValues = [
        "normal",
        "none",
        "counter",
        "open-quote",
        "close-quote",
        "no-open-quote",
        "no-close-quote",
        "initial",
        "inherit",
        "unset"
      ];
      var oldProcessStyleValue = processStyleValue;
      processStyleValue = function processStyleValue(key, value) {
        if (key === "content") {
          if (
            typeof value !== "string" ||
            (contentValues.indexOf(value) === -1 &&
              !contentValuePattern.test(value) &&
              (value.charAt(0) !== value.charAt(value.length - 1) ||
                (value.charAt(0) !== '"' && value.charAt(0) !== "'")))
          ) {
            console.error(
              "You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" +
                value +
                "\"'`"
            );
          }
        }
        return oldProcessStyleValue(key, value);
      };
    }
    var classnames = function classnames(args) {
      var len = args.length;
      var i = 0;
      var cls = "";
      for (; i < len; i++) {
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;
        switch (typeof arg) {
          case "boolean":
            break;
          case "function":
            if (false) {
              console.error(
                "Passing functions to cx is deprecated and will be removed in the next major version of Emotion.\n" +
                  "Please call the function before passing it to cx."
              );
            }
            toAdd = classnames([arg()]);
            break;
          case "object": {
            if (Array.isArray(arg)) {
              toAdd = classnames(arg);
            } else {
              toAdd = "";
              for (var k in arg) {
                if (arg[k] && k) {
                  toAdd && (toAdd += " ");
                  toAdd += k;
                }
              }
            }
            break;
          }
          default: {
            toAdd = arg;
          }
        }
        if (toAdd) {
          cls && (cls += " ");
          cls += toAdd;
        }
      }
      return cls;
    };
    var isBrowser = typeof document !== "undefined";
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
    function makeStyleTag(opts) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", opts.key || "");
      if (opts.nonce !== undefined) {
        tag.setAttribute("nonce", opts.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      (opts.container !== undefined
        ? opts.container
        : document.head
      ).appendChild(tag);
      return tag;
    }
    var StyleSheet = (function() {
      function StyleSheet(options) {
        this.isSpeedy = "production" === "production";
        this.tags = [];
        this.ctr = 0;
        this.opts = options;
      }
      var _proto = StyleSheet.prototype;
      _proto.inject = function inject() {
        if (this.injected) {
          throw new Error("already injected!");
        }
        this.tags[0] = makeStyleTag(this.opts);
        this.injected = true;
      };
      _proto.speedy = function speedy(bool) {
        if (this.ctr !== 0) {
          throw new Error("cannot change speedy now");
        }
        this.isSpeedy = !!bool;
      };
      _proto.insert = function insert(rule, sourceMap) {
        if (this.isSpeedy) {
          var tag = this.tags[this.tags.length - 1];
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e) {
            if (false) {
              console.warn("illegal rule", rule);
            }
          }
        } else {
          var _tag = makeStyleTag(this.opts);
          this.tags.push(_tag);
          _tag.appendChild(document.createTextNode(rule + (sourceMap || "")));
        }
        this.ctr++;
        if (this.ctr % 65000 === 0) {
          this.tags.push(makeStyleTag(this.opts));
        }
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
        this.injected = false;
      };
      return StyleSheet;
    })();
    function createEmotion(context, options) {
      if (context.__SECRET_EMOTION__ !== undefined) {
        return context.__SECRET_EMOTION__;
      }
      if (options === undefined) options = {};
      var key = options.key || "css";
      if (false) {
        if (/[^a-z-]/.test(key)) {
          throw new Error(
            'Emotion key must only contain lower case alphabetical characters and - but "' +
              key +
              '" was passed'
          );
        }
      }
      var current;
      function insertRule(rule) {
        current += rule;
        if (isBrowser) {
          sheet.insert(rule, currentSourceMap);
        }
      }
      var insertionPlugin = __WEBPACK_IMPORTED_MODULE_4_stylis_rule_sheet___default()(
        insertRule
      );
      var stylisOptions;
      if (options.prefix !== undefined) {
        stylisOptions = { prefix: options.prefix };
      }
      var caches = {
        registered: {},
        inserted: {},
        nonce: options.nonce,
        key: key
      };
      var sheet = new StyleSheet(options);
      if (isBrowser) {
        sheet.inject();
      }
      var stylis = new __WEBPACK_IMPORTED_MODULE_3__emotion_stylis__["a"](
        stylisOptions
      );
      stylis.use(options.stylisPlugins)(insertionPlugin);
      var currentSourceMap = "";
      function handleInterpolation(
        interpolation,
        couldBeSelectorInterpolation
      ) {
        if (interpolation == null) {
          return "";
        }
        switch (typeof interpolation) {
          case "boolean":
            return "";
          case "function":
            if (interpolation.__emotion_styles !== undefined) {
              var selector = interpolation.toString();
              if (
                selector === "NO_COMPONENT_SELECTOR" &&
                "production" !== "production"
              ) {
                throw new Error(
                  "Component selectors can only be used in conjunction with babel-plugin-emotion."
                );
              }
              return selector;
            }
            if (this === undefined && "production" !== "production") {
              console.error(
                "Interpolating functions in css calls is deprecated and will be removed in the next major version of Emotion.\n" +
                  "If you want to have a css call based on props, create a function that returns a css call like this\n" +
                  "let dynamicStyle = (props) => css`color: ${props.color}`\n" +
                  "It can be called directly with props or interpolated in a styled call like this\n" +
                  "let SomeComponent = styled('div')`${dynamicStyle}`"
              );
            }
            return handleInterpolation.call(
              this,
              this === undefined
                ? interpolation()
                : interpolation(this.mergedProps, this.context),
              couldBeSelectorInterpolation
            );
          case "object":
            return createStringFromObject.call(this, interpolation);
          default:
            var cached = caches.registered[interpolation];
            return couldBeSelectorInterpolation === false &&
              cached !== undefined
              ? cached
              : interpolation;
        }
      }
      var objectToStringCache = new WeakMap();
      function createStringFromObject(obj) {
        if (objectToStringCache.has(obj)) {
          return objectToStringCache.get(obj);
        }
        var string = "";
        if (Array.isArray(obj)) {
          obj.forEach(function(interpolation) {
            string += handleInterpolation.call(this, interpolation, false);
          }, this);
        } else {
          Object.keys(obj).forEach(function(key) {
            if (typeof obj[key] !== "object") {
              if (caches.registered[obj[key]] !== undefined) {
                string += key + "{" + caches.registered[obj[key]] + "}";
              } else {
                string +=
                  processStyleName(key) +
                  ":" +
                  processStyleValue(key, obj[key]) +
                  ";";
              }
            } else {
              if (
                key === "NO_COMPONENT_SELECTOR" &&
                "production" !== "production"
              ) {
                throw new Error(
                  "Component selectors can only be used in conjunction with babel-plugin-emotion."
                );
              }
              if (
                Array.isArray(obj[key]) &&
                typeof obj[key][0] === "string" &&
                caches.registered[obj[key][0]] === undefined
              ) {
                obj[key].forEach(function(value) {
                  string +=
                    processStyleName(key) +
                    ":" +
                    processStyleValue(key, value) +
                    ";";
                });
              } else {
                string +=
                  key +
                  "{" +
                  handleInterpolation.call(this, obj[key], false) +
                  "}";
              }
            }
          }, this);
        }
        objectToStringCache.set(obj, string);
        return string;
      }
      var name;
      var stylesWithLabel;
      var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
      var createClassName = function createClassName(styles, identifierName) {
        return (
          __webpack_require__.i(
            __WEBPACK_IMPORTED_MODULE_2__emotion_hash__["a"]
          )(styles + identifierName) + identifierName
        );
      };
      if (false) {
        var oldCreateClassName = createClassName;
        var sourceMappingUrlPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
        createClassName = function createClassName(styles, identifierName) {
          return oldCreateClassName(
            styles.replace(sourceMappingUrlPattern, function(sourceMap) {
              currentSourceMap = sourceMap;
              return "";
            }),
            identifierName
          );
        };
      }
      var createStyles = function createStyles(strings) {
        var stringMode = true;
        var styles = "";
        var identifierName = "";
        if (strings == null || strings.raw === undefined) {
          stringMode = false;
          styles += handleInterpolation.call(this, strings, false);
        } else {
          styles += strings[0];
        }
        for (
          var _len = arguments.length,
            interpolations = new Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          interpolations[_key - 1] = arguments[_key];
        }
        interpolations.forEach(function(interpolation, i) {
          styles += handleInterpolation.call(
            this,
            interpolation,
            styles.charCodeAt(styles.length - 1) === 46
          );
          if (stringMode === true && strings[i + 1] !== undefined) {
            styles += strings[i + 1];
          }
        }, this);
        stylesWithLabel = styles;
        styles = styles.replace(labelPattern, function(match, p1) {
          identifierName += "-" + p1;
          return "";
        });
        name = createClassName(styles, identifierName);
        return styles;
      };
      if (false) {
        var oldStylis = stylis;
        stylis = function stylis(selector, styles) {
          oldStylis(selector, styles);
          currentSourceMap = "";
        };
      }
      function insert(scope, styles) {
        if (caches.inserted[name] === undefined) {
          current = "";
          stylis(scope, styles);
          caches.inserted[name] = current;
        }
      }
      var css = function css() {
        var styles = createStyles.apply(this, arguments);
        var selector = key + "-" + name;
        if (caches.registered[selector] === undefined) {
          caches.registered[selector] = stylesWithLabel;
        }
        insert("." + selector, styles);
        return selector;
      };
      var keyframes = function keyframes() {
        var styles = createStyles.apply(this, arguments);
        var animation = "animation-" + name;
        insert("", "@keyframes " + animation + "{" + styles + "}");
        return animation;
      };
      var injectGlobal = function injectGlobal() {
        var styles = createStyles.apply(this, arguments);
        insert("", styles);
      };
      function getRegisteredStyles(registeredStyles, classNames) {
        var rawClassName = "";
        classNames.split(" ").forEach(function(className) {
          if (caches.registered[className] !== undefined) {
            registeredStyles.push(className);
          } else {
            rawClassName += className + " ";
          }
        });
        return rawClassName;
      }
      function merge(className, sourceMap) {
        var registeredStyles = [];
        var rawClassName = getRegisteredStyles(registeredStyles, className);
        if (registeredStyles.length < 2) {
          return className;
        }
        return rawClassName + css(registeredStyles, sourceMap);
      }
      function cx() {
        for (
          var _len2 = arguments.length,
            classNames = new Array(_len2),
            _key2 = 0;
          _key2 < _len2;
          _key2++
        ) {
          classNames[_key2] = arguments[_key2];
        }
        return merge(classnames(classNames));
      }
      function hydrateSingleId(id) {
        caches.inserted[id] = true;
      }
      function hydrate(ids) {
        ids.forEach(hydrateSingleId);
      }
      function flush() {
        if (isBrowser) {
          sheet.flush();
          sheet.inject();
        }
        caches.inserted = {};
        caches.registered = {};
      }
      if (isBrowser) {
        var chunks = document.querySelectorAll("[data-emotion-" + key + "]");
        Array.prototype.forEach.call(chunks, function(node) {
          sheet.tags[0].parentNode.insertBefore(node, sheet.tags[0]);
          node
            .getAttribute("data-emotion-" + key)
            .split(" ")
            .forEach(hydrateSingleId);
        });
      }
      var emotion = {
        flush: flush,
        hydrate: hydrate,
        cx: cx,
        merge: merge,
        getRegisteredStyles: getRegisteredStyles,
        injectGlobal: injectGlobal,
        keyframes: keyframes,
        css: css,
        sheet: sheet,
        caches: caches
      };
      context.__SECRET_EMOTION__ = emotion;
      return emotion;
    }
    __webpack_exports__["a"] = createEmotion;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var emptyObject = __webpack_require__(30);
    var _invariant = __webpack_require__(0);
    if (false) {
      var warning = require("fbjs/lib/warning");
    }
    var MIXINS_KEY = "mixins";
    function identity(fn) {
      return fn;
    }
    var ReactPropTypeLocationNames;
    if (false) {
      ReactPropTypeLocationNames = {
        prop: "prop",
        context: "context",
        childContext: "child context"
      };
    } else {
      ReactPropTypeLocationNames = {};
    }
    function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
      var injectedMixins = [];
      var ReactClassInterface = {
        mixins: "DEFINE_MANY",
        statics: "DEFINE_MANY",
        propTypes: "DEFINE_MANY",
        contextTypes: "DEFINE_MANY",
        childContextTypes: "DEFINE_MANY",
        getDefaultProps: "DEFINE_MANY_MERGED",
        getInitialState: "DEFINE_MANY_MERGED",
        getChildContext: "DEFINE_MANY_MERGED",
        render: "DEFINE_ONCE",
        componentWillMount: "DEFINE_MANY",
        componentDidMount: "DEFINE_MANY",
        componentWillReceiveProps: "DEFINE_MANY",
        shouldComponentUpdate: "DEFINE_ONCE",
        componentWillUpdate: "DEFINE_MANY",
        componentDidUpdate: "DEFINE_MANY",
        componentWillUnmount: "DEFINE_MANY",
        UNSAFE_componentWillMount: "DEFINE_MANY",
        UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
        UNSAFE_componentWillUpdate: "DEFINE_MANY",
        updateComponent: "OVERRIDE_BASE"
      };
      var ReactClassStaticInterface = {
        getDerivedStateFromProps: "DEFINE_MANY_MERGED"
      };
      var RESERVED_SPEC_KEYS = {
        displayName: function(Constructor, displayName) {
          Constructor.displayName = displayName;
        },
        mixins: function(Constructor, mixins) {
          if (mixins) {
            for (var i = 0; i < mixins.length; i++) {
              mixSpecIntoComponent(Constructor, mixins[i]);
            }
          }
        },
        childContextTypes: function(Constructor, childContextTypes) {
          if (false) {
            validateTypeDef(Constructor, childContextTypes, "childContext");
          }
          Constructor.childContextTypes = _assign(
            {},
            Constructor.childContextTypes,
            childContextTypes
          );
        },
        contextTypes: function(Constructor, contextTypes) {
          if (false) {
            validateTypeDef(Constructor, contextTypes, "context");
          }
          Constructor.contextTypes = _assign(
            {},
            Constructor.contextTypes,
            contextTypes
          );
        },
        getDefaultProps: function(Constructor, getDefaultProps) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps = createMergedResultFunction(
              Constructor.getDefaultProps,
              getDefaultProps
            );
          } else {
            Constructor.getDefaultProps = getDefaultProps;
          }
        },
        propTypes: function(Constructor, propTypes) {
          if (false) {
            validateTypeDef(Constructor, propTypes, "prop");
          }
          Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
        },
        statics: function(Constructor, statics) {
          mixStaticSpecIntoComponent(Constructor, statics);
        },
        autobind: function() {}
      };
      function validateTypeDef(Constructor, typeDef, location) {
        for (var propName in typeDef) {
          if (typeDef.hasOwnProperty(propName)) {
            if (false) {
              warning(
                typeof typeDef[propName] === "function",
                "%s: %s type `%s` is invalid; it must be a function, usually from " +
                  "React.PropTypes.",
                Constructor.displayName || "ReactClass",
                ReactPropTypeLocationNames[location],
                propName
              );
            }
          }
        }
      }
      function validateMethodOverride(isAlreadyDefined, name) {
        var specPolicy = ReactClassInterface.hasOwnProperty(name)
          ? ReactClassInterface[name]
          : null;
        if (ReactClassMixin.hasOwnProperty(name)) {
          _invariant(
            specPolicy === "OVERRIDE_BASE",
            "ReactClassInterface: You are attempting to override " +
              "`%s` from your class specification. Ensure that your method names " +
              "do not overlap with React methods.",
            name
          );
        }
        if (isAlreadyDefined) {
          _invariant(
            specPolicy === "DEFINE_MANY" || specPolicy === "DEFINE_MANY_MERGED",
            "ReactClassInterface: You are attempting to define " +
              "`%s` on your component more than once. This conflict may be due " +
              "to a mixin.",
            name
          );
        }
      }
      function mixSpecIntoComponent(Constructor, spec) {
        if (!spec) {
          if (false) {
            var typeofSpec = typeof spec;
            var isMixinValid = typeofSpec === "object" && spec !== null;
            if (process.env.NODE_ENV !== "production") {
              warning(
                isMixinValid,
                "%s: You're attempting to include a mixin that is either null " +
                  "or not an object. Check the mixins included by the component, " +
                  "as well as any mixins they include themselves. " +
                  "Expected object but got %s.",
                Constructor.displayName || "ReactClass",
                spec === null ? null : typeofSpec
              );
            }
          }
          return;
        }
        _invariant(
          typeof spec !== "function",
          "ReactClass: You're attempting to " +
            "use a component class or function as a mixin. Instead, just use a " +
            "regular object."
        );
        _invariant(
          !isValidElement(spec),
          "ReactClass: You're attempting to " +
            "use a component as a mixin. Instead, just use a regular object."
        );
        var proto = Constructor.prototype;
        var autoBindPairs = proto.__reactAutoBindPairs;
        if (spec.hasOwnProperty(MIXINS_KEY)) {
          RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
        }
        for (var name in spec) {
          if (!spec.hasOwnProperty(name)) {
            continue;
          }
          if (name === MIXINS_KEY) {
            continue;
          }
          var property = spec[name];
          var isAlreadyDefined = proto.hasOwnProperty(name);
          validateMethodOverride(isAlreadyDefined, name);
          if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
            RESERVED_SPEC_KEYS[name](Constructor, property);
          } else {
            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
            var isFunction = typeof property === "function";
            var shouldAutoBind =
              isFunction &&
              !isReactClassMethod &&
              !isAlreadyDefined &&
              spec.autobind !== false;
            if (shouldAutoBind) {
              autoBindPairs.push(name, property);
              proto[name] = property;
            } else {
              if (isAlreadyDefined) {
                var specPolicy = ReactClassInterface[name];
                _invariant(
                  isReactClassMethod &&
                    (specPolicy === "DEFINE_MANY_MERGED" ||
                      specPolicy === "DEFINE_MANY"),
                  "ReactClass: Unexpected spec policy %s for key %s " +
                    "when mixing in component specs.",
                  specPolicy,
                  name
                );
                if (specPolicy === "DEFINE_MANY_MERGED") {
                  proto[name] = createMergedResultFunction(
                    proto[name],
                    property
                  );
                } else if (specPolicy === "DEFINE_MANY") {
                  proto[name] = createChainedFunction(proto[name], property);
                }
              } else {
                proto[name] = property;
                if (false) {
                  if (typeof property === "function" && spec.displayName) {
                    proto[name].displayName = spec.displayName + "_" + name;
                  }
                }
              }
            }
          }
        }
      }
      function mixStaticSpecIntoComponent(Constructor, statics) {
        if (!statics) {
          return;
        }
        for (var name in statics) {
          var property = statics[name];
          if (!statics.hasOwnProperty(name)) {
            continue;
          }
          var isReserved = name in RESERVED_SPEC_KEYS;
          _invariant(
            !isReserved,
            "ReactClass: You are attempting to define a reserved " +
              'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
              "as an instance property instead; it will still be accessible on the " +
              "constructor.",
            name
          );
          var isAlreadyDefined = name in Constructor;
          if (isAlreadyDefined) {
            var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
              ? ReactClassStaticInterface[name]
              : null;
            _invariant(
              specPolicy === "DEFINE_MANY_MERGED",
              "ReactClass: You are attempting to define " +
                "`%s` on your component more than once. This conflict may be " +
                "due to a mixin.",
              name
            );
            Constructor[name] = createMergedResultFunction(
              Constructor[name],
              property
            );
            return;
          }
          Constructor[name] = property;
        }
      }
      function mergeIntoWithNoDuplicateKeys(one, two) {
        _invariant(
          one && two && typeof one === "object" && typeof two === "object",
          "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects."
        );
        for (var key in two) {
          if (two.hasOwnProperty(key)) {
            _invariant(
              one[key] === undefined,
              "mergeIntoWithNoDuplicateKeys(): " +
                "Tried to merge two objects with the same key: `%s`. This conflict " +
                "may be due to a mixin; in particular, this may be caused by two " +
                "getInitialState() or getDefaultProps() methods returning objects " +
                "with clashing keys.",
              key
            );
            one[key] = two[key];
          }
        }
        return one;
      }
      function createMergedResultFunction(one, two) {
        return function mergedResult() {
          var a = one.apply(this, arguments);
          var b = two.apply(this, arguments);
          if (a == null) {
            return b;
          } else if (b == null) {
            return a;
          }
          var c = {};
          mergeIntoWithNoDuplicateKeys(c, a);
          mergeIntoWithNoDuplicateKeys(c, b);
          return c;
        };
      }
      function createChainedFunction(one, two) {
        return function chainedFunction() {
          one.apply(this, arguments);
          two.apply(this, arguments);
        };
      }
      function bindAutoBindMethod(component, method) {
        var boundMethod = method.bind(component);
        if (false) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            for (
              var _len = arguments.length,
                args = Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key];
            }
            if (newThis !== component && newThis !== null) {
              if (process.env.NODE_ENV !== "production") {
                warning(
                  false,
                  "bind(): React component methods may only be bound to the " +
                    "component instance. See %s",
                  componentName
                );
              }
            } else if (!args.length) {
              if (process.env.NODE_ENV !== "production") {
                warning(
                  false,
                  "bind(): You are binding a component method to the component. " +
                    "React does this for you automatically in a high-performance " +
                    "way, so you can safely remove this call. See %s",
                  componentName
                );
              }
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
      function bindAutoBindMethods(component) {
        var pairs = component.__reactAutoBindPairs;
        for (var i = 0; i < pairs.length; i += 2) {
          var autoBindKey = pairs[i];
          var method = pairs[i + 1];
          component[autoBindKey] = bindAutoBindMethod(component, method);
        }
      }
      var IsMountedPreMixin = {
        componentDidMount: function() {
          this.__isMounted = true;
        }
      };
      var IsMountedPostMixin = {
        componentWillUnmount: function() {
          this.__isMounted = false;
        }
      };
      var ReactClassMixin = {
        replaceState: function(newState, callback) {
          this.updater.enqueueReplaceState(this, newState, callback);
        },
        isMounted: function() {
          if (false) {
            warning(
              this.__didWarnIsMounted,
              "%s: isMounted is deprecated. Instead, make sure to clean up " +
                "subscriptions and pending requests in componentWillUnmount to " +
                "prevent memory leaks.",
              (this.constructor && this.constructor.displayName) ||
                this.name ||
                "Component"
            );
            this.__didWarnIsMounted = true;
          }
          return !!this.__isMounted;
        }
      };
      var ReactClassComponent = function() {};
      _assign(
        ReactClassComponent.prototype,
        ReactComponent.prototype,
        ReactClassMixin
      );
      function createClass(spec) {
        var Constructor = identity(function(props, context, updater) {
          if (false) {
            warning(
              this instanceof Constructor,
              "Something is calling a React component directly. Use a factory or " +
                "JSX instead. See: https://fb.me/react-legacyfactory"
            );
          }
          if (this.__reactAutoBindPairs.length) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState
            ? this.getInitialState()
            : null;
          if (false) {
            if (
              initialState === undefined &&
              this.getInitialState._isMockFunction
            ) {
              initialState = null;
            }
          }
          _invariant(
            typeof initialState === "object" && !Array.isArray(initialState),
            "%s.getInitialState(): must return an object or null",
            Constructor.displayName || "ReactCompositeComponent"
          );
          this.state = initialState;
        });
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        Constructor.prototype.__reactAutoBindPairs = [];
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, IsMountedPreMixin);
        mixSpecIntoComponent(Constructor, spec);
        mixSpecIntoComponent(Constructor, IsMountedPostMixin);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if (false) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        _invariant(
          Constructor.prototype.render,
          "createClass(...): Class specification must implement a `render` method."
        );
        if (false) {
          warning(
            !Constructor.prototype.componentShouldUpdate,
            "%s has a method called " +
              "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
              "The name is phrased as a question because the function is " +
              "expected to return a value.",
            spec.displayName || "A component"
          );
          warning(
            !Constructor.prototype.componentWillRecieveProps,
            "%s has a method called " +
              "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            spec.displayName || "A component"
          );
          warning(
            !Constructor.prototype.UNSAFE_componentWillRecieveProps,
            "%s has a method called UNSAFE_componentWillRecieveProps(). " +
              "Did you mean UNSAFE_componentWillReceiveProps()?",
            spec.displayName || "A component"
          );
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      }
      return createClass;
    }
    module.exports = factory;
  },
  function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(142)();
    exports.push([
      module.i,
      'body.aframe-inspector-opened,\n.toggle-edit {\n  font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Helvetica, Arial, sans-serif;\n}\n.wf-roboto-n4-active body.aframe-inspector-opened,\n.wf-roboto-n4-active .toggle-edit {\n  font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Helvetica, Arial, sans-serif;\n}\nbody.aframe-inspector-opened {\n  background: #1d1d1d;\n  color: #fff;\n  font-size: 12px;\n  margin: 0;\n  overflow: hidden;\n}\n#aframeInspector #toolbar {\n  background-color: #242424;\n}\n#aframeInspector #toolbar .toolbarActions {\n  padding: 0 0 5px;\n}\n#aframeInspector #toolbar .toolbarActions a.disabled {\n  color: #666;\n  cursor: default;\n}\n#aframeInspector #scenegraph {\n  background: #242424;\n  border-top: 1px solid #111;\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  padding-top: 32px;\n  width: 230px;\n}\n#aframeInspector #scenegraph .entity {\n  background: #242424;\n  cursor: pointer;\n  display: flex;\n  justify-content: space-between;\n  padding: 3px;\n  width: 100%;\n  white-space: nowrap;\n}\n#aframeInspector #scenegraph .entity:hover {\n  background: #1d2f39;\n}\n#aframeInspector #scenegraph .entity.active {\n  background-color: #155373;\n  color: #fff;\n}\n#aframeInspector #scenegraph .entity.active .component:hover {\n  color: #1888c1;\n}\n#aframeInspector #scenegraph .entity.active .entityActions {\n  display: inline;\n}\n#aframeInspector #scenegraph .entity.novisible.active span,\n#aframeInspector #scenegraph .entity.novisible.active .fa,\n#aframeInspector #scenegraph .entity.novisible.active .collapsespace,\n#aframeInspector #scenegraph .entity.novisible.active .id {\n  color: #999;\n}\n#aframeInspector #scenegraph .entity.novisible:not(.active) span,\n#aframeInspector #scenegraph .entity.novisible:not(.active) .fa,\n#aframeInspector #scenegraph .entity.novisible:not(.active) .collapsespace,\n#aframeInspector #scenegraph .entity.novisible:not(.active) .id {\n  color: #626262;\n}\n#aframeInspector #scenegraph .component:hover {\n  color: #1faaf2;\n}\n#aframeInspector #scenegraph .entityIcons {\n  margin-left: 2px;\n}\n#aframeInspector #scenegraph .entityActions {\n  display: none;\n  margin: 0 14px;\n}\n#aframeInspector #scenegraph .entityActions .button {\n  color: #fff;\n  font-size: 12px;\n  margin-left: 6px;\n}\n#aframeInspector #scenegraph .fa {\n  color: #ccc;\n}\n#aframeInspector #scenegraph .entityActions .fa:hover {\n  color: #1faaf2;\n}\n#aframeInspector #scenegraph .active .fa {\n  color: #fafafa;\n}\n#aframeInspector #scenegraph .id {\n  color: #ccc;\n}\n#aframeInspector #scenegraph .option.active .id {\n  color: #fff;\n}\n#aframeInspector #scenegraph .collapsespace {\n  color: #eee;\n  display: inline-block;\n  text-align: center;\n  width: 14px;\n}\n#aframeInspector #scenegraph .fa-eye {\n  color: #bbb;\n}\n#aframeInspector #scenegraph .icons a.button {\n  color: #fff;\n}\n#aframeInspector #scenegraph .search {\n  padding: 5px;\n  font-size: 16px;\n  position: relative;\n}\n#aframeInspector #scenegraph .search input {\n  color: #c3c3c3;\n  background: #1d1d1d;\n  border-radius: 5px;\n  height: 22px;\n  text-indent: 10px;\n  width: 216px;\n}\n#aframeInspector #scenegraph .search .fa-search {\n  position: absolute;\n  right: 14px;\n  top: 8px;\n}\n#aframeInspector #scenegraph .search .fa-times {\n  position: absolute;\n  right: 15px;\n  top: 9px;\n}\n#aframeInspector #scenegraph .outliner {\n  background: #242424;\n  color: #c3c3c3;\n  cursor: default;\n  flex: 1 1 auto;\n  font-size: 13px;\n  height: calc(100% - 98px);\n  outline: none;\n  overflow-y: auto;\n  padding: 0;\n  width: 230px;\n}\n#aframeInspector .scenegraph-bottom {\n  background-color: #323232;\n  border-top: 1px solid #111;\n  bottom: 10;\n  height: 40px;\n  left: 0;\n  z-index: 100;\n}\n#aframeInspector .scenegraph-bottom a {\n  float: right;\n  margin: 10px;\n}\n#aframeInspector .components {\n  background-color: #242424;\n  color: #c3c3c3;\n  height: 100%;\n  overflow: auto;\n  position: fixed;\n  width: 331px;\n}\n#aframeInspector div.vec2,\n#aframeInspector div.vec3,\n#aframeInspector div.vec4 {\n  display: inline;\n}\n#aframeInspector .vec2 input.number,\n#aframeInspector .vec3 input.number {\n  width: 40px;\n}\n#aframeInspector .vec4 input.number {\n  width: 34px;\n}\n#aframeInspector .collapsible-header {\n  align-items: center;\n  display: flex;\n  justify-content: space-between;\n}\n#aframeInspector .collapsible-header .entityPrint {\n  color: #fff;\n}\n#aframeInspector .collapsible-content {\n  padding: 5px 0;\n}\n#aframeInspector .componentTitle span {\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-transform: uppercase;\n  white-space: nowrap;\n  color: #fff;\n  font-weight: 600;\n  vertical-align: bottom !important;\n}\n#aframeInspector .collapsible .static {\n  background: #333;\n  border-bottom: 2px solid #242424;\n  cursor: pointer;\n  height: 16px;\n  padding: 8px 10px 12px 10px;\n  vertical-align: bottom;\n  font-size: 13px;\n}\n#aframeInspector .collapsible .static:hover {\n  background: #393939;\n}\n#aframeInspector .collapsible .menu {\n  text-align: right;\n}\n#aframeInspector .collapsible .menuafter {\n  color: #bbb;\n  content: \'\\2807\';\n  font-size: 12px;\n  padding: 5px;\n  text-align: right;\n}\n#aframeInspector .collapsible .static {\n  margin: 0;\n}\n#aframeInspector .collapsible .static .collapse-button {\n  border: 6px solid transparent;\n  float: left;\n  height: 0;\n  margin-right: 10px;\n  margin-left: 2px;\n  width: 0;\n}\n#aframeInspector .collapsible.collapsed .static .collapse-button {\n  border-left-color: #c3c3c3;\n  margin-top: 4px;\n}\n#aframeInspector .collapsible:not(.collapsed) .static .collapse-button {\n  border-top-color: #c3c3c3;\n  margin-top: 7px;\n}\n#aframeInspector .propertyRow {\n  align-items: center;\n  display: flex;\n  font-size: 13px;\n  min-height: 30px;\n  padding: 2px 15px;\n}\n#aframeInspector .propertyRow .text {\n  cursor: default;\n  display: inline-block;\n  overflow: hidden;\n  padding-right: 10px;\n  text-overflow: ellipsis;\n  vertical-align: middle;\n  width: 118px;\n}\n#aframeInspector .propertyRow .map_value {\n  margin: 0 0 0 5px;\n  width: 68px;\n}\n#aframeInspector .propertyRow .Select-control {\n  font-size: 11px;\n  height: 24px;\n}\n#aframeInspector .propertyRow .Select-placeholder,\n#aframeInspector .propertyRow .Select--single > .Select-control .Select-value {\n  line-height: 19px;\n}\n#aframeInspector .propertyRow .Select-input {\n  height: 22px;\n}\n#aframeInspector .propertyRow input[type=text],\n#aframeInspector .propertyRow input[type=number],\n#aframeInspector .propertyRow input.string,\n#aframeInspector .propertyRow input.number {\n  background: #1d1d1d;\n  color: #1faaf2;\n  min-height: 26px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n#aframeInspector .propertyRow input[type=text]:last-child,\n#aframeInspector .propertyRow input[type=number]:last-child,\n#aframeInspector .propertyRow input.string:last-child,\n#aframeInspector .propertyRow input.number:last-child {\n  padding-right: 0;\n}\n#aframeInspector .propertyRow input.string {\n  padding-left: 8px;\n  box-sizing: border-box;\n  width: 165px;\n}\n#aframeInspector .propertyRow .color_value {\n  margin: 0 0 0 5px;\n  width: 68px;\n  letter-spacing: 1px;\n}\n#aframeInspector .propertyRowDefined .text {\n  color: #fafafa;\n  font-weight: 500;\n}\n#aframeInspector .components * {\n  vertical-align: middle;\n}\n#aframeInspector span.subcomponent {\n  color: #999;\n  float: none !important;\n  margin-left: 10px;\n  vertical-align: top !important;\n}\n#aframeInspector a.help-link {\n  opacity: 0.4;\n}\n#aframeInspector a.help-linkhover {\n  opacity: 1;\n}\n#aframeInspector #addComponentContainer {\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  padding: 20px 10px;\n  background: #1d1d1d;\n}\n#aframeInspector #addComponentContainer #addComponent {\n  text-align: left;\n  width: 200px;\n}\n#aframeInspector #addComponentContainer #addComponent .select__control {\n  background: #161616;\n  height: 35px;\n  color: #1faaf2;\n}\n#aframeInspector #addComponentContainer #addComponent .option {\n  display: flex;\n  justify-content: space-between;\n}\n#aframeInspector #addComponentContainer #addComponent .option span {\n  color: #1faaf2;\n}\n#aframeInspector #addComponentContainer #addComponentHeader {\n  font-size: 15px;\n  margin: 5px 0 10px 0;\n}\n#aframeInspector .Select-menu-outer .is-focused span {\n  color: #fff;\n}\n#aframeInspector .component-title {\n  align-items: center;\n  display: flex;\n}\n#aframeInspector #componentEntityHeader .collapsible-header {\n  bottom: 4px;\n  position: relative;\n}\n#aframeInspector #componentEntityHeader .collapse-button {\n  display: none;\n}\n#aframeInspector #componentEntityHeader .static {\n  height: 13px;\n}\n#aframeInspector #componentEntityHeader .entityPrint {\n  font-size: 15px;\n  padding-left: 5px;\n}\n#aframeInspector #componentEntityHeader .entityName {\n  max-width: 160px;\n  top: 0;\n}\n#aframeInspector #componentEntityHeader .entityIcons {\n  color: #fafafa;\n}\n#aframeInspector #mixinSelect {\n  width: 160px;\n}\n#aframeInspector .propertyRow .texture {\n  display: flex;\n}\n#aframeInspector .propertyRow .texture input {\n  margin-left: 0;\n  width: 120px;\n}\n#aframeInspector #componentEntityHeader .gltfIcon img {\n  top: 0;\n}\n#aframeInspector .fa {\n  color: #c3c3c3;\n}\n#aframeInspector .fa:hover {\n  color: #1faaf2;\n}\n#aframeInspector .entityPrint {\n  font-family: system-ui, BlinkMacSystemFont, -apple-system, "Segoe UI", Helvetica, Arial, sans-serif;\n}\n#aframeInspector .entityName {\n  display: inline-block;\n  overflow: hidden;\n  position: relative;\n  text-overflow: ellipsis;\n  top: 3px;\n  white-space: nowrap;\n}\n#aframeInspector [data-entity-name-type="id"] {\n  color: #92374d;\n}\n#aframeInspector [data-entity-name-type="class"] {\n  color: #514b23;\n}\n#aframeInspector [data-entity-name-type="mixin"] {\n  color: #d66853;\n}\n#aframeInspector .help-lists {\n  display: flex;\n  justify-content: space-around;\n}\n#aframeInspector .help-list {\n  list-style: none;\n  margin: 0;\n  padding: 0 0 10px;\n  width: 350px;\n}\n#aframeInspector .help-list li {\n  margin-right: 40px;\n}\n#aframeInspector .help-key-unit {\n  line-height: 1.8;\n  margin-right: 2em;\n  padding: 5px 0;\n}\n#aframeInspector .help-key {\n  bottom: 2px;\n  margin-right: 4px;\n  min-width: 60px;\n  position: relative;\n}\n#aframeInspector .help-key span {\n  background-color: #2e2e2e;\n  background-repeat: repeat-x;\n  border: 1px solid #666;\n  border-radius: 3px;\n  box-shadow: 0 0 5px #000;\n  color: #999;\n  display: inline-block;\n  font-size: 12px;\n  padding: 0 8px;\n  text-align: center;\n}\n#aframeInspector .help-key-def {\n  color: #bbb;\n  display: inline-block;\n  margin-left: 1em;\n}\n#aframeInspector .select__control {\n  border: 0;\n  border-radius: 0;\n  cursor: pointer;\n  min-height: 26px;\n  font-family: system-ui, BlinkMacSystemFont, -apple-system, "Segoe UI", Helvetica, Arial, sans-serif;\n  font-size: 13px;\n}\n#aframeInspector .select__indicator {\n  height: 26px;\n}\n#aframeInspector .select__indicator-separator {\n  display: none;\n}\n#aframeInspector .select__control,\n#aframeInspector .select__menu {\n  background: #1d1d1d;\n}\n#aframeInspector .select__option {\n  padding: 5px 10px;\n}\n#aframeInspector .select__placeholder,\n#aframeInspector .select__menu {\n  color: #c3c3c3;\n}\n#aframeInspector .select__single-value {\n  color: #1faaf2;\n}\n#aframeInspector .select__control--is-focused {\n  box-shadow: none !important;\n}\n#aframeInspector .select__option {\n  cursor: pointer;\n}\n#aframeInspector .select__clear-indicator {\n  display: none;\n}\n#aframeInspector .select__label {\n  font-size: 11px;\n}\n#aframeInspector .select__option--is-focused {\n  background: #155373;\n}\n#aframeInspector .select__value-container {\n  height: 26px;\n  position: static;\n}\n#aframeInspector .select__value-container.select__value-container--is-multi {\n  height: auto;\n  padding: 6px;\n}\n#aframeInspector .select__dropdown-indicator {\n  padding: 3px 8px;\n}\n#aframeInspector .select__multi-value {\n  background: #242424;\n  color: #1faaf2;\n}\n#aframeInspector .select__multi-value__label {\n  color: #1faaf2;\n}\n#aframeInspector .select__value-container--is-multi > :last-child {\n  display: none;\n}\n#aframeInspector .select__multi-value__remove:hover {\n  color: #fff;\n  background: #242424;\n}\n#aframeInspector .modal {\n  animation: animateopacity 0.2s ease-out;\n  background-color: #000;\n  background-color: rgba(0,0,0,0.6);\n  display: flex;\n  height: 100%;\n  left: 0;\n  overflow: auto;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 9999999999;\n}\n#aframeInspector .modal h3 {\n  font-size: 18px;\n  font-weight: 100;\n  margin: 0.6em 0;\n}\n#aframeInspector #textureModal .modal-content {\n  height: calc(100% - 50px);\n  width: calc(100% - 50px);\n}\n#aframeInspector .modal-content {\n  animation: animatetop 0.2s ease-out;\n  animation-duration: 0.2s;\n  animation-name: animatetop;\n  background-color: #232323;\n  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.5), 0 6px 20px 0 rgba(0,0,0,0.5);\n  margin: auto;\n  overflow: hidden;\n  padding: 0;\n}\n#aframeInspector .close {\n  color: #fff;\n  float: right;\n  font-size: 28px;\n  font-weight: bold;\n}\n#aframeInspector .closehover,\n#aframeInspector .closefocus {\n  color: #08f;\n  cursor: pointer;\n  text-decoration: none;\n}\n#aframeInspector .modal-header {\n  color: #fff;\n  padding: 2px 16px;\n}\n#aframeInspector .modal-body {\n  overflow: auto;\n  padding: 16px;\n}\n#aframeInspector .modal-footer {\n  color: #fff;\n  padding: 2px 16px;\n}\n#aframeInspector .gallery {\n  background: #232323;\n  display: flex;\n  flex-wrap: wrap;\n  margin: 15px auto 0;\n  overflow: auto;\n  padding: 15px 3px 3px;\n}\n#aframeInspector .newimage .gallery {\n  padding: 16px;\n}\n#aframeInspector .gallery li {\n  border-radius: 2px;\n  box-shadow: 0 0 6px rgba(0,0,0,0.6);\n  cursor: pointer;\n  margin: 8px;\n  overflow: hidden;\n  width: 155px;\n}\n#aframeInspector .gallery li.selected,\n#aframeInspector .gallery li:hover {\n  box-shadow: 0 0 0 2px #1eaaf1;\n}\n#aframeInspector .gallery li .detail {\n  background-color: #323232;\n  margin: 0;\n  min-height: 60px;\n  padding: 3px 10px;\n}\n#aframeInspector .gallery li .button.fa-external-link {\n  margin-left: 136px;\n  margin-top: 5px;\n  position: fixed;\n}\n#aframeInspector .preview {\n  padding: 10px;\n  width: 150px;\n}\n#aframeInspector .preview input {\n  display: block;\n  margin: 8px 0;\n  width: 144px;\n}\n#aframeInspector .preview button {\n  width: 155px;\n}\n#aframeInspector .preview .detail .title {\n  color: #fff;\n  display: inline-block;\n  max-width: 155px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n#aframeInspector .gallery li.selected .detail,\n#aframeInspector .gallery li:hover .detail {\n  background-color: #444;\n}\n#aframeInspector .gallery li .detail span {\n  color: #777;\n  display: block;\n  margin-top: 4px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  width: 140px;\n}\n#aframeInspector .gallery li.selected .detail span,\n#aframeInspector .gallery li:hover .detail span {\n  color: #888;\n}\n#aframeInspector .gallery li .detail span.title {\n  color: #fff !important;\n}\n#aframeInspector .modal button {\n  appearance: none;\n  border-radius: 0;\n  box-shadow: none;\n  cursor: pointer;\n  display: inline-block;\n  font-size: 12px;\n  line-height: 1.8;\n  margin: 0 10px 0 0;\n  padding: 5px 10px;\n}\n#aframeInspector .modal buttonfocus {\n  outline: none;\n}\n#aframeInspector .modal button {\n  background-color: #1eaaf1;\n  border: none;\n  color: #fff;\n}\n#aframeInspector .modal buttonhover,\n#aframeInspector .modal button.hover {\n  background-color: #346392;\n  text-shadow: -1px 1px #27496d;\n}\n#aframeInspector .modal buttonactive,\n#aframeInspector .modal button.active {\n  background-color: #27496d;\n  text-shadow: -1px 1px #193047;\n}\n#aframeInspector .modal buttondisabled {\n  background-color: #888;\n  cursor: none;\n}\n#aframeInspector .newimage {\n  background-color: #323232;\n  color: #bcbcbc;\n  display: flex;\n  font-size: 13px;\n  justify-content: space-between;\n  margin-top: 10px;\n  overflow: auto;\n  padding: 10px;\n}\n#aframeInspector .newimage input {\n  color: #1eaaf1;\n  padding: 3px 5px;\n}\n#aframeInspector .texture canvas + input {\n  margin-left: 5px;\n}\n#aframeInspector .texture .fa {\n  padding-right: 5px;\n}\n#aframeInspector .texture .fa-external-link {\n  font-size: 14px;\n  padding-top: 2px;\n}\n#aframeInspector .uploader-normal-button .hidden {\n  display: none;\n}\n#aframeInspector .gallery a.fa.texture-link {\n  box-shadow: 0 0 14px -1px rgba(0,0,0,0.75);\n  position: fixed;\n}\n#aframeInspector .assets.search {\n  margin-top: 10px;\n  width: 200px;\n}\n#aframeInspector .assets.search .fa-search {\n  top: 7px;\n}\n#aframeInspector .new_asset_options {\n  margin: 10px;\n}\n#aframeInspector .new_asset_options > ul {\n  margin-left: 10px;\n  padding: 5px;\n}\n#aframeInspector .new_asset_options > ul > li {\n  padding: 10px 0;\n}\n#aframeInspector .new_asset_options .imageUrl {\n  margin-left: 5px;\n  width: 350px;\n}\n#aframeInspector .texture canvas {\n  border: 1px solid #333;\n  cursor: pointer;\n}\n#aframeInspector #viewportBar {\n  align-items: center;\n  background-color: #242424;\n  color: #c3c3c3;\n  display: flex;\n  flex-grow: 2;\n  height: 32px;\n  font-size: 14px;\n  justify-content: space-between;\n  left: 0;\n  margin: 0 auto;\n  right: 0;\n  top: 0;\n}\n#aframeInspector .toolbarButtons {\n  position: relative;\n}\n#aframeInspector .toolbarButtons * {\n  margin-left: 0;\n  padding: 8px;\n  vertical-align: middle;\n}\n#aframeInspector .toolbarButtons a.button {\n  margin: 0 6px 0 0;\n}\n#aframeInspector .toolbarButtons a.button:not(.active):hover {\n  background-color: #444;\n}\n#aframeInspector .toolbarButtons .active {\n  background-color: #1faaf2;\n  color: #fff;\n}\n#aframeInspector .toolbarButtons .active:hover {\n  color: #fff !important;\n}\n#aframeInspector .local-transform {\n  padding-left: 10px;\n}\n#aframeInspector .local-transform label {\n  color: #aaa;\n  padding-left: 5px;\n}\n#aframeInspector .local-transform a.button {\n  padding-top: 0;\n}\n#aframeInspector #cameraSelect {\n  cursor: pointer;\n  width: 110px;\n}\n#aframeInspector #cameraSelect .select__dropdown-indicator {\n  padding-left: 3px;\n  padding-right: 3px;\n}\n#aframeInspector #cameraToolbar {\n  margin-left: 5px;\n  align-items: center;\n  display: flex;\n}\n#aframeInspector #cameraToolbar a {\n  margin-right: 10px;\n}\n#aframeInspector #cameraToolbar .select__control {\n  background: none;\n}\n#aframeInspector #cameraToolbar .select__single-value {\n  color: #c3c3c3;\n}\n#aframeInspector #cameraToolbar .select__single-value:hover {\n  color: #1faaf2;\n}\n#aframeInspector #viewportHud {\n  display: none;\n}\n@media (min-width: 1024px) {\n  #aframeInspector #viewportHud {\n    display: block;\n  }\n}\n#aframeInspector .Select-control {\n  background-color: #222 !important;\n  border: none;\n  border-radius: 0;\n  color: #1faaf2;\n  font-family: $monosapce;\n}\n#aframeInspector .Select-menu-outer {\n  border: none;\n}\n#aframeInspector .Select-menu-outer .is-focused {\n  background-color: #1faaf2 !important;\n  color: #c3c3c3;\n}\n#aframeInspector .Select-option {\n  background-color: #222 !important;\n}\n#aframeInspector .select-widget {\n  display: inline-block;\n  width: 157px;\n}\n#aframeInspector .Select-placeholder,\n#aframeInspector .Select--single > .Select-control .Select-value {\n  color: #1faaf2 !important;\n}\n#aframeInspector .Select-value-label {\n  color: #1faaf2 !important;\n}\n#aframeInspector .dropbtn {\n  border: none;\n  color: #c3c3c3;\n  cursor: pointer;\n}\n#aframeInspector .dropdown {\n  display: inline-block;\n  position: relative;\n}\n#aframeInspector .dropdown-content {\n  background-color: #f9f9f9;\n  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);\n  display: none;\n  left: 8px;\n  min-width: 38px;\n  position: absolute;\n  z-index: 999;\n}\n#aframeInspector .dropdown-content a {\n  background-color: #232323;\n  color: #7d7d7d;\n  display: block;\n  padding: 10px 14px;\n  text-decoration: none;\n}\n#aframeInspector .dropdown-content a:hover {\n  background-color: #4ecbff;\n  color: #c3c3c3;\n}\n#aframeInspector .dropdownhover .dropdown-content {\n  display: block;\n}\n#aframeInspector .dropdownhover .dropbtn {\n  color: #1faaf2;\n}\n#aframeInspector .Select,\n#aframeInspector code,\n#aframeInspector pre,\n#aframeInspector input,\n#aframeInspector textarea,\n#aframeInspector select {\n  font-family: system-ui, BlinkMacSystemFont, -apple-system, "Segoe UI", Helvetica, Arial, sans-serif;\n  font-size: 13px;\n}\n#aframeInspector .wf-robotomono-n4-active .Select,\n#aframeInspector .wf-robotomono-n4-active code,\n#aframeInspector .wf-robotomono-n4-active pre,\n#aframeInspector .wf-robotomono-n4-active input,\n#aframeInspector .wf-robotomono-n4-active textarea,\n#aframeInspector .wf-robotomono-n4-active select {\n  font-family: Roboto Mono, Consolas, Andale Mono, Monaco, Courier New, monospace;\n}\n#aframeInspector hr {\n  border: 0;\n  border-top: 1px solid #ccc;\n}\n#aframeInspector a {\n  cursor: pointer;\n}\n#aframeInspector button {\n  position: relative;\n}\n#aframeInspector code {\n  font-family: Consolas, Andale Mono, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;\n}\n#aframeInspector textarea {\n  tab-size: 4;\n  white-space: pre;\n  word-wrap: normal;\n}\n#aframeInspector textarea.success {\n  border-color: #8b8 !important;\n}\n#aframeInspector textarea.fail {\n  background-color: rgba(255,0,0,0.05);\n  border-color: #f00 !important;\n}\n#aframeInspector textarea,\n#aframeInspector input {\n  outline: none /* osx */;\n}\n#aframeInspector .gltfIcon img {\n  height: 20px;\n  left: 5px;\n  padding: 0 5px;\n  position: relative;\n  top: 4px;\n  width: 20px;\n}\n#aframeInspector #scenegraph,\n#aframeInspector #rightPanel {\n  z-index: 9998;\n}\n#aframeInspector #sidebar,\n#aframeInspector #scenegraph,\n#aframeInspector .panel {\n  cursor: default;\n  user-select: none;\n}\n#aframeInspector .toggle-edit {\n  background-color: #92374d;\n  color: #fafafa;\n  font-size: 13px;\n  left: 3px;\n  margin: 0;\n  padding: 6px 10px;\n  position: fixed;\n  text-align: center;\n  text-decoration: none;\n  top: 3px;\n  width: 204px;\n  z-index: 999999999;\n}\n#aframeInspector .toggle-edithover {\n  background-color: #e42b5a;\n}\n#aframeInspector input {\n  background-color: transparent;\n  border: 1px solid #555;\n  color: #fff;\n}\n#aframeInspector input,\n#aframeInspector .texture canvas {\n  transition: 0.1s background-color ease-in-out, 0.1s border-color ease-in-out, 0.1s color ease-in-out;\n}\n#aframeInspector input[type=text],\n#aframeInspector input[type=number],\n#aframeInspector input.string,\n#aframeInspector input.number {\n  min-height: 14px;\n  outline: none;\n}\n#aframeInspector input[type="checkbox"] {\n  cursor: pointer;\n  margin: 0;\n  height: 18px;\n  width: 18px;\n}\n#aframeInspector input.number {\n  background-color: transparent !important;\n  border: 0;\n  color: #2cb7ff !important;\n  cursor: col-resize;\n  font-size: 13px;\n  padding: 2px;\n}\n#aframeInspector input.stringfocus,\n#aframeInspector input.numberfocus {\n  border: 1px solid #20b1fb;\n  color: #fff;\n  cursor: auto;\n}\n#aframeInspector input.error {\n  border: 1px solid #a00;\n}\n#aframeInspector #sidebar {\n  background: #242424;\n  width: 331px;\n}\n#aframeInspector #sidebar * {\n  vertical-align: middle;\n}\n#aframeInspector input,\n#aframeInspector textarea,\n#aframeInspector select {\n  background: #222;\n  border: 1px solid transparent;\n  color: #888;\n}\n#aframeInspector select {\n  background: #393939;\n}\n#aframeInspector input[type=color] {\n  background-color: #333;\n  border: 1px solid #111;\n  height: 28px;\n  cursor: pointer;\n}\n#aframeInspector input[type=color] {\n  cursor: pointer;\n  height: 25px;\n  padding: 0;\n  width: 50px;\n}\n#aframeInspector input[type=color]-webkit-color-swatch {\n  border: 0 /* To remove the gray border. */;\n}\n#aframeInspector input[type=color]-webkit-color-swatch-wrapper {\n  padding: 0 /* To remove the inner padding. */;\n}\n#aframeInspector input[type=color]-moz-color-swatch {\n  border: 0;\n}\n#aframeInspector input[type=color]-moz-focus-inner {\n  border: 0 /* To remove the inner border (specific to Firefox). */;\n  padding: 0;\n}\n#aframeInspector .hidden {\n  visibility: hidden;\n}\n#aframeInspector a.button {\n  color: #bcbcbc;\n  font-size: 16px;\n  margin-left: 10px;\n  text-decoration: none;\n}\n#aframeInspector a.buttonhover {\n  color: #1faaf2;\n}\n#aframeInspector .hide {\n  display: none;\n}\n#aframeInspector .a-canvas.state-dragging {\n  cursor: grabbing;\n}\n#aframeInspector #rightPanel {\n  align-items: stretch;\n  display: flex;\n  justify-content: flex-end;\n}\n#aframeInspector #inspectorContainer {\n  display: flex;\n  justify-content: space-between;\n  left: 0;\n  height: 100%;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 999999;\n}\n#aframeInspector #scenegraph,\n#aframeInspector #viewportBar,\n#aframeInspector #rightPanel {\n  pointer-events: all;\n}\n#aframeInspector .aframe-inspector-opened a-scene .a-canvas {\n  background-color: #191919;\n  z-index: 9998;\n}\n#aframeInspector .toggle-sidebar {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  position: absolute;\n  z-index: 9998;\n}\n#aframeInspector .toggle-sidebar .left {\n  left: 0;\n}\n#aframeInspector .toggle-sidebar .right {\n  right: 0;\n}\n#aframeInspector .toggle-sidebar a {\n  background-color: #262626;\n  color: #bcbcbc;\n  padding: 5px;\n  z-index: 9998;\n}\n#aframeInspector .toggle-sidebar a.hover {\n  background-color: #1faaf2;\n  color: #fff;\n}\n@-moz-keyframes animateopacity {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@-webkit-keyframes animateopacity {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@-o-keyframes animateopacity {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes animateopacity {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n',
      ""
    ]);
  },
  function(module, exports) {
    module.exports = function() {
      var list = [];
      list.toString = function toString() {
        var result = [];
        for (var i = 0; i < this.length; i++) {
          var item = this[i];
          if (item[2]) {
            result.push("@media " + item[2] + "{" + item[1] + "}");
          } else {
            result.push(item[1]);
          }
        }
        return result.join("");
      };
      list.i = function(modules, mediaQuery) {
        if (typeof modules === "string") modules = [[null, modules, ""]];
        var alreadyImportedModules = {};
        for (var i = 0; i < this.length; i++) {
          var id = this[i][0];
          if (typeof id === "number") alreadyImportedModules[id] = true;
        }
        for (i = 0; i < modules.length; i++) {
          var item = modules[i];
          if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
            if (mediaQuery && !item[2]) {
              item[2] = mediaQuery;
            } else if (mediaQuery) {
              item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
            }
            list.push(item);
          }
        }
      };
      return list;
    };
  },
  function(module, exports) {
    var DOCUMENT_NODE_TYPE = 9;
    if (typeof Element !== "undefined" && !Element.prototype.matches) {
      var proto = Element.prototype;
      proto.matches =
        proto.matchesSelector ||
        proto.mozMatchesSelector ||
        proto.msMatchesSelector ||
        proto.oMatchesSelector ||
        proto.webkitMatchesSelector;
    }
    function closest(element, selector) {
      while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (
          typeof element.matches === "function" &&
          element.matches(selector)
        ) {
          return element;
        }
        element = element.parentNode;
      }
    }
    module.exports = closest;
  },
  function(module, exports, __webpack_require__) {
    var closest = __webpack_require__(143);
    function _delegate(element, selector, type, callback, useCapture) {
      var listenerFn = listener.apply(this, arguments);
      element.addEventListener(type, listenerFn, useCapture);
      return {
        destroy: function() {
          element.removeEventListener(type, listenerFn, useCapture);
        }
      };
    }
    function delegate(elements, selector, type, callback, useCapture) {
      if (typeof elements.addEventListener === "function") {
        return _delegate.apply(null, arguments);
      }
      if (typeof type === "function") {
        return _delegate.bind(null, document).apply(null, arguments);
      }
      if (typeof elements === "string") {
        elements = document.querySelectorAll(elements);
      }
      return Array.prototype.map.call(elements, function(element) {
        return _delegate(element, selector, type, callback, useCapture);
      });
    }
    function listener(element, selector, type, callback) {
      return function(e) {
        e.delegateTarget = closest(e.target, selector);
        if (e.delegateTarget) {
          callback.call(element, e);
        }
      };
    }
    module.exports = delegate;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _interopRequireDefault = __webpack_require__(106);
    exports.__esModule = true;
    exports.default = addClass;
    var _hasClass = _interopRequireDefault(__webpack_require__(146));
    function addClass(element, className) {
      if (element.classList) element.classList.add(className);
      else if (!(0, _hasClass.default)(element, className))
        if (typeof element.className === "string")
          element.className = element.className + " " + className;
        else
          element.setAttribute(
            "class",
            ((element.className && element.className.baseVal) || "") +
              " " +
              className
          );
    }
    module.exports = exports["default"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = hasClass;
    function hasClass(element, className) {
      if (element.classList)
        return !!className && element.classList.contains(className);
      else
        return (
          (
            " " +
            (element.className.baseVal || element.className) +
            " "
          ).indexOf(" " + className + " ") !== -1
        );
    }
    module.exports = exports["default"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function replaceClassName(origClass, classToRemove) {
      return origClass
        .replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1")
        .replace(/\s+/g, " ")
        .replace(/^\s*|\s*$/g, "");
    }
    module.exports = function removeClass(element, className) {
      if (element.classList) element.classList.remove(className);
      else if (typeof element.className === "string")
        element.className = replaceClassName(element.className, className);
      else
        element.setAttribute(
          "class",
          replaceClassName(
            (element.className && element.className.baseVal) || "",
            className
          )
        );
    };
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global) {
      var __WEBPACK_IMPORTED_MODULE_0_create_emotion__ = __webpack_require__(
        139
      );
      __webpack_require__.d(__webpack_exports__, "b", function() {
        return injectGlobal;
      });
      __webpack_require__.d(__webpack_exports__, "a", function() {
        return css;
      });
      var context = typeof global !== "undefined" ? global : {};
      var _createEmotion = __webpack_require__.i(
          __WEBPACK_IMPORTED_MODULE_0_create_emotion__["a"]
        )(context),
        flush = _createEmotion.flush,
        hydrate = _createEmotion.hydrate,
        cx = _createEmotion.cx,
        merge = _createEmotion.merge,
        getRegisteredStyles = _createEmotion.getRegisteredStyles,
        injectGlobal = _createEmotion.injectGlobal,
        keyframes = _createEmotion.keyframes,
        css = _createEmotion.css,
        sheet = _createEmotion.sheet,
        caches = _createEmotion.caches;
    }.call(__webpack_exports__, __webpack_require__(56)));
  },
  function(module, exports) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError("n must be a positive number");
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
      if (!this._events) this._events = {};
      if (type === "error") {
        if (
          !this._events.error ||
          (isObject(this._events.error) && !this._events.error.length)
        ) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error(
              'Uncaught, unspecified "error" event. (' + er + ")"
            );
            err.context = er;
            throw err;
          }
        }
      }
      handler = this._events[type];
      if (isUndefined(handler)) return false;
      if (isFunction(handler)) {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++) listeners[i].apply(this, args);
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      if (!this._events) this._events = {};
      if (this._events.newListener)
        this.emit(
          "newListener",
          type,
          isFunction(listener.listener) ? listener.listener : listener
        );
      if (!this._events[type]) this._events[type] = listener;
      else if (isObject(this._events[type])) this._events[type].push(listener);
      else this._events[type] = [this._events[type], listener];
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error(
            "(node) warning: possible EventEmitter memory " +
              "leak detected. %d listeners added. " +
              "Use emitter.setMaxListeners() to increase limit.",
            this._events[type].length
          );
          if (typeof console.trace === "function") {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      var fired = false;
      function g() {
        this.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
      g.listener = listener;
      this.on(type, g);
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      if (!this._events || !this._events[type]) return this;
      list = this._events[type];
      length = list.length;
      position = -1;
      if (
        list === listener ||
        (isFunction(list.listener) && list.listener === listener)
      ) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit("removeListener", type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0; ) {
          if (
            list[i] === listener ||
            (list[i].listener && list[i].listener === listener)
          ) {
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
        if (this._events.removeListener)
          this.emit("removeListener", type, listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
      if (!this._events) return this;
      if (!this._events.removeListener) {
        if (arguments.length === 0) this._events = {};
        else if (this._events[type]) delete this._events[type];
        return this;
      }
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = {};
        return this;
      }
      listeners = this._events[type];
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type]) ret = [];
      else if (isFunction(this._events[type])) ret = [this._events[type]];
      else ret = this._events[type].slice();
      return ret;
    };
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
        if (isFunction(evlistener)) return 1;
        else if (evlistener) return evlistener.length;
      }
      return 0;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function isNumber(arg) {
      return typeof arg === "number";
    }
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _hyphenPattern = /-(.)/g;
    function camelize(string) {
      return string.replace(_hyphenPattern, function(_, character) {
        return character.toUpperCase();
      });
    }
    module.exports = camelize;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var camelize = __webpack_require__(150);
    var msPattern = /^-ms-/;
    function camelizeStyleName(string) {
      return camelize(string.replace(msPattern, "ms-"));
    }
    module.exports = camelizeStyleName;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var isTextNode = __webpack_require__(160);
    function containsNode(outerNode, innerNode) {
      if (!outerNode || !innerNode) {
        return false;
      } else if (outerNode === innerNode) {
        return true;
      } else if (isTextNode(outerNode)) {
        return false;
      } else if (isTextNode(innerNode)) {
        return containsNode(outerNode, innerNode.parentNode);
      } else if ("contains" in outerNode) {
        return outerNode.contains(innerNode);
      } else if (outerNode.compareDocumentPosition) {
        return !!(outerNode.compareDocumentPosition(innerNode) & 16);
      } else {
        return false;
      }
    }
    module.exports = containsNode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var invariant = __webpack_require__(0);
    function toArray(obj) {
      var length = obj.length;
      !(
        !Array.isArray(obj) &&
        (typeof obj === "object" || typeof obj === "function")
      )
        ? false
          ? invariant(false, "toArray: Array-like object expected")
          : invariant(false)
        : void 0;
      !(typeof length === "number")
        ? false
          ? invariant(false, "toArray: Object needs a length property")
          : invariant(false)
        : void 0;
      !(length === 0 || length - 1 in obj)
        ? false
          ? invariant(false, "toArray: Object should have keys for indices")
          : invariant(false)
        : void 0;
      !(typeof obj.callee !== "function")
        ? false
          ? invariant(
              false,
              "toArray: Object can't be `arguments`. Use rest params " +
                "(function(...args) {}) or Array.from() instead."
            )
          : invariant(false)
        : void 0;
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    function hasArrayNature(obj) {
      return (
        !!obj &&
        (typeof obj == "object" || typeof obj == "function") &&
        "length" in obj &&
        !("setInterval" in obj) &&
        typeof obj.nodeType != "number" &&
        (Array.isArray(obj) || "callee" in obj || "item" in obj)
      );
    }
    function createArrayFromMixed(obj) {
      if (!hasArrayNature(obj)) {
        return [obj];
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else {
        return toArray(obj);
      }
    }
    module.exports = createArrayFromMixed;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var createArrayFromMixed = __webpack_require__(153);
    var getMarkupWrap = __webpack_require__(155);
    var invariant = __webpack_require__(0);
    var dummyNode = ExecutionEnvironment.canUseDOM
      ? document.createElement("div")
      : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      !!!dummyNode
        ? false
          ? invariant(false, "createNodesFromMarkup dummy not initialized")
          : invariant(false)
        : void 0;
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName("script");
      if (scripts.length) {
        !handleScript
          ? false
            ? invariant(
                false,
                "createNodesFromMarkup(...): Unexpected <script> element rendered."
              )
            : invariant(false)
          : void 0;
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = Array.from(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var invariant = __webpack_require__(0);
    var dummyNode = ExecutionEnvironment.canUseDOM
      ? document.createElement("div")
      : null;
    var shouldWrap = {};
    var selectWrap = [1, '<select multiple="true">', "</select>"];
    var tableWrap = [1, "<table>", "</table>"];
    var trWrap = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
    var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', "</svg>"];
    var markupWrap = {
      "*": [1, "?<div>", "</div>"],
      area: [1, "<map>", "</map>"],
      col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      legend: [1, "<fieldset>", "</fieldset>"],
      param: [1, "<object>", "</object>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      optgroup: selectWrap,
      option: selectWrap,
      caption: tableWrap,
      colgroup: tableWrap,
      tbody: tableWrap,
      tfoot: tableWrap,
      thead: tableWrap,
      td: trWrap,
      th: trWrap
    };
    var svgElements = [
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "text",
      "tspan"
    ];
    svgElements.forEach(function(nodeName) {
      markupWrap[nodeName] = svgWrap;
      shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
      !!!dummyNode
        ? false
          ? invariant(false, "Markup wrapping node not initialized")
          : invariant(false)
        : void 0;
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = "*";
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === "*") {
          dummyNode.innerHTML = "<link />";
        } else {
          dummyNode.innerHTML = "<" + nodeName + "></" + nodeName + ">";
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function getUnboundedScrollPosition(scrollable) {
      if (scrollable.Window && scrollable instanceof scrollable.Window) {
        return {
          x:
            scrollable.pageXOffset ||
            scrollable.document.documentElement.scrollLeft,
          y:
            scrollable.pageYOffset ||
            scrollable.document.documentElement.scrollTop
        };
      }
      return { x: scrollable.scrollLeft, y: scrollable.scrollTop };
    }
    module.exports = getUnboundedScrollPosition;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _uppercasePattern = /([A-Z])/g;
    function hyphenate(string) {
      return string.replace(_uppercasePattern, "-$1").toLowerCase();
    }
    module.exports = hyphenate;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var hyphenate = __webpack_require__(157);
    var msPattern = /^ms-/;
    function hyphenateStyleName(string) {
      return hyphenate(string).replace(msPattern, "-ms-");
    }
    module.exports = hyphenateStyleName;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function isNode(object) {
      var doc = object ? object.ownerDocument || object : document;
      var defaultView = doc.defaultView || window;
      return !!(
        object &&
        (typeof defaultView.Node === "function"
          ? object instanceof defaultView.Node
          : typeof object === "object" &&
            typeof object.nodeType === "number" &&
            typeof object.nodeName === "string")
      );
    }
    module.exports = isNode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var isNode = __webpack_require__(159);
    function isTextNode(object) {
      return isNode(object) && object.nodeType == 3;
    }
    module.exports = isTextNode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function memoizeStringOnly(callback) {
      var cache = {};
      return function(string) {
        if (!cache.hasOwnProperty(string)) {
          cache[string] = callback.call(this, string);
        }
        return cache[string];
      };
    }
    module.exports = memoizeStringOnly;
  },
  function(module, exports) {
    exports.node = function(value) {
      return (
        value !== undefined &&
        value instanceof HTMLElement &&
        value.nodeType === 1
      );
    };
    exports.nodeList = function(value) {
      var type = Object.prototype.toString.call(value);
      return (
        value !== undefined &&
        (type === "[object NodeList]" || type === "[object HTMLCollection]") &&
        "length" in value &&
        (value.length === 0 || exports.node(value[0]))
      );
    };
    exports.string = function(value) {
      return typeof value === "string" || value instanceof String;
    };
    exports.fn = function(value) {
      var type = Object.prototype.toString.call(value);
      return type === "[object Function]";
    };
  },
  function(module, exports, __webpack_require__) {
    var is = __webpack_require__(162);
    var delegate = __webpack_require__(144);
    function listen(target, type, callback) {
      if (!target && !type && !callback) {
        throw new Error("Missing required arguments");
      }
      if (!is.string(type)) {
        throw new TypeError("Second argument must be a String");
      }
      if (!is.fn(callback)) {
        throw new TypeError("Third argument must be a Function");
      }
      if (is.node(target)) {
        return listenNode(target, type, callback);
      } else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
      } else if (is.string(target)) {
        return listenSelector(target, type, callback);
      } else {
        throw new TypeError(
          "First argument must be a String, HTMLElement, HTMLCollection, or NodeList"
        );
      }
    }
    function listenNode(node, type, callback) {
      node.addEventListener(type, callback);
      return {
        destroy: function() {
          node.removeEventListener(type, callback);
        }
      };
    }
    function listenNodeList(nodeList, type, callback) {
      Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
      });
      return {
        destroy: function() {
          Array.prototype.forEach.call(nodeList, function(node) {
            node.removeEventListener(type, callback);
          });
        }
      };
    }
    function listenSelector(selector, type, callback) {
      return delegate(document.body, selector, type, callback);
    }
    module.exports = listen;
  },
  function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var simpleIsEqual = function simpleIsEqual(a, b) {
      return a === b;
    };
    function index(resultFn, isEqual) {
      if (isEqual === void 0) {
        isEqual = simpleIsEqual;
      }
      var lastThis;
      var lastArgs = [];
      var lastResult;
      var calledOnce = false;
      var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
        return isEqual(newArg, lastArgs[index]);
      };
      var result = function result() {
        for (
          var _len = arguments.length, newArgs = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          newArgs[_key] = arguments[_key];
        }
        if (
          calledOnce &&
          lastThis === this &&
          newArgs.length === lastArgs.length &&
          newArgs.every(isNewArgEqualToLast)
        ) {
          return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
      };
      return result;
    }
    __webpack_exports__["a"] = index;
  },
  function(module, exports, __webpack_require__) {
    (function(process) {
      (function() {
        var getNanoSeconds,
          hrtime,
          loadTime,
          moduleLoadTime,
          nodeLoadTime,
          upTime;
        if (
          typeof performance !== "undefined" &&
          performance !== null &&
          performance.now
        ) {
          module.exports = function() {
            return performance.now();
          };
        } else if (
          typeof process !== "undefined" &&
          process !== null &&
          process.hrtime
        ) {
          module.exports = function() {
            return (getNanoSeconds() - nodeLoadTime) / 1e6;
          };
          hrtime = process.hrtime;
          getNanoSeconds = function() {
            var hr;
            hr = hrtime();
            return hr[0] * 1e9 + hr[1];
          };
          moduleLoadTime = getNanoSeconds();
          upTime = process.uptime() * 1e9;
          nodeLoadTime = moduleLoadTime - upTime;
        } else if (Date.now) {
          module.exports = function() {
            return Date.now() - loadTime;
          };
          loadTime = Date.now();
        } else {
          module.exports = function() {
            return new Date().getTime() - loadTime;
          };
          loadTime = new Date().getTime();
        }
      }.call(this));
    }.call(exports, __webpack_require__(39)));
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var printWarning = function() {};
    if (false) {
      var ReactPropTypesSecret = require("./lib/ReactPropTypesSecret");
      var loggedTypeFailures = {};
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };
    }
    function checkPropTypes(
      typeSpecs,
      values,
      location,
      componentName,
      getStack
    ) {
      if (false) {
        for (var typeSpecName in typeSpecs) {
          if (typeSpecs.hasOwnProperty(typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") +
                    ": " +
                    location +
                    " type `" +
                    typeSpecName +
                    "` is invalid; " +
                    "it must be a function, usually from the `prop-types` package, but received `" +
                    typeof typeSpecs[typeSpecName] +
                    "`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](
                values,
                typeSpecName,
                componentName,
                location,
                null,
                ReactPropTypesSecret
              );
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") +
                  ": type specification of " +
                  location +
                  " `" +
                  typeSpecName +
                  "` is invalid; the type checker " +
                  "function must return `null` or an `Error` but returned a " +
                  typeof error +
                  ". " +
                  "You may have forgotten to pass an argument to the type checker " +
                  "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
                  "shape all require an argument)."
              );
            }
            if (
              error instanceof Error &&
              !(error.message in loggedTypeFailures)
            ) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " +
                  location +
                  " type: " +
                  error.message +
                  (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    module.exports = checkPropTypes;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactPropTypesSecret = __webpack_require__(74);
    function emptyFunction() {}
    module.exports = function() {
      function shim(
        props,
        propName,
        componentName,
        location,
        propFullName,
        secret
      ) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. " +
            "Use PropTypes.checkPropTypes() to call them. " +
            "Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim
      };
      ReactPropTypes.checkPropTypes = emptyFunction;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var assign = __webpack_require__(6);
    var ReactPropTypesSecret = __webpack_require__(74);
    var checkPropTypes = __webpack_require__(166);
    var printWarning = function() {};
    if (false) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn =
          maybeIterable &&
          ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
            maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message) {
        this.message = message;
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (false) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(
          isRequired,
          props,
          propName,
          componentName,
          location,
          propFullName,
          secret
        ) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. " +
                  "Use `PropTypes.checkPropTypes()` to call them. " +
                  "Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (false) {
              var cacheKey = componentName + ":" + propName;
              if (
                !manualPropTypeCallCache[cacheKey] &&
                manualPropTypeWarningCount < 3
              ) {
                printWarning(
                  "You are manually calling a React.PropTypes validation " +
                    "function for the `" +
                    propFullName +
                    "` prop on `" +
                    componentName +
                    "`. This is deprecated " +
                    "and will throw in the standalone `prop-types` package. " +
                    "You may be seeing this warning due to a third-party PropTypes " +
                    "library. See https://fb.me/react-warning-dont-call-proptypes " +
                    "for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError(
                  "The " +
                    location +
                    " `" +
                    propFullName +
                    "` is marked as required " +
                    ("in `" + componentName + "`, but its value is `null`.")
                );
              }
              return new PropTypeError(
                "The " +
                  location +
                  " `" +
                  propFullName +
                  "` is marked as required in " +
                  ("`" + componentName + "`, but its value is `undefined`.")
              );
            }
            return null;
          } else {
            return validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            );
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName,
          secret
        ) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type " +
                ("`" +
                  preciseType +
                  "` supplied to `" +
                  componentName +
                  "`, expected ") +
                ("`" + expectedType + "`.")
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError(
              "Property `" +
                propFullName +
                "` of component `" +
                componentName +
                "` has invalid PropType notation inside arrayOf."
            );
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type " +
                ("`" +
                  propType +
                  "` supplied to `" +
                  componentName +
                  "`, expected an array.")
            );
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(
              propValue,
              i,
              componentName,
              location,
              propFullName + "[" + i + "]",
              ReactPropTypesSecret
            );
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type " +
                ("`" +
                  propType +
                  "` supplied to `" +
                  componentName +
                  "`, expected a single ReactElement.")
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type " +
                ("`" +
                  actualClassName +
                  "` supplied to `" +
                  componentName +
                  "`, expected ") +
                ("instance of `" + expectedClassName + "`.")
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          false
            ? printWarning(
                "Invalid argument supplied to oneOf, expected an instance of array."
              )
            : void 0;
          return emptyFunctionThatReturnsNull;
        }
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues);
          return new PropTypeError(
            "Invalid " +
              location +
              " `" +
              propFullName +
              "` of value `" +
              propValue +
              "` " +
              ("supplied to `" +
                componentName +
                "`, expected one of " +
                valuesString +
                ".")
          );
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError(
              "Property `" +
                propFullName +
                "` of component `" +
                componentName +
                "` has invalid PropType notation inside objectOf."
            );
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type " +
                ("`" +
                  propType +
                  "` supplied to `" +
                  componentName +
                  "`, expected an object.")
            );
          }
          for (var key in propValue) {
            if (propValue.hasOwnProperty(key)) {
              var error = typeChecker(
                propValue,
                key,
                componentName,
                location,
                propFullName + "." + key,
                ReactPropTypesSecret
              );
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          false
            ? printWarning(
                "Invalid argument supplied to oneOfType, expected an instance of array."
              )
            : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but " +
                "received " +
                getPostfixForTypeWarning(checker) +
                " at index " +
                i +
                "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (
              checker(
                props,
                propName,
                componentName,
                location,
                propFullName,
                ReactPropTypesSecret
              ) == null
            ) {
              return null;
            }
          }
          return new PropTypeError(
            "Invalid " +
              location +
              " `" +
              propFullName +
              "` supplied to " +
              ("`" + componentName + "`.")
          );
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          if (!isNode(props[propName])) {
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` supplied to " +
                ("`" + componentName + "`, expected a ReactNode.")
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type `" +
                propType +
                "` " +
                ("supplied to `" + componentName + "`, expected `object`.")
            );
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (!checker) {
              continue;
            }
            var error = checker(
              propValue,
              key,
              componentName,
              location,
              propFullName + "." + key,
              ReactPropTypesSecret
            );
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type `" +
                propType +
                "` " +
                ("supplied to `" + componentName + "`, expected `object`.")
            );
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (!checker) {
              return new PropTypeError(
                "Invalid " +
                  location +
                  " `" +
                  propFullName +
                  "` key `" +
                  key +
                  "` supplied to `" +
                  componentName +
                  "`." +
                  "\nBad object: " +
                  JSON.stringify(props[propName], null, "  ") +
                  "\nValid keys: " +
                  JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(
              propValue,
              key,
              componentName,
              location,
              propFullName + "." + key,
              ReactPropTypesSecret
            );
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  },
  function(module, exports, __webpack_require__) {
    (function(global) {
      var now = __webpack_require__(165),
        root = typeof window === "undefined" ? global : window,
        vendors = ["moz", "webkit"],
        suffix = "AnimationFrame",
        raf = root["request" + suffix],
        caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
      for (var i = 0; !raf && i < vendors.length; i++) {
        raf = root[vendors[i] + "Request" + suffix];
        caf =
          root[vendors[i] + "Cancel" + suffix] ||
          root[vendors[i] + "CancelRequest" + suffix];
      }
      if (!raf || !caf) {
        var last = 0,
          id = 0,
          queue = [],
          frameDuration = 1000 / 60;
        raf = function(callback) {
          if (queue.length === 0) {
            var _now = now(),
              next = Math.max(0, frameDuration - (_now - last));
            last = next + _now;
            setTimeout(function() {
              var cp = queue.slice(0);
              queue.length = 0;
              for (var i = 0; i < cp.length; i++) {
                if (!cp[i].cancelled) {
                  try {
                    cp[i].callback(last);
                  } catch (e) {
                    setTimeout(function() {
                      throw e;
                    }, 0);
                  }
                }
              }
            }, Math.round(next));
          }
          queue.push({ handle: ++id, callback: callback, cancelled: false });
          return id;
        };
        caf = function(handle) {
          for (var i = 0; i < queue.length; i++) {
            if (queue[i].handle === handle) {
              queue[i].cancelled = true;
            }
          }
        };
      }
      module.exports = function(fn) {
        return raf.call(root, fn);
      };
      module.exports.cancel = function() {
        caf.apply(root, arguments);
      };
      module.exports.polyfill = function(object) {
        if (!object) {
          object = root;
        }
        object.requestAnimationFrame = raf;
        object.cancelAnimationFrame = caf;
      };
    }.call(exports, __webpack_require__(56)));
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ARIADOMPropertyConfig = {
      Properties: {
        "aria-current": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      },
      DOMAttributeNames: {},
      DOMPropertyNames: {}
    };
    module.exports = ARIADOMPropertyConfig;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMComponentTree = __webpack_require__(7);
    var focusNode = __webpack_require__(71);
    var AutoFocusUtils = {
      focusDOMComponent: function() {
        focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
      }
    };
    module.exports = AutoFocusUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPropagators = __webpack_require__(26);
    var ExecutionEnvironment = __webpack_require__(8);
    var FallbackCompositionState = __webpack_require__(178);
    var SyntheticCompositionEvent = __webpack_require__(215);
    var SyntheticInputEvent = __webpack_require__(218);
    var END_KEYCODES = [9, 13, 27, 32];
    var START_KEYCODE = 229;
    var canUseCompositionEvent =
      ExecutionEnvironment.canUseDOM && "CompositionEvent" in window;
    var documentMode = null;
    if (ExecutionEnvironment.canUseDOM && "documentMode" in document) {
      documentMode = document.documentMode;
    }
    var canUseTextInputEvent =
      ExecutionEnvironment.canUseDOM &&
      "TextEvent" in window &&
      !documentMode &&
      !isPresto();
    var useFallbackCompositionData =
      ExecutionEnvironment.canUseDOM &&
      (!canUseCompositionEvent ||
        (documentMode && documentMode > 8 && documentMode <= 11));
    function isPresto() {
      var opera = window.opera;
      return (
        typeof opera === "object" &&
        typeof opera.version === "function" &&
        parseInt(opera.version(), 10) <= 12
      );
    }
    var SPACEBAR_CODE = 32;
    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    var eventTypes = {
      beforeInput: {
        phasedRegistrationNames: {
          bubbled: "onBeforeInput",
          captured: "onBeforeInputCapture"
        },
        dependencies: [
          "topCompositionEnd",
          "topKeyPress",
          "topTextInput",
          "topPaste"
        ]
      },
      compositionEnd: {
        phasedRegistrationNames: {
          bubbled: "onCompositionEnd",
          captured: "onCompositionEndCapture"
        },
        dependencies: [
          "topBlur",
          "topCompositionEnd",
          "topKeyDown",
          "topKeyPress",
          "topKeyUp",
          "topMouseDown"
        ]
      },
      compositionStart: {
        phasedRegistrationNames: {
          bubbled: "onCompositionStart",
          captured: "onCompositionStartCapture"
        },
        dependencies: [
          "topBlur",
          "topCompositionStart",
          "topKeyDown",
          "topKeyPress",
          "topKeyUp",
          "topMouseDown"
        ]
      },
      compositionUpdate: {
        phasedRegistrationNames: {
          bubbled: "onCompositionUpdate",
          captured: "onCompositionUpdateCapture"
        },
        dependencies: [
          "topBlur",
          "topCompositionUpdate",
          "topKeyDown",
          "topKeyPress",
          "topKeyUp",
          "topMouseDown"
        ]
      }
    };
    var hasSpaceKeypress = false;
    function isKeypressCommand(nativeEvent) {
      return (
        (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
        !(nativeEvent.ctrlKey && nativeEvent.altKey)
      );
    }
    function getCompositionEventType(topLevelType) {
      switch (topLevelType) {
        case "topCompositionStart":
          return eventTypes.compositionStart;
        case "topCompositionEnd":
          return eventTypes.compositionEnd;
        case "topCompositionUpdate":
          return eventTypes.compositionUpdate;
      }
    }
    function isFallbackCompositionStart(topLevelType, nativeEvent) {
      return (
        topLevelType === "topKeyDown" && nativeEvent.keyCode === START_KEYCODE
      );
    }
    function isFallbackCompositionEnd(topLevelType, nativeEvent) {
      switch (topLevelType) {
        case "topKeyUp":
          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
        case "topKeyDown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "topKeyPress":
        case "topMouseDown":
        case "topBlur":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      var detail = nativeEvent.detail;
      if (typeof detail === "object" && "data" in detail) {
        return detail.data;
      }
      return null;
    }
    var currentComposition = null;
    function extractCompositionEvent(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      var eventType;
      var fallbackData;
      if (canUseCompositionEvent) {
        eventType = getCompositionEventType(topLevelType);
      } else if (!currentComposition) {
        if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionStart;
        }
      } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionEnd;
      }
      if (!eventType) {
        return null;
      }
      if (useFallbackCompositionData) {
        if (!currentComposition && eventType === eventTypes.compositionStart) {
          currentComposition = FallbackCompositionState.getPooled(
            nativeEventTarget
          );
        } else if (eventType === eventTypes.compositionEnd) {
          if (currentComposition) {
            fallbackData = currentComposition.getData();
          }
        }
      }
      var event = SyntheticCompositionEvent.getPooled(
        eventType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
      if (fallbackData) {
        event.data = fallbackData;
      } else {
        var customData = getDataFromCustomEvent(nativeEvent);
        if (customData !== null) {
          event.data = customData;
        }
      }
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
    function getNativeBeforeInputChars(topLevelType, nativeEvent) {
      switch (topLevelType) {
        case "topCompositionEnd":
          return getDataFromCustomEvent(nativeEvent);
        case "topKeyPress":
          var which = nativeEvent.which;
          if (which !== SPACEBAR_CODE) {
            return null;
          }
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "topTextInput":
          var chars = nativeEvent.data;
          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
            return null;
          }
          return chars;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
      if (currentComposition) {
        if (
          topLevelType === "topCompositionEnd" ||
          (!canUseCompositionEvent &&
            isFallbackCompositionEnd(topLevelType, nativeEvent))
        ) {
          var chars = currentComposition.getData();
          FallbackCompositionState.release(currentComposition);
          currentComposition = null;
          return chars;
        }
        return null;
      }
      switch (topLevelType) {
        case "topPaste":
          return null;
        case "topKeyPress":
          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
            return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "topCompositionEnd":
          return useFallbackCompositionData ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    function extractBeforeInputEvent(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      var chars;
      if (canUseTextInputEvent) {
        chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
      } else {
        chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
      }
      if (!chars) {
        return null;
      }
      var event = SyntheticInputEvent.getPooled(
        eventTypes.beforeInput,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
      event.data = chars;
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
    var BeforeInputEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        return [
          extractCompositionEvent(
            topLevelType,
            targetInst,
            nativeEvent,
            nativeEventTarget
          ),
          extractBeforeInputEvent(
            topLevelType,
            targetInst,
            nativeEvent,
            nativeEventTarget
          )
        ];
      }
    };
    module.exports = BeforeInputEventPlugin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var CSSProperty = __webpack_require__(75);
    var ExecutionEnvironment = __webpack_require__(8);
    var ReactInstrumentation = __webpack_require__(9);
    var camelizeStyleName = __webpack_require__(151);
    var dangerousStyleValue = __webpack_require__(224);
    var hyphenateStyleName = __webpack_require__(158);
    var memoizeStringOnly = __webpack_require__(161);
    var warning = __webpack_require__(4);
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var hasShorthandPropertyBug = false;
    var styleFloatAccessor = "cssFloat";
    if (ExecutionEnvironment.canUseDOM) {
      var tempStyle = document.createElement("div").style;
      try {
        tempStyle.font = "";
      } catch (e) {
        hasShorthandPropertyBug = true;
      }
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = "styleFloat";
      }
    }
    if (false) {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnedForNaNValue = false;
      var warnHyphenatedStyleName = function(name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "Unsupported style property %s. Did you mean %s?%s",
              name,
              camelizeStyleName(name),
              checkRenderMessage(owner)
            )
          : void 0;
      };
      var warnBadVendoredStyleName = function(name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "Unsupported vendor-prefixed style property %s. Did you mean %s?%s",
              name,
              name.charAt(0).toUpperCase() + name.slice(1),
              checkRenderMessage(owner)
            )
          : void 0;
      };
      var warnStyleValueWithSemicolon = function(name, value, owner) {
        if (
          warnedStyleValues.hasOwnProperty(value) &&
          warnedStyleValues[value]
        ) {
          return;
        }
        warnedStyleValues[value] = true;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "Style property values shouldn't contain a semicolon.%s " +
                'Try "%s: %s" instead.',
              checkRenderMessage(owner),
              name,
              value.replace(badStyleValueWithSemicolonPattern, "")
            )
          : void 0;
      };
      var warnStyleValueIsNaN = function(name, value, owner) {
        if (warnedForNaNValue) {
          return;
        }
        warnedForNaNValue = true;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "`NaN` is an invalid value for the `%s` css style property.%s",
              name,
              checkRenderMessage(owner)
            )
          : void 0;
      };
      var checkRenderMessage = function(owner) {
        if (owner) {
          var name = owner.getName();
          if (name) {
            return " Check the render method of `" + name + "`.";
          }
        }
        return "";
      };
      var warnValidStyle = function(name, value, component) {
        var owner;
        if (component) {
          owner = component._currentElement._owner;
        }
        if (name.indexOf("-") > -1) {
          warnHyphenatedStyleName(name, owner);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name, owner);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value, owner);
        }
        if (typeof value === "number" && isNaN(value)) {
          warnStyleValueIsNaN(name, value, owner);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles, component) {
        var serialized = "";
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          var styleValue = styles[styleName];
          if (false) {
            if (!isCustomProperty) {
              warnValidStyle(styleName, styleValue, component);
            }
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ":";
            serialized +=
              dangerousStyleValue(
                styleName,
                styleValue,
                component,
                isCustomProperty
              ) + ";";
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles, component) {
        if (false) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: component._debugID,
            type: "update styles",
            payload: styles
          });
        }
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (false) {
            if (!isCustomProperty) {
              warnValidStyle(styleName, styles[styleName], component);
            }
          }
          var styleValue = dangerousStyleValue(
            styleName,
            styles[styleName],
            component,
            isCustomProperty
          );
          if (styleName === "float" || styleName === "cssFloat") {
            styleName = styleFloatAccessor;
          }
          if (isCustomProperty) {
            style.setProperty(styleName, styleValue);
          } else if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion =
              hasShorthandPropertyBug &&
              CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = "";
              }
            } else {
              style[styleName] = "";
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPluginHub = __webpack_require__(25);
    var EventPropagators = __webpack_require__(26);
    var ExecutionEnvironment = __webpack_require__(8);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactUpdates = __webpack_require__(11);
    var SyntheticEvent = __webpack_require__(12);
    var inputValueTracking = __webpack_require__(91);
    var getEventTarget = __webpack_require__(52);
    var isEventSupported = __webpack_require__(53);
    var isTextInputElement = __webpack_require__(93);
    var eventTypes = {
      change: {
        phasedRegistrationNames: {
          bubbled: "onChange",
          captured: "onChangeCapture"
        },
        dependencies: [
          "topBlur",
          "topChange",
          "topClick",
          "topFocus",
          "topInput",
          "topKeyDown",
          "topKeyUp",
          "topSelectionChange"
        ]
      }
    };
    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
      var event = SyntheticEvent.getPooled(
        eventTypes.change,
        inst,
        nativeEvent,
        target
      );
      event.type = "change";
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
    var activeElement = null;
    var activeElementInst = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return (
        nodeName === "select" || (nodeName === "input" && elem.type === "file")
      );
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble =
        isEventSupported("change") &&
        (!document.documentMode || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = createAndAccumulateChangeEvent(
        activeElementInst,
        nativeEvent,
        getEventTarget(nativeEvent)
      );
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue(false);
    }
    function startWatchingForChangeEventIE8(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent("onchange", manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent("onchange", manualDispatchChangeEvent);
      activeElement = null;
      activeElementInst = null;
    }
    function getInstIfValueChanged(targetInst, nativeEvent) {
      var updated = inputValueTracking.updateValueIfChanged(targetInst);
      var simulated =
        nativeEvent.simulated === true &&
        ChangeEventPlugin._allowSimulatedPassThrough;
      if (updated || simulated) {
        return targetInst;
      }
    }
    function getTargetInstForChangeEvent(topLevelType, targetInst) {
      if (topLevelType === "topChange") {
        return targetInst;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
      if (topLevelType === "topFocus") {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(target, targetInst);
      } else if (topLevelType === "topBlur") {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported =
        isEventSupported("input") &&
        (!document.documentMode || document.documentMode > 9);
    }
    function startWatchingForValueChange(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent("onpropertychange", handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent("onpropertychange", handlePropertyChange);
      activeElement = null;
      activeElementInst = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== "value") {
        return;
      }
      if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
        manualDispatchChangeEvent(nativeEvent);
      }
    }
    function handleEventsForInputEventPolyfill(
      topLevelType,
      target,
      targetInst
    ) {
      if (topLevelType === "topFocus") {
        stopWatchingForValueChange();
        startWatchingForValueChange(target, targetInst);
      } else if (topLevelType === "topBlur") {
        stopWatchingForValueChange();
      }
    }
    function getTargetInstForInputEventPolyfill(
      topLevelType,
      targetInst,
      nativeEvent
    ) {
      if (
        topLevelType === "topSelectionChange" ||
        topLevelType === "topKeyUp" ||
        topLevelType === "topKeyDown"
      ) {
        return getInstIfValueChanged(activeElementInst, nativeEvent);
      }
    }
    function shouldUseClickEvent(elem) {
      var nodeName = elem.nodeName;
      return (
        nodeName &&
        nodeName.toLowerCase() === "input" &&
        (elem.type === "checkbox" || elem.type === "radio")
      );
    }
    function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
      if (topLevelType === "topClick") {
        return getInstIfValueChanged(targetInst, nativeEvent);
      }
    }
    function getTargetInstForInputOrChangeEvent(
      topLevelType,
      targetInst,
      nativeEvent
    ) {
      if (topLevelType === "topInput" || topLevelType === "topChange") {
        return getInstIfValueChanged(targetInst, nativeEvent);
      }
    }
    function handleControlledInputBlur(inst, node) {
      if (inst == null) {
        return;
      }
      var state = inst._wrapperState || node._wrapperState;
      if (!state || !state.controlled || node.type !== "number") {
        return;
      }
      var value = "" + node.value;
      if (node.getAttribute("value") !== value) {
        node.setAttribute("value", value);
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      _allowSimulatedPassThrough: true,
      _isInputEventSupported: isInputEventSupported,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var targetNode = targetInst
          ? ReactDOMComponentTree.getNodeFromInstance(targetInst)
          : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          if (doesChangeEventBubble) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
          if (inst) {
            var event = createAndAccumulateChangeEvent(
              inst,
              nativeEvent,
              nativeEventTarget
            );
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, targetNode, targetInst);
        }
        if (topLevelType === "topBlur") {
          handleControlledInputBlur(targetInst, targetNode);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var DOMLazyTree = __webpack_require__(18);
    var ExecutionEnvironment = __webpack_require__(8);
    var createNodesFromMarkup = __webpack_require__(154);
    var emptyFunction = __webpack_require__(10);
    var invariant = __webpack_require__(0);
    var Danger = {
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        !ExecutionEnvironment.canUseDOM
          ? false
            ? invariant(
                false,
                "dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering."
              )
            : _prodInvariant("56")
          : void 0;
        !markup
          ? false
            ? invariant(
                false,
                "dangerouslyReplaceNodeWithMarkup(...): Missing markup."
              )
            : _prodInvariant("57")
          : void 0;
        !(oldChild.nodeName !== "HTML")
          ? false
            ? invariant(
                false,
                "dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString()."
              )
            : _prodInvariant("58")
          : void 0;
        if (typeof markup === "string") {
          var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
          oldChild.parentNode.replaceChild(newChild, oldChild);
        } else {
          DOMLazyTree.replaceChildWithTree(oldChild, markup);
        }
      }
    };
    module.exports = Danger;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DefaultEventPluginOrder = [
      "ResponderEventPlugin",
      "SimpleEventPlugin",
      "TapEventPlugin",
      "EnterLeaveEventPlugin",
      "ChangeEventPlugin",
      "SelectEventPlugin",
      "BeforeInputEventPlugin"
    ];
    module.exports = DefaultEventPluginOrder;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPropagators = __webpack_require__(26);
    var ReactDOMComponentTree = __webpack_require__(7);
    var SyntheticMouseEvent = __webpack_require__(33);
    var eventTypes = {
      mouseEnter: {
        registrationName: "onMouseEnter",
        dependencies: ["topMouseOut", "topMouseOver"]
      },
      mouseLeave: {
        registrationName: "onMouseLeave",
        dependencies: ["topMouseOut", "topMouseOver"]
      }
    };
    var EnterLeaveEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        if (
          topLevelType === "topMouseOver" &&
          (nativeEvent.relatedTarget || nativeEvent.fromElement)
        ) {
          return null;
        }
        if (topLevelType !== "topMouseOut" && topLevelType !== "topMouseOver") {
          return null;
        }
        var win;
        if (nativeEventTarget.window === nativeEventTarget) {
          win = nativeEventTarget;
        } else {
          var doc = nativeEventTarget.ownerDocument;
          if (doc) {
            win = doc.defaultView || doc.parentWindow;
          } else {
            win = window;
          }
        }
        var from;
        var to;
        if (topLevelType === "topMouseOut") {
          from = targetInst;
          var related = nativeEvent.relatedTarget || nativeEvent.toElement;
          to = related
            ? ReactDOMComponentTree.getClosestInstanceFromNode(related)
            : null;
        } else {
          from = null;
          to = targetInst;
        }
        if (from === to) {
          return null;
        }
        var fromNode =
          from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
        var toNode =
          to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
        var leave = SyntheticMouseEvent.getPooled(
          eventTypes.mouseLeave,
          from,
          nativeEvent,
          nativeEventTarget
        );
        leave.type = "mouseleave";
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = SyntheticMouseEvent.getPooled(
          eventTypes.mouseEnter,
          to,
          nativeEvent,
          nativeEventTarget
        );
        enter.type = "mouseenter";
        enter.target = toNode;
        enter.relatedTarget = fromNode;
        EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
        return [leave, enter];
      }
    };
    module.exports = EnterLeaveEventPlugin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var PooledClass = __webpack_require__(17);
    var getTextContentAccessor = __webpack_require__(90);
    function FallbackCompositionState(root) {
      this._root = root;
      this._startText = this.getText();
      this._fallbackText = null;
    }
    _assign(FallbackCompositionState.prototype, {
      destructor: function() {
        this._root = null;
        this._startText = null;
        this._fallbackText = null;
      },
      getText: function() {
        if ("value" in this._root) {
          return this._root.value;
        }
        return this._root[getTextContentAccessor()];
      },
      getData: function() {
        if (this._fallbackText) {
          return this._fallbackText;
        }
        var start;
        var startValue = this._startText;
        var startLength = startValue.length;
        var end;
        var endValue = this.getText();
        var endLength = endValue.length;
        for (start = 0; start < startLength; start++) {
          if (startValue[start] !== endValue[start]) {
            break;
          }
        }
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd; end++) {
          if (startValue[startLength - end] !== endValue[endLength - end]) {
            break;
          }
        }
        var sliceTail = end > 1 ? 1 - end : undefined;
        this._fallbackText = endValue.slice(start, sliceTail);
        return this._fallbackText;
      }
    });
    PooledClass.addPoolingTo(FallbackCompositionState);
    module.exports = FallbackCompositionState;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMProperty = __webpack_require__(19);
    var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
    var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
    var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
    var HAS_POSITIVE_NUMERIC_VALUE =
      DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
    var HAS_OVERLOADED_BOOLEAN_VALUE =
      DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
    var HTMLDOMPropertyConfig = {
      isCustomAttribute: RegExp.prototype.test.bind(
        new RegExp("^(data|aria)-[" + DOMProperty.ATTRIBUTE_NAME_CHAR + "]*$")
      ),
      Properties: {
        accept: 0,
        acceptCharset: 0,
        accessKey: 0,
        action: 0,
        allowFullScreen: HAS_BOOLEAN_VALUE,
        allowTransparency: 0,
        alt: 0,
        as: 0,
        async: HAS_BOOLEAN_VALUE,
        autoComplete: 0,
        autoPlay: HAS_BOOLEAN_VALUE,
        capture: HAS_BOOLEAN_VALUE,
        cellPadding: 0,
        cellSpacing: 0,
        charSet: 0,
        challenge: 0,
        checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        cite: 0,
        classID: 0,
        className: 0,
        cols: HAS_POSITIVE_NUMERIC_VALUE,
        colSpan: 0,
        content: 0,
        contentEditable: 0,
        contextMenu: 0,
        controls: HAS_BOOLEAN_VALUE,
        controlsList: 0,
        coords: 0,
        crossOrigin: 0,
        data: 0,
        dateTime: 0,
        default: HAS_BOOLEAN_VALUE,
        defer: HAS_BOOLEAN_VALUE,
        dir: 0,
        disabled: HAS_BOOLEAN_VALUE,
        download: HAS_OVERLOADED_BOOLEAN_VALUE,
        draggable: 0,
        encType: 0,
        form: 0,
        formAction: 0,
        formEncType: 0,
        formMethod: 0,
        formNoValidate: HAS_BOOLEAN_VALUE,
        formTarget: 0,
        frameBorder: 0,
        headers: 0,
        height: 0,
        hidden: HAS_BOOLEAN_VALUE,
        high: 0,
        href: 0,
        hrefLang: 0,
        htmlFor: 0,
        httpEquiv: 0,
        icon: 0,
        id: 0,
        inputMode: 0,
        integrity: 0,
        is: 0,
        keyParams: 0,
        keyType: 0,
        kind: 0,
        label: 0,
        lang: 0,
        list: 0,
        loop: HAS_BOOLEAN_VALUE,
        low: 0,
        manifest: 0,
        marginHeight: 0,
        marginWidth: 0,
        max: 0,
        maxLength: 0,
        media: 0,
        mediaGroup: 0,
        method: 0,
        min: 0,
        minLength: 0,
        multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        name: 0,
        nonce: 0,
        noValidate: HAS_BOOLEAN_VALUE,
        open: HAS_BOOLEAN_VALUE,
        optimum: 0,
        pattern: 0,
        placeholder: 0,
        playsInline: HAS_BOOLEAN_VALUE,
        poster: 0,
        preload: 0,
        profile: 0,
        radioGroup: 0,
        readOnly: HAS_BOOLEAN_VALUE,
        referrerPolicy: 0,
        rel: 0,
        required: HAS_BOOLEAN_VALUE,
        reversed: HAS_BOOLEAN_VALUE,
        role: 0,
        rows: HAS_POSITIVE_NUMERIC_VALUE,
        rowSpan: HAS_NUMERIC_VALUE,
        sandbox: 0,
        scope: 0,
        scoped: HAS_BOOLEAN_VALUE,
        scrolling: 0,
        seamless: HAS_BOOLEAN_VALUE,
        selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        shape: 0,
        size: HAS_POSITIVE_NUMERIC_VALUE,
        sizes: 0,
        span: HAS_POSITIVE_NUMERIC_VALUE,
        spellCheck: 0,
        src: 0,
        srcDoc: 0,
        srcLang: 0,
        srcSet: 0,
        start: HAS_NUMERIC_VALUE,
        step: 0,
        style: 0,
        summary: 0,
        tabIndex: 0,
        target: 0,
        title: 0,
        type: 0,
        useMap: 0,
        value: 0,
        width: 0,
        wmode: 0,
        wrap: 0,
        about: 0,
        datatype: 0,
        inlist: 0,
        prefix: 0,
        property: 0,
        resource: 0,
        typeof: 0,
        vocab: 0,
        autoCapitalize: 0,
        autoCorrect: 0,
        autoSave: 0,
        color: 0,
        itemProp: 0,
        itemScope: HAS_BOOLEAN_VALUE,
        itemType: 0,
        itemID: 0,
        itemRef: 0,
        results: 0,
        security: 0,
        unselectable: 0
      },
      DOMAttributeNames: {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv"
      },
      DOMPropertyNames: {},
      DOMMutationMethods: {
        value: function(node, value) {
          if (value == null) {
            return node.removeAttribute("value");
          }
          if (node.type !== "number" || node.hasAttribute("value") === false) {
            node.setAttribute("value", "" + value);
          } else if (
            node.validity &&
            !node.validity.badInput &&
            node.ownerDocument.activeElement !== node
          ) {
            node.setAttribute("value", "" + value);
          }
        }
      }
    };
    module.exports = HTMLDOMPropertyConfig;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    (function(process) {
      var ReactReconciler = __webpack_require__(20);
      var instantiateReactComponent = __webpack_require__(92);
      var KeyEscapeUtils = __webpack_require__(44);
      var shouldUpdateReactComponent = __webpack_require__(54);
      var traverseAllChildren = __webpack_require__(95);
      var warning = __webpack_require__(4);
      var ReactComponentTreeHook;
      if (
        typeof process !== "undefined" &&
        __webpack_require__.i({ NODE_ENV: "production" }) &&
        "production" === "test"
      ) {
        ReactComponentTreeHook = __webpack_require__(101);
      }
      function instantiateChild(childInstances, child, name, selfDebugID) {
        var keyUnique = childInstances[name] === undefined;
        if (false) {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require("react/lib/ReactComponentTreeHook");
          }
          if (!keyUnique) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "flattenChildren(...): Encountered two children with the same key, " +
                    "`%s`. Child keys must be unique; when two children share a key, only " +
                    "the first child will be used.%s",
                  KeyEscapeUtils.unescape(name),
                  ReactComponentTreeHook.getStackAddendumByID(selfDebugID)
                )
              : void 0;
          }
        }
        if (child != null && keyUnique) {
          childInstances[name] = instantiateReactComponent(child, true);
        }
      }
      var ReactChildReconciler = {
        instantiateChildren: function(
          nestedChildNodes,
          transaction,
          context,
          selfDebugID
        ) {
          if (nestedChildNodes == null) {
            return null;
          }
          var childInstances = {};
          if (false) {
            traverseAllChildren(
              nestedChildNodes,
              function(childInsts, child, name) {
                return instantiateChild(childInsts, child, name, selfDebugID);
              },
              childInstances
            );
          } else {
            traverseAllChildren(
              nestedChildNodes,
              instantiateChild,
              childInstances
            );
          }
          return childInstances;
        },
        updateChildren: function(
          prevChildren,
          nextChildren,
          mountImages,
          removedNodes,
          transaction,
          hostParent,
          hostContainerInfo,
          context,
          selfDebugID
        ) {
          if (!nextChildren && !prevChildren) {
            return;
          }
          var name;
          var prevChild;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            prevChild = prevChildren && prevChildren[name];
            var prevElement = prevChild && prevChild._currentElement;
            var nextElement = nextChildren[name];
            if (
              prevChild != null &&
              shouldUpdateReactComponent(prevElement, nextElement)
            ) {
              ReactReconciler.receiveComponent(
                prevChild,
                nextElement,
                transaction,
                context
              );
              nextChildren[name] = prevChild;
            } else {
              if (prevChild) {
                removedNodes[name] = ReactReconciler.getHostNode(prevChild);
                ReactReconciler.unmountComponent(prevChild, false);
              }
              var nextChildInstance = instantiateReactComponent(
                nextElement,
                true
              );
              nextChildren[name] = nextChildInstance;
              var nextChildMountImage = ReactReconciler.mountComponent(
                nextChildInstance,
                transaction,
                hostParent,
                hostContainerInfo,
                context,
                selfDebugID
              );
              mountImages.push(nextChildMountImage);
            }
          }
          for (name in prevChildren) {
            if (
              prevChildren.hasOwnProperty(name) &&
              !(nextChildren && nextChildren.hasOwnProperty(name))
            ) {
              prevChild = prevChildren[name];
              removedNodes[name] = ReactReconciler.getHostNode(prevChild);
              ReactReconciler.unmountComponent(prevChild, false);
            }
          }
        },
        unmountChildren: function(renderedChildren, safely) {
          for (var name in renderedChildren) {
            if (renderedChildren.hasOwnProperty(name)) {
              var renderedChild = renderedChildren[name];
              ReactReconciler.unmountComponent(renderedChild, safely);
            }
          }
        }
      };
      module.exports = ReactChildReconciler;
    }.call(exports, __webpack_require__(39)));
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMChildrenOperations = __webpack_require__(40);
    var ReactDOMIDOperations = __webpack_require__(188);
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates:
        ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkup:
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
    };
    module.exports = ReactComponentBrowserEnvironment;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var React = __webpack_require__(21);
    var ReactComponentEnvironment = __webpack_require__(46);
    var ReactCurrentOwner = __webpack_require__(13);
    var ReactErrorUtils = __webpack_require__(47);
    var ReactInstanceMap = __webpack_require__(27);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactNodeTypes = __webpack_require__(85);
    var ReactReconciler = __webpack_require__(20);
    if (false) {
      var checkReactTypeSpec = require("./checkReactTypeSpec");
    }
    var emptyObject = __webpack_require__(30);
    var invariant = __webpack_require__(0);
    var shallowEqual = __webpack_require__(38);
    var shouldUpdateReactComponent = __webpack_require__(54);
    var warning = __webpack_require__(4);
    var CompositeTypes = {
      ImpureClass: 0,
      PureClass: 1,
      StatelessFunctional: 2
    };
    function StatelessComponent(Component) {}
    StatelessComponent.prototype.render = function() {
      var Component = ReactInstanceMap.get(this)._currentElement.type;
      var element = Component(this.props, this.context, this.updater);
      warnIfInvalidElement(Component, element);
      return element;
    };
    function warnIfInvalidElement(Component, element) {
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(
              element === null ||
                element === false ||
                React.isValidElement(element),
              "%s(...): A valid React element (or null) must be returned. You may have " +
                "returned undefined, an array or some other invalid object.",
              Component.displayName || Component.name || "Component"
            )
          : void 0;
        process.env.NODE_ENV !== "production"
          ? warning(
              !Component.childContextTypes,
              "%s(...): childContextTypes cannot be defined on a functional component.",
              Component.displayName || Component.name || "Component"
            )
          : void 0;
      }
    }
    function shouldConstruct(Component) {
      return !!(Component.prototype && Component.prototype.isReactComponent);
    }
    function isPureComponent(Component) {
      return !!(
        Component.prototype && Component.prototype.isPureReactComponent
      );
    }
    function measureLifeCyclePerf(fn, debugID, timerType) {
      if (debugID === 0) {
        return fn();
      }
      ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
      try {
        return fn();
      } finally {
        ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
      }
    }
    var nextMountID = 1;
    var ReactCompositeComponent = {
      construct: function(element) {
        this._currentElement = element;
        this._rootNodeID = 0;
        this._compositeType = null;
        this._instance = null;
        this._hostParent = null;
        this._hostContainerInfo = null;
        this._updateBatchNumber = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedNodeType = null;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._topLevelWrapper = null;
        this._pendingCallbacks = null;
        this._calledComponentWillUnmount = false;
        if (false) {
          this._warnedAboutRefsInRender = false;
        }
      },
      mountComponent: function(
        transaction,
        hostParent,
        hostContainerInfo,
        context
      ) {
        var _this = this;
        this._context = context;
        this._mountOrder = nextMountID++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var publicProps = this._currentElement.props;
        var publicContext = this._processContext(context);
        var Component = this._currentElement.type;
        var updateQueue = transaction.getUpdateQueue();
        var doConstruct = shouldConstruct(Component);
        var inst = this._constructComponent(
          doConstruct,
          publicProps,
          publicContext,
          updateQueue
        );
        var renderedElement;
        if (!doConstruct && (inst == null || inst.render == null)) {
          renderedElement = inst;
          warnIfInvalidElement(Component, renderedElement);
          !(inst === null || inst === false || React.isValidElement(inst))
            ? false
              ? invariant(
                  false,
                  "%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.",
                  Component.displayName || Component.name || "Component"
                )
              : _prodInvariant(
                  "105",
                  Component.displayName || Component.name || "Component"
                )
            : void 0;
          inst = new StatelessComponent(Component);
          this._compositeType = CompositeTypes.StatelessFunctional;
        } else {
          if (isPureComponent(Component)) {
            this._compositeType = CompositeTypes.PureClass;
          } else {
            this._compositeType = CompositeTypes.ImpureClass;
          }
        }
        if (false) {
          if (inst.render == null) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "%s(...): No `render` method found on the returned component " +
                    "instance: you may have forgotten to define `render`.",
                  Component.displayName || Component.name || "Component"
                )
              : void 0;
          }
          var propsMutated = inst.props !== publicProps;
          var componentName =
            Component.displayName || Component.name || "Component";
          process.env.NODE_ENV !== "production"
            ? warning(
                inst.props === undefined || !propsMutated,
                "%s(...): When calling super() in `%s`, make sure to pass " +
                  "up the same props that your component's constructor was passed.",
                componentName,
                componentName
              )
            : void 0;
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        inst.updater = updateQueue;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                !inst.getInitialState ||
                  inst.getInitialState.isReactClassApproved ||
                  inst.state,
                "getInitialState was defined on %s, a plain JavaScript class. " +
                  "This is only supported for classes created using React.createClass. " +
                  "Did you mean to define a state property instead?",
                this.getName() || "a component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                !inst.getDefaultProps ||
                  inst.getDefaultProps.isReactClassApproved,
                "getDefaultProps was defined on %s, a plain JavaScript class. " +
                  "This is only supported for classes created using React.createClass. " +
                  "Use a static property to define defaultProps instead.",
                this.getName() || "a component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                !inst.propTypes,
                "propTypes was defined as an instance property on %s. Use a static " +
                  "property to define propTypes instead.",
                this.getName() || "a component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                !inst.contextTypes,
                "contextTypes was defined as an instance property on %s. Use a " +
                  "static property to define contextTypes instead.",
                this.getName() || "a component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                typeof inst.componentShouldUpdate !== "function",
                "%s has a method called " +
                  "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
                  "The name is phrased as a question because the function is " +
                  "expected to return a value.",
                this.getName() || "A component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                typeof inst.componentDidUnmount !== "function",
                "%s has a method called " +
                  "componentDidUnmount(). But there is no such lifecycle method. " +
                  "Did you mean componentWillUnmount()?",
                this.getName() || "A component"
              )
            : void 0;
          process.env.NODE_ENV !== "production"
            ? warning(
                typeof inst.componentWillRecieveProps !== "function",
                "%s has a method called " +
                  "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
                this.getName() || "A component"
              )
            : void 0;
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        !(typeof initialState === "object" && !Array.isArray(initialState))
          ? false
            ? invariant(
                false,
                "%s.state: must be set to an object or null",
                this.getName() || "ReactCompositeComponent"
              )
            : _prodInvariant("106", this.getName() || "ReactCompositeComponent")
          : void 0;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        var markup;
        if (inst.unstable_handleError) {
          markup = this.performInitialMountWithErrorHandling(
            renderedElement,
            hostParent,
            hostContainerInfo,
            transaction,
            context
          );
        } else {
          markup = this.performInitialMount(
            renderedElement,
            hostParent,
            hostContainerInfo,
            transaction,
            context
          );
        }
        if (inst.componentDidMount) {
          if (false) {
            transaction.getReactMountReady().enqueue(function() {
              measureLifeCyclePerf(
                function() {
                  return inst.componentDidMount();
                },
                _this._debugID,
                "componentDidMount"
              );
            });
          } else {
            transaction
              .getReactMountReady()
              .enqueue(inst.componentDidMount, inst);
          }
        }
        return markup;
      },
      _constructComponent: function(
        doConstruct,
        publicProps,
        publicContext,
        updateQueue
      ) {
        if (false) {
          ReactCurrentOwner.current = this;
          try {
            return this._constructComponentWithoutOwner(
              doConstruct,
              publicProps,
              publicContext,
              updateQueue
            );
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          return this._constructComponentWithoutOwner(
            doConstruct,
            publicProps,
            publicContext,
            updateQueue
          );
        }
      },
      _constructComponentWithoutOwner: function(
        doConstruct,
        publicProps,
        publicContext,
        updateQueue
      ) {
        var Component = this._currentElement.type;
        if (doConstruct) {
          if (false) {
            return measureLifeCyclePerf(
              function() {
                return new Component(publicProps, publicContext, updateQueue);
              },
              this._debugID,
              "ctor"
            );
          } else {
            return new Component(publicProps, publicContext, updateQueue);
          }
        }
        if (false) {
          return measureLifeCyclePerf(
            function() {
              return Component(publicProps, publicContext, updateQueue);
            },
            this._debugID,
            "render"
          );
        } else {
          return Component(publicProps, publicContext, updateQueue);
        }
      },
      performInitialMountWithErrorHandling: function(
        renderedElement,
        hostParent,
        hostContainerInfo,
        transaction,
        context
      ) {
        var markup;
        var checkpoint = transaction.checkpoint();
        try {
          markup = this.performInitialMount(
            renderedElement,
            hostParent,
            hostContainerInfo,
            transaction,
            context
          );
        } catch (e) {
          transaction.rollback(checkpoint);
          this._instance.unstable_handleError(e);
          if (this._pendingStateQueue) {
            this._instance.state = this._processPendingState(
              this._instance.props,
              this._instance.context
            );
          }
          checkpoint = transaction.checkpoint();
          this._renderedComponent.unmountComponent(true);
          transaction.rollback(checkpoint);
          markup = this.performInitialMount(
            renderedElement,
            hostParent,
            hostContainerInfo,
            transaction,
            context
          );
        }
        return markup;
      },
      performInitialMount: function(
        renderedElement,
        hostParent,
        hostContainerInfo,
        transaction,
        context
      ) {
        var inst = this._instance;
        var debugID = 0;
        if (false) {
          debugID = this._debugID;
        }
        if (inst.componentWillMount) {
          if (false) {
            measureLifeCyclePerf(
              function() {
                return inst.componentWillMount();
              },
              debugID,
              "componentWillMount"
            );
          } else {
            inst.componentWillMount();
          }
          if (this._pendingStateQueue) {
            inst.state = this._processPendingState(inst.props, inst.context);
          }
        }
        if (renderedElement === undefined) {
          renderedElement = this._renderValidatedComponent();
        }
        var nodeType = ReactNodeTypes.getType(renderedElement);
        this._renderedNodeType = nodeType;
        var child = this._instantiateReactComponent(
          renderedElement,
          nodeType !== ReactNodeTypes.EMPTY
        );
        this._renderedComponent = child;
        var markup = ReactReconciler.mountComponent(
          child,
          transaction,
          hostParent,
          hostContainerInfo,
          this._processChildContext(context),
          debugID
        );
        if (false) {
          if (debugID !== 0) {
            var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
            ReactInstrumentation.debugTool.onSetChildren(
              debugID,
              childDebugIDs
            );
          }
        }
        return markup;
      },
      getHostNode: function() {
        return ReactReconciler.getHostNode(this._renderedComponent);
      },
      unmountComponent: function(safely) {
        if (!this._renderedComponent) {
          return;
        }
        var inst = this._instance;
        if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
          inst._calledComponentWillUnmount = true;
          if (safely) {
            var name = this.getName() + ".componentWillUnmount()";
            ReactErrorUtils.invokeGuardedCallback(
              name,
              inst.componentWillUnmount.bind(inst)
            );
          } else {
            if (false) {
              measureLifeCyclePerf(
                function() {
                  return inst.componentWillUnmount();
                },
                this._debugID,
                "componentWillUnmount"
              );
            } else {
              inst.componentWillUnmount();
            }
          }
        }
        if (this._renderedComponent) {
          ReactReconciler.unmountComponent(this._renderedComponent, safely);
          this._renderedNodeType = null;
          this._renderedComponent = null;
          this._instance = null;
        }
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = 0;
        this._topLevelWrapper = null;
        ReactInstanceMap.remove(inst);
      },
      _maskContext: function(context) {
        var Component = this._currentElement.type;
        var contextTypes = Component.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        var maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function(context) {
        var maskedContext = this._maskContext(context);
        if (false) {
          var Component = this._currentElement.type;
          if (Component.contextTypes) {
            this._checkContextTypes(
              Component.contextTypes,
              maskedContext,
              "context"
            );
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var Component = this._currentElement.type;
        var inst = this._instance;
        var childContext;
        if (inst.getChildContext) {
          if (false) {
            ReactInstrumentation.debugTool.onBeginProcessingChildContext();
            try {
              childContext = inst.getChildContext();
            } finally {
              ReactInstrumentation.debugTool.onEndProcessingChildContext();
            }
          } else {
            childContext = inst.getChildContext();
          }
        }
        if (childContext) {
          !(typeof Component.childContextTypes === "object")
            ? false
              ? invariant(
                  false,
                  "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
                  this.getName() || "ReactCompositeComponent"
                )
              : _prodInvariant(
                  "107",
                  this.getName() || "ReactCompositeComponent"
                )
            : void 0;
          if (false) {
            this._checkContextTypes(
              Component.childContextTypes,
              childContext,
              "child context"
            );
          }
          for (var name in childContext) {
            !(name in Component.childContextTypes)
              ? false
                ? invariant(
                    false,
                    '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
                    this.getName() || "ReactCompositeComponent",
                    name
                  )
                : _prodInvariant(
                    "108",
                    this.getName() || "ReactCompositeComponent",
                    name
                  )
              : void 0;
          }
          return _assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _checkContextTypes: function(typeSpecs, values, location) {
        if (false) {
          checkReactTypeSpec(
            typeSpecs,
            values,
            location,
            this.getName(),
            null,
            this._debugID
          );
        }
      },
      receiveComponent: function(nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(
          transaction,
          prevElement,
          nextElement,
          prevContext,
          nextContext
        );
      },
      performUpdateIfNecessary: function(transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(
            this,
            this._pendingElement,
            transaction,
            this._context
          );
        } else if (
          this._pendingStateQueue !== null ||
          this._pendingForceUpdate
        ) {
          this.updateComponent(
            transaction,
            this._currentElement,
            this._currentElement,
            this._context,
            this._context
          );
        } else {
          this._updateBatchNumber = null;
        }
      },
      updateComponent: function(
        transaction,
        prevParentElement,
        nextParentElement,
        prevUnmaskedContext,
        nextUnmaskedContext
      ) {
        var inst = this._instance;
        !(inst != null)
          ? false
            ? invariant(
                false,
                "Attempted to update component `%s` that has already been unmounted (or failed to mount).",
                this.getName() || "ReactCompositeComponent"
              )
            : _prodInvariant("136", this.getName() || "ReactCompositeComponent")
          : void 0;
        var willReceive = false;
        var nextContext;
        if (this._context === nextUnmaskedContext) {
          nextContext = inst.context;
        } else {
          nextContext = this._processContext(nextUnmaskedContext);
          willReceive = true;
        }
        var prevProps = prevParentElement.props;
        var nextProps = nextParentElement.props;
        if (prevParentElement !== nextParentElement) {
          willReceive = true;
        }
        if (willReceive && inst.componentWillReceiveProps) {
          if (false) {
            measureLifeCyclePerf(
              function() {
                return inst.componentWillReceiveProps(nextProps, nextContext);
              },
              this._debugID,
              "componentWillReceiveProps"
            );
          } else {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = true;
        if (!this._pendingForceUpdate) {
          if (inst.shouldComponentUpdate) {
            if (false) {
              shouldUpdate = measureLifeCyclePerf(
                function() {
                  return inst.shouldComponentUpdate(
                    nextProps,
                    nextState,
                    nextContext
                  );
                },
                this._debugID,
                "shouldComponentUpdate"
              );
            } else {
              shouldUpdate = inst.shouldComponentUpdate(
                nextProps,
                nextState,
                nextContext
              );
            }
          } else {
            if (this._compositeType === CompositeTypes.PureClass) {
              shouldUpdate =
                !shallowEqual(prevProps, nextProps) ||
                !shallowEqual(inst.state, nextState);
            }
          }
        }
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                shouldUpdate !== undefined,
                "%s.shouldComponentUpdate(): Returned undefined instead of a " +
                  "boolean value. Make sure to return true or false.",
                this.getName() || "ReactCompositeComponent"
              )
            : void 0;
        }
        this._updateBatchNumber = null;
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(
            nextParentElement,
            nextProps,
            nextState,
            nextContext,
            transaction,
            nextUnmaskedContext
          );
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function(props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = _assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          _assign(
            nextState,
            typeof partial === "function"
              ? partial.call(inst, nextState, props, context)
              : partial
          );
        }
        return nextState;
      },
      _performComponentUpdate: function(
        nextElement,
        nextProps,
        nextState,
        nextContext,
        transaction,
        unmaskedContext
      ) {
        var _this2 = this;
        var inst = this._instance;
        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
        var prevProps;
        var prevState;
        var prevContext;
        if (hasComponentDidUpdate) {
          prevProps = inst.props;
          prevState = inst.state;
          prevContext = inst.context;
        }
        if (inst.componentWillUpdate) {
          if (false) {
            measureLifeCyclePerf(
              function() {
                return inst.componentWillUpdate(
                  nextProps,
                  nextState,
                  nextContext
                );
              },
              this._debugID,
              "componentWillUpdate"
            );
          } else {
            inst.componentWillUpdate(nextProps, nextState, nextContext);
          }
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (hasComponentDidUpdate) {
          if (false) {
            transaction.getReactMountReady().enqueue(function() {
              measureLifeCyclePerf(
                inst.componentDidUpdate.bind(
                  inst,
                  prevProps,
                  prevState,
                  prevContext
                ),
                _this2._debugID,
                "componentDidUpdate"
              );
            });
          } else {
            transaction
              .getReactMountReady()
              .enqueue(
                inst.componentDidUpdate.bind(
                  inst,
                  prevProps,
                  prevState,
                  prevContext
                ),
                inst
              );
          }
        }
      },
      _updateRenderedComponent: function(transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var nextRenderedElement = this._renderValidatedComponent();
        var debugID = 0;
        if (false) {
          debugID = this._debugID;
        }
        if (
          shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)
        ) {
          ReactReconciler.receiveComponent(
            prevComponentInstance,
            nextRenderedElement,
            transaction,
            this._processChildContext(context)
          );
        } else {
          var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
          ReactReconciler.unmountComponent(prevComponentInstance, false);
          var nodeType = ReactNodeTypes.getType(nextRenderedElement);
          this._renderedNodeType = nodeType;
          var child = this._instantiateReactComponent(
            nextRenderedElement,
            nodeType !== ReactNodeTypes.EMPTY
          );
          this._renderedComponent = child;
          var nextMarkup = ReactReconciler.mountComponent(
            child,
            transaction,
            this._hostParent,
            this._hostContainerInfo,
            this._processChildContext(context),
            debugID
          );
          if (false) {
            if (debugID !== 0) {
              var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
              ReactInstrumentation.debugTool.onSetChildren(
                debugID,
                childDebugIDs
              );
            }
          }
          this._replaceNodeWithMarkup(
            oldHostNode,
            nextMarkup,
            prevComponentInstance
          );
        }
      },
      _replaceNodeWithMarkup: function(oldHostNode, nextMarkup, prevInstance) {
        ReactComponentEnvironment.replaceNodeWithMarkup(
          oldHostNode,
          nextMarkup,
          prevInstance
        );
      },
      _renderValidatedComponentWithoutOwnerOrContext: function() {
        var inst = this._instance;
        var renderedElement;
        if (false) {
          renderedElement = measureLifeCyclePerf(
            function() {
              return inst.render();
            },
            this._debugID,
            "render"
          );
        } else {
          renderedElement = inst.render();
        }
        if (false) {
          if (renderedElement === undefined && inst.render._isMockFunction) {
            renderedElement = null;
          }
        }
        return renderedElement;
      },
      _renderValidatedComponent: function() {
        var renderedElement;
        if (
          "production" !== "production" ||
          this._compositeType !== CompositeTypes.StatelessFunctional
        ) {
          ReactCurrentOwner.current = this;
          try {
            renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
        }
        !(
          renderedElement === null ||
          renderedElement === false ||
          React.isValidElement(renderedElement)
        )
          ? false
            ? invariant(
                false,
                "%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.",
                this.getName() || "ReactCompositeComponent"
              )
            : _prodInvariant("109", this.getName() || "ReactCompositeComponent")
          : void 0;
        return renderedElement;
      },
      attachRef: function(ref, component) {
        var inst = this.getPublicInstance();
        !(inst != null)
          ? false
            ? invariant(
                false,
                "Stateless function components cannot have refs."
              )
            : _prodInvariant("110")
          : void 0;
        var publicComponentInstance = component.getPublicInstance();
        if (false) {
          var componentName =
            component && component.getName
              ? component.getName()
              : "a component";
          process.env.NODE_ENV !== "production"
            ? warning(
                publicComponentInstance != null ||
                  component._compositeType !==
                    CompositeTypes.StatelessFunctional,
                "Stateless function components cannot be given refs " +
                  '(See ref "%s" in %s created by %s). ' +
                  "Attempts to access this ref will fail.",
                ref,
                componentName,
                this.getName()
              )
            : void 0;
        }
        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;
        refs[ref] = publicComponentInstance;
      },
      detachRef: function(ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function() {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return (
          type.displayName ||
          (constructor && constructor.displayName) ||
          type.name ||
          (constructor && constructor.name) ||
          null
        );
      },
      getPublicInstance: function() {
        var inst = this._instance;
        if (this._compositeType === CompositeTypes.StatelessFunctional) {
          return null;
        }
        return inst;
      },
      _instantiateReactComponent: null
    };
    module.exports = ReactCompositeComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDefaultInjection = __webpack_require__(196);
    var ReactMount = __webpack_require__(84);
    var ReactReconciler = __webpack_require__(20);
    var ReactUpdates = __webpack_require__(11);
    var ReactVersion = __webpack_require__(209);
    var findDOMNode = __webpack_require__(225);
    var getHostComponentFromComposite = __webpack_require__(89);
    var renderSubtreeIntoContainer = __webpack_require__(232);
    var warning = __webpack_require__(4);
    ReactDefaultInjection.inject();
    var ReactDOM = {
      findDOMNode: findDOMNode,
      render: ReactMount.render,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      version: ReactVersion,
      unstable_batchedUpdates: ReactUpdates.batchedUpdates,
      unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
    };
    if (
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === "function"
    ) {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        ComponentTree: {
          getClosestInstanceFromNode:
            ReactDOMComponentTree.getClosestInstanceFromNode,
          getNodeFromInstance: function(inst) {
            if (inst._renderedComponent) {
              inst = getHostComponentFromComposite(inst);
            }
            if (inst) {
              return ReactDOMComponentTree.getNodeFromInstance(inst);
            } else {
              return null;
            }
          }
        },
        Mount: ReactMount,
        Reconciler: ReactReconciler
      });
    }
    if (false) {
      var ExecutionEnvironment = require("fbjs/lib/ExecutionEnvironment");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          if (
            (navigator.userAgent.indexOf("Chrome") > -1 &&
              navigator.userAgent.indexOf("Edge") === -1) ||
            navigator.userAgent.indexOf("Firefox") > -1
          ) {
            var showFileUrlMessage =
              window.location.protocol.indexOf("http") === -1 &&
              navigator.userAgent.indexOf("Firefox") === -1;
            console.debug(
              "Download the React DevTools " +
                (showFileUrlMessage
                  ? "and use an HTTP server (instead of a file: URL) "
                  : "") +
                "for a better development experience: " +
                "https://fb.me/react-devtools"
            );
          }
        }
        var testFunc = function testFn() {};
        process.env.NODE_ENV !== "production"
          ? warning(
              (testFunc.name || testFunc.toString()).indexOf("testFn") !== -1,
              "It looks like you're using a minified copy of the development build " +
                "of React. When deploying React apps to production, make sure to use " +
                "the production build which skips development warnings and is faster. " +
                "See https://fb.me/react-minification for more details."
            )
          : void 0;
        var ieCompatibilityMode =
          document.documentMode && document.documentMode < 8;
        process.env.NODE_ENV !== "production"
          ? warning(
              !ieCompatibilityMode,
              "Internet Explorer is running in compatibility mode; please add the " +
                "following tag to your HTML to prevent this from happening: " +
                '<meta http-equiv="X-UA-Compatible" content="IE=edge" />'
            )
          : void 0;
        var expectedFeatures = [
          Array.isArray,
          Array.prototype.every,
          Array.prototype.forEach,
          Array.prototype.indexOf,
          Array.prototype.map,
          Date.now,
          Function.prototype.bind,
          Object.keys,
          String.prototype.trim
        ];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "One or more ES5 shims expected by React are not available: " +
                    "https://fb.me/react-warning-polyfills"
                )
              : void 0;
            break;
          }
        }
      }
    }
    if (false) {
      var ReactInstrumentation = require("./ReactInstrumentation");
      var ReactDOMUnknownPropertyHook = require("./ReactDOMUnknownPropertyHook");
      var ReactDOMNullInputValuePropHook = require("./ReactDOMNullInputValuePropHook");
      var ReactDOMInvalidARIAHook = require("./ReactDOMInvalidARIAHook");
      ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
    }
    module.exports = ReactDOM;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var AutoFocusUtils = __webpack_require__(171);
    var CSSPropertyOperations = __webpack_require__(173);
    var DOMLazyTree = __webpack_require__(18);
    var DOMNamespaces = __webpack_require__(41);
    var DOMProperty = __webpack_require__(19);
    var DOMPropertyOperations = __webpack_require__(77);
    var EventPluginHub = __webpack_require__(25);
    var EventPluginRegistry = __webpack_require__(42);
    var ReactBrowserEventEmitter = __webpack_require__(32);
    var ReactDOMComponentFlags = __webpack_require__(78);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMInput = __webpack_require__(189);
    var ReactDOMOption = __webpack_require__(190);
    var ReactDOMSelect = __webpack_require__(79);
    var ReactDOMTextarea = __webpack_require__(193);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactMultiChild = __webpack_require__(202);
    var ReactServerRenderingTransaction = __webpack_require__(207);
    var emptyFunction = __webpack_require__(10);
    var escapeTextContentForBrowser = __webpack_require__(35);
    var invariant = __webpack_require__(0);
    var isEventSupported = __webpack_require__(53);
    var shallowEqual = __webpack_require__(38);
    var inputValueTracking = __webpack_require__(91);
    var validateDOMNesting = __webpack_require__(55);
    var warning = __webpack_require__(4);
    var Flags = ReactDOMComponentFlags;
    var deleteListener = EventPluginHub.deleteListener;
    var getNode = ReactDOMComponentTree.getNodeFromInstance;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    var CONTENT_TYPES = { string: true, number: true };
    var STYLE = "style";
    var HTML = "__html";
    var RESERVED_PROPS = {
      children: null,
      dangerouslySetInnerHTML: null,
      suppressContentEditableWarning: null
    };
    var DOC_FRAGMENT_TYPE = 11;
    function getDeclarationErrorAddendum(internalInstance) {
      if (internalInstance) {
        var owner = internalInstance._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name) {
            return " This DOM node was rendered by `" + name + "`.";
          }
        }
      }
      return "";
    }
    function friendlyStringify(obj) {
      if (typeof obj === "object") {
        if (Array.isArray(obj)) {
          return "[" + obj.map(friendlyStringify).join(", ") + "]";
        } else {
          var pairs = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key)
                ? key
                : JSON.stringify(key);
              pairs.push(keyEscaped + ": " + friendlyStringify(obj[key]));
            }
          }
          return "{" + pairs.join(", ") + "}";
        }
      } else if (typeof obj === "string") {
        return JSON.stringify(obj);
      } else if (typeof obj === "function") {
        return "[function object]";
      }
      return String(obj);
    }
    var styleMutationWarning = {};
    function checkAndWarnForMutatedStyle(style1, style2, component) {
      if (style1 == null || style2 == null) {
        return;
      }
      if (shallowEqual(style1, style2)) {
        return;
      }
      var componentName = component._tag;
      var owner = component._currentElement._owner;
      var ownerName;
      if (owner) {
        ownerName = owner.getName();
      }
      var hash = ownerName + "|" + componentName;
      if (styleMutationWarning.hasOwnProperty(hash)) {
        return;
      }
      styleMutationWarning[hash] = true;
      false
        ? warning(
            false,
            "`%s` was passed a style object that has previously been mutated. " +
              "Mutating `style` is deprecated. Consider cloning it beforehand. Check " +
              "the `render` %s. Previous style: %s. Mutated style: %s.",
            componentName,
            owner ? "of `" + ownerName + "`" : "using <" + componentName + ">",
            friendlyStringify(style1),
            friendlyStringify(style2)
          )
        : void 0;
    }
    function assertValidProps(component, props) {
      if (!props) {
        return;
      }
      if (voidElementTags[component._tag]) {
        !(props.children == null && props.dangerouslySetInnerHTML == null)
          ? false
            ? invariant(
                false,
                "%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s",
                component._tag,
                component._currentElement._owner
                  ? " Check the render method of " +
                      component._currentElement._owner.getName() +
                      "."
                  : ""
              )
            : _prodInvariant(
                "137",
                component._tag,
                component._currentElement._owner
                  ? " Check the render method of " +
                      component._currentElement._owner.getName() +
                      "."
                  : ""
              )
          : void 0;
      }
      if (props.dangerouslySetInnerHTML != null) {
        !(props.children == null)
          ? false
            ? invariant(
                false,
                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
              )
            : _prodInvariant("60")
          : void 0;
        !(
          typeof props.dangerouslySetInnerHTML === "object" &&
          HTML in props.dangerouslySetInnerHTML
        )
          ? false
            ? invariant(
                false,
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information."
              )
            : _prodInvariant("61")
          : void 0;
      }
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(
              props.innerHTML == null,
              "Directly setting property `innerHTML` is not permitted. " +
                "For more information, lookup documentation on `dangerouslySetInnerHTML`."
            )
          : void 0;
        process.env.NODE_ENV !== "production"
          ? warning(
              props.suppressContentEditableWarning ||
                !props.contentEditable ||
                props.children == null,
              "A component is `contentEditable` and contains `children` managed by " +
                "React. It is now your responsibility to guarantee that none of " +
                "those nodes are unexpectedly modified or duplicated. This is " +
                "probably not intentional."
            )
          : void 0;
        process.env.NODE_ENV !== "production"
          ? warning(
              props.onFocusIn == null && props.onFocusOut == null,
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. " +
                "All React events are normalized to bubble, so onFocusIn and onFocusOut " +
                "are not needed/supported by React."
            )
          : void 0;
      }
      !(props.style == null || typeof props.style === "object")
        ? false
          ? invariant(
              false,
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.%s",
              getDeclarationErrorAddendum(component)
            )
          : _prodInvariant("62", getDeclarationErrorAddendum(component))
        : void 0;
    }
    function enqueuePutListener(inst, registrationName, listener, transaction) {
      if (transaction instanceof ReactServerRenderingTransaction) {
        return;
      }
      if (false) {
        process.env.NODE_ENV !== "production"
          ? warning(
              registrationName !== "onScroll" ||
                isEventSupported("scroll", true),
              "This browser doesn't support the `onScroll` event"
            )
          : void 0;
      }
      var containerInfo = inst._hostContainerInfo;
      var isDocumentFragment =
        containerInfo._node &&
        containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
      var doc = isDocumentFragment
        ? containerInfo._node
        : containerInfo._ownerDocument;
      listenTo(registrationName, doc);
      transaction
        .getReactMountReady()
        .enqueue(putListener, {
          inst: inst,
          registrationName: registrationName,
          listener: listener
        });
    }
    function putListener() {
      var listenerToPut = this;
      EventPluginHub.putListener(
        listenerToPut.inst,
        listenerToPut.registrationName,
        listenerToPut.listener
      );
    }
    function inputPostMount() {
      var inst = this;
      ReactDOMInput.postMountWrapper(inst);
    }
    function textareaPostMount() {
      var inst = this;
      ReactDOMTextarea.postMountWrapper(inst);
    }
    function optionPostMount() {
      var inst = this;
      ReactDOMOption.postMountWrapper(inst);
    }
    var setAndValidateContentChildDev = emptyFunction;
    if (false) {
      setAndValidateContentChildDev = function(content) {
        var hasExistingContent = this._contentDebugID != null;
        var debugID = this._debugID;
        var contentDebugID = -debugID;
        if (content == null) {
          if (hasExistingContent) {
            ReactInstrumentation.debugTool.onUnmountComponent(
              this._contentDebugID
            );
          }
          this._contentDebugID = null;
          return;
        }
        validateDOMNesting(null, String(content), this, this._ancestorInfo);
        this._contentDebugID = contentDebugID;
        if (hasExistingContent) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(
            contentDebugID,
            content
          );
          ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
        } else {
          ReactInstrumentation.debugTool.onBeforeMountComponent(
            contentDebugID,
            content,
            debugID
          );
          ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
          ReactInstrumentation.debugTool.onSetChildren(debugID, [
            contentDebugID
          ]);
        }
      };
    }
    var mediaEvents = {
      topAbort: "abort",
      topCanPlay: "canplay",
      topCanPlayThrough: "canplaythrough",
      topDurationChange: "durationchange",
      topEmptied: "emptied",
      topEncrypted: "encrypted",
      topEnded: "ended",
      topError: "error",
      topLoadedData: "loadeddata",
      topLoadedMetadata: "loadedmetadata",
      topLoadStart: "loadstart",
      topPause: "pause",
      topPlay: "play",
      topPlaying: "playing",
      topProgress: "progress",
      topRateChange: "ratechange",
      topSeeked: "seeked",
      topSeeking: "seeking",
      topStalled: "stalled",
      topSuspend: "suspend",
      topTimeUpdate: "timeupdate",
      topVolumeChange: "volumechange",
      topWaiting: "waiting"
    };
    function trackInputValue() {
      inputValueTracking.track(this);
    }
    function trapBubbledEventsLocal() {
      var inst = this;
      !inst._rootNodeID
        ? false
          ? invariant(false, "Must be mounted to trap events")
          : _prodInvariant("63")
        : void 0;
      var node = getNode(inst);
      !node
        ? false
          ? invariant(
              false,
              "trapBubbledEvent(...): Requires node to be rendered."
            )
          : _prodInvariant("64")
        : void 0;
      switch (inst._tag) {
        case "iframe":
        case "object":
          inst._wrapperState.listeners = [
            ReactBrowserEventEmitter.trapBubbledEvent("topLoad", "load", node)
          ];
          break;
        case "video":
        case "audio":
          inst._wrapperState.listeners = [];
          for (var event in mediaEvents) {
            if (mediaEvents.hasOwnProperty(event)) {
              inst._wrapperState.listeners.push(
                ReactBrowserEventEmitter.trapBubbledEvent(
                  event,
                  mediaEvents[event],
                  node
                )
              );
            }
          }
          break;
        case "source":
          inst._wrapperState.listeners = [
            ReactBrowserEventEmitter.trapBubbledEvent("topError", "error", node)
          ];
          break;
        case "img":
          inst._wrapperState.listeners = [
            ReactBrowserEventEmitter.trapBubbledEvent(
              "topError",
              "error",
              node
            ),
            ReactBrowserEventEmitter.trapBubbledEvent("topLoad", "load", node)
          ];
          break;
        case "form":
          inst._wrapperState.listeners = [
            ReactBrowserEventEmitter.trapBubbledEvent(
              "topReset",
              "reset",
              node
            ),
            ReactBrowserEventEmitter.trapBubbledEvent(
              "topSubmit",
              "submit",
              node
            )
          ];
          break;
        case "input":
        case "select":
        case "textarea":
          inst._wrapperState.listeners = [
            ReactBrowserEventEmitter.trapBubbledEvent(
              "topInvalid",
              "invalid",
              node
            )
          ];
          break;
      }
    }
    function postUpdateSelectWrapper() {
      ReactDOMSelect.postUpdateWrapper(this);
    }
    var omittedCloseTags = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    var newlineEatingTags = { listing: true, pre: true, textarea: true };
    var voidElementTags = _assign({ menuitem: true }, omittedCloseTags);
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        !VALID_TAG_REGEX.test(tag)
          ? false
            ? invariant(false, "Invalid tag: %s", tag)
            : _prodInvariant("65", tag)
          : void 0;
        validatedTagCache[tag] = true;
      }
    }
    function isCustomComponent(tagName, props) {
      return tagName.indexOf("-") >= 0 || props.is != null;
    }
    var globalIdCounter = 1;
    function ReactDOMComponent(element) {
      var tag = element.type;
      validateDangerousTag(tag);
      this._currentElement = element;
      this._tag = tag.toLowerCase();
      this._namespaceURI = null;
      this._renderedChildren = null;
      this._previousStyle = null;
      this._previousStyleCopy = null;
      this._hostNode = null;
      this._hostParent = null;
      this._rootNodeID = 0;
      this._domID = 0;
      this._hostContainerInfo = null;
      this._wrapperState = null;
      this._topLevelWrapper = null;
      this._flags = 0;
      if (false) {
        this._ancestorInfo = null;
        setAndValidateContentChildDev.call(this, null);
      }
    }
    ReactDOMComponent.displayName = "ReactDOMComponent";
    ReactDOMComponent.Mixin = {
      mountComponent: function(
        transaction,
        hostParent,
        hostContainerInfo,
        context
      ) {
        this._rootNodeID = globalIdCounter++;
        this._domID = hostContainerInfo._idCounter++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var props = this._currentElement.props;
        switch (this._tag) {
          case "audio":
          case "form":
          case "iframe":
          case "img":
          case "link":
          case "object":
          case "source":
          case "video":
            this._wrapperState = { listeners: null };
            transaction
              .getReactMountReady()
              .enqueue(trapBubbledEventsLocal, this);
            break;
          case "input":
            ReactDOMInput.mountWrapper(this, props, hostParent);
            props = ReactDOMInput.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trackInputValue, this);
            transaction
              .getReactMountReady()
              .enqueue(trapBubbledEventsLocal, this);
            break;
          case "option":
            ReactDOMOption.mountWrapper(this, props, hostParent);
            props = ReactDOMOption.getHostProps(this, props);
            break;
          case "select":
            ReactDOMSelect.mountWrapper(this, props, hostParent);
            props = ReactDOMSelect.getHostProps(this, props);
            transaction
              .getReactMountReady()
              .enqueue(trapBubbledEventsLocal, this);
            break;
          case "textarea":
            ReactDOMTextarea.mountWrapper(this, props, hostParent);
            props = ReactDOMTextarea.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trackInputValue, this);
            transaction
              .getReactMountReady()
              .enqueue(trapBubbledEventsLocal, this);
            break;
        }
        assertValidProps(this, props);
        var namespaceURI;
        var parentTag;
        if (hostParent != null) {
          namespaceURI = hostParent._namespaceURI;
          parentTag = hostParent._tag;
        } else if (hostContainerInfo._tag) {
          namespaceURI = hostContainerInfo._namespaceURI;
          parentTag = hostContainerInfo._tag;
        }
        if (
          namespaceURI == null ||
          (namespaceURI === DOMNamespaces.svg && parentTag === "foreignobject")
        ) {
          namespaceURI = DOMNamespaces.html;
        }
        if (namespaceURI === DOMNamespaces.html) {
          if (this._tag === "svg") {
            namespaceURI = DOMNamespaces.svg;
          } else if (this._tag === "math") {
            namespaceURI = DOMNamespaces.mathml;
          }
        }
        this._namespaceURI = namespaceURI;
        if (false) {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo._tag) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(this._tag, null, this, parentInfo);
          }
          this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(
            parentInfo,
            this._tag,
            this
          );
        }
        var mountImage;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var el;
          if (namespaceURI === DOMNamespaces.html) {
            if (this._tag === "script") {
              var div = ownerDocument.createElement("div");
              var type = this._currentElement.type;
              div.innerHTML = "<" + type + "></" + type + ">";
              el = div.removeChild(div.firstChild);
            } else if (props.is) {
              el = ownerDocument.createElement(
                this._currentElement.type,
                props.is
              );
            } else {
              el = ownerDocument.createElement(this._currentElement.type);
            }
          } else {
            el = ownerDocument.createElementNS(
              namespaceURI,
              this._currentElement.type
            );
          }
          ReactDOMComponentTree.precacheNode(this, el);
          this._flags |= Flags.hasCachedChildNodes;
          if (!this._hostParent) {
            DOMPropertyOperations.setAttributeForRoot(el);
          }
          this._updateDOMProperties(null, props, transaction);
          var lazyTree = DOMLazyTree(el);
          this._createInitialChildren(transaction, props, context, lazyTree);
          mountImage = lazyTree;
        } else {
          var tagOpen = this._createOpenTagMarkupAndPutListeners(
            transaction,
            props
          );
          var tagContent = this._createContentMarkup(
            transaction,
            props,
            context
          );
          if (!tagContent && omittedCloseTags[this._tag]) {
            mountImage = tagOpen + "/>";
          } else {
            mountImage =
              tagOpen +
              ">" +
              tagContent +
              "</" +
              this._currentElement.type +
              ">";
          }
        }
        switch (this._tag) {
          case "input":
            transaction.getReactMountReady().enqueue(inputPostMount, this);
            if (props.autoFocus) {
              transaction
                .getReactMountReady()
                .enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case "textarea":
            transaction.getReactMountReady().enqueue(textareaPostMount, this);
            if (props.autoFocus) {
              transaction
                .getReactMountReady()
                .enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case "select":
            if (props.autoFocus) {
              transaction
                .getReactMountReady()
                .enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case "button":
            if (props.autoFocus) {
              transaction
                .getReactMountReady()
                .enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case "option":
            transaction.getReactMountReady().enqueue(optionPostMount, this);
            break;
        }
        return mountImage;
      },
      _createOpenTagMarkupAndPutListeners: function(transaction, props) {
        var ret = "<" + this._currentElement.type;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            if (propValue) {
              enqueuePutListener(this, propKey, propValue, transaction);
            }
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                if (false) {
                  this._previousStyle = propValue;
                }
                propValue = this._previousStyleCopy = _assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(
                propValue,
                this
              );
            }
            var markup = null;
            if (this._tag != null && isCustomComponent(this._tag, props)) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = DOMPropertyOperations.createMarkupForCustomAttribute(
                  propKey,
                  propValue
                );
              }
            } else {
              markup = DOMPropertyOperations.createMarkupForProperty(
                propKey,
                propValue
              );
            }
            if (markup) {
              ret += " " + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret;
        }
        if (!this._hostParent) {
          ret += " " + DOMPropertyOperations.createMarkupForRoot();
        }
        ret += " " + DOMPropertyOperations.createMarkupForID(this._domID);
        return ret;
      },
      _createContentMarkup: function(transaction, props, context) {
        var ret = "";
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            ret = innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children]
            ? props.children
            : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            ret = escapeTextContentForBrowser(contentToUse);
            if (false) {
              setAndValidateContentChildDev.call(this, contentToUse);
            }
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(
              childrenToUse,
              transaction,
              context
            );
            ret = mountImages.join("");
          }
        }
        if (newlineEatingTags[this._tag] && ret.charAt(0) === "\n") {
          return "\n" + ret;
        } else {
          return ret;
        }
      },
      _createInitialChildren: function(transaction, props, context, lazyTree) {
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children]
            ? props.children
            : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            if (contentToUse !== "") {
              if (false) {
                setAndValidateContentChildDev.call(this, contentToUse);
              }
              DOMLazyTree.queueText(lazyTree, contentToUse);
            }
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(
              childrenToUse,
              transaction,
              context
            );
            for (var i = 0; i < mountImages.length; i++) {
              DOMLazyTree.queueChild(lazyTree, mountImages[i]);
            }
          }
        }
      },
      receiveComponent: function(nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function(
        transaction,
        prevElement,
        nextElement,
        context
      ) {
        var lastProps = prevElement.props;
        var nextProps = this._currentElement.props;
        switch (this._tag) {
          case "input":
            lastProps = ReactDOMInput.getHostProps(this, lastProps);
            nextProps = ReactDOMInput.getHostProps(this, nextProps);
            break;
          case "option":
            lastProps = ReactDOMOption.getHostProps(this, lastProps);
            nextProps = ReactDOMOption.getHostProps(this, nextProps);
            break;
          case "select":
            lastProps = ReactDOMSelect.getHostProps(this, lastProps);
            nextProps = ReactDOMSelect.getHostProps(this, nextProps);
            break;
          case "textarea":
            lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
            nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
            break;
        }
        assertValidProps(this, nextProps);
        this._updateDOMProperties(lastProps, nextProps, transaction);
        this._updateDOMChildren(lastProps, nextProps, transaction, context);
        switch (this._tag) {
          case "input":
            ReactDOMInput.updateWrapper(this);
            inputValueTracking.updateValueIfChanged(this);
            break;
          case "textarea":
            ReactDOMTextarea.updateWrapper(this);
            break;
          case "select":
            transaction
              .getReactMountReady()
              .enqueue(postUpdateSelectWrapper, this);
            break;
        }
      },
      _updateDOMProperties: function(lastProps, nextProps, transaction) {
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (
            nextProps.hasOwnProperty(propKey) ||
            !lastProps.hasOwnProperty(propKey) ||
            lastProps[propKey] == null
          ) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = "";
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (lastProps[propKey]) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, lastProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.deleteValueForAttribute(
                getNode(this),
                propKey
              );
            }
          } else if (
            DOMProperty.properties[propKey] ||
            DOMProperty.isCustomAttribute(propKey)
          ) {
            DOMPropertyOperations.deleteValueForProperty(
              getNode(this),
              propKey
            );
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp =
            propKey === STYLE
              ? this._previousStyleCopy
              : lastProps != null
              ? lastProps[propKey]
              : undefined;
          if (
            !nextProps.hasOwnProperty(propKey) ||
            nextProp === lastProp ||
            (nextProp == null && lastProp == null)
          ) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              if (false) {
                checkAndWarnForMutatedStyle(
                  this._previousStyleCopy,
                  this._previousStyle,
                  this
                );
                this._previousStyle = nextProp;
              }
              nextProp = this._previousStyleCopy = _assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (
                  lastProp.hasOwnProperty(styleName) &&
                  (!nextProp || !nextProp.hasOwnProperty(styleName))
                ) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (
                  nextProp.hasOwnProperty(styleName) &&
                  lastProp[styleName] !== nextProp[styleName]
                ) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (nextProp) {
              enqueuePutListener(this, propKey, nextProp, transaction);
            } else if (lastProp) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, nextProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.setValueForAttribute(
                getNode(this),
                propKey,
                nextProp
              );
            }
          } else if (
            DOMProperty.properties[propKey] ||
            DOMProperty.isCustomAttribute(propKey)
          ) {
            var node = getNode(this);
            if (nextProp != null) {
              DOMPropertyOperations.setValueForProperty(
                node,
                propKey,
                nextProp
              );
            } else {
              DOMPropertyOperations.deleteValueForProperty(node, propKey);
            }
          }
        }
        if (styleUpdates) {
          CSSPropertyOperations.setValueForStyles(
            getNode(this),
            styleUpdates,
            this
          );
        }
      },
      _updateDOMChildren: function(lastProps, nextProps, transaction, context) {
        var lastContent = CONTENT_TYPES[typeof lastProps.children]
          ? lastProps.children
          : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children]
          ? nextProps.children
          : null;
        var lastHtml =
          lastProps.dangerouslySetInnerHTML &&
          lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml =
          nextProps.dangerouslySetInnerHTML &&
          nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent("");
          if (false) {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent("" + nextContent);
            if (false) {
              setAndValidateContentChildDev.call(this, nextContent);
            }
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            this.updateMarkup("" + nextHtml);
          }
          if (false) {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        } else if (nextChildren != null) {
          if (false) {
            setAndValidateContentChildDev.call(this, null);
          }
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      getHostNode: function() {
        return getNode(this);
      },
      unmountComponent: function(safely) {
        switch (this._tag) {
          case "audio":
          case "form":
          case "iframe":
          case "img":
          case "link":
          case "object":
          case "source":
          case "video":
            var listeners = this._wrapperState.listeners;
            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].remove();
              }
            }
            break;
          case "input":
          case "textarea":
            inputValueTracking.stopTracking(this);
            break;
          case "html":
          case "head":
          case "body":
            true
              ? false
                ? invariant(
                    false,
                    "<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.",
                    this._tag
                  )
                : _prodInvariant("66", this._tag)
              : void 0;
            break;
        }
        this.unmountChildren(safely);
        ReactDOMComponentTree.uncacheNode(this);
        EventPluginHub.deleteAllListeners(this);
        this._rootNodeID = 0;
        this._domID = 0;
        this._wrapperState = null;
        if (false) {
          setAndValidateContentChildDev.call(this, null);
        }
      },
      getPublicInstance: function() {
        return getNode(this);
      }
    };
    _assign(
      ReactDOMComponent.prototype,
      ReactDOMComponent.Mixin,
      ReactMultiChild.Mixin
    );
    module.exports = ReactDOMComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var validateDOMNesting = __webpack_require__(55);
    var DOC_NODE_TYPE = 9;
    function ReactDOMContainerInfo(topLevelWrapper, node) {
      var info = {
        _topLevelWrapper: topLevelWrapper,
        _idCounter: 1,
        _ownerDocument: node
          ? node.nodeType === DOC_NODE_TYPE
            ? node
            : node.ownerDocument
          : null,
        _node: node,
        _tag: node ? node.nodeName.toLowerCase() : null,
        _namespaceURI: node ? node.namespaceURI : null
      };
      if (false) {
        info._ancestorInfo = node
          ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null)
          : null;
      }
      return info;
    }
    module.exports = ReactDOMContainerInfo;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var DOMLazyTree = __webpack_require__(18);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMEmptyComponent = function(instantiate) {
      this._currentElement = null;
      this._hostNode = null;
      this._hostParent = null;
      this._hostContainerInfo = null;
      this._domID = 0;
    };
    _assign(ReactDOMEmptyComponent.prototype, {
      mountComponent: function(
        transaction,
        hostParent,
        hostContainerInfo,
        context
      ) {
        var domID = hostContainerInfo._idCounter++;
        this._domID = domID;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var nodeValue = " react-empty: " + this._domID + " ";
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var node = ownerDocument.createComment(nodeValue);
          ReactDOMComponentTree.precacheNode(this, node);
          return DOMLazyTree(node);
        } else {
          if (transaction.renderToStaticMarkup) {
            return "";
          }
          return "<!--" + nodeValue + "-->";
        }
      },
      receiveComponent: function() {},
      getHostNode: function() {
        return ReactDOMComponentTree.getNodeFromInstance(this);
      },
      unmountComponent: function() {
        ReactDOMComponentTree.uncacheNode(this);
      }
    });
    module.exports = ReactDOMEmptyComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactDOMFeatureFlags = { useCreateElement: true, useFiber: false };
    module.exports = ReactDOMFeatureFlags;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMChildrenOperations = __webpack_require__(40);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMIDOperations = {
      dangerouslyProcessChildrenUpdates: function(parentInst, updates) {
        var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
        DOMChildrenOperations.processUpdates(node, updates);
      }
    };
    module.exports = ReactDOMIDOperations;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var DOMPropertyOperations = __webpack_require__(77);
    var LinkedValueUtils = __webpack_require__(45);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactUpdates = __webpack_require__(11);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    var didWarnValueLink = false;
    var didWarnCheckedLink = false;
    var didWarnValueDefaultValue = false;
    var didWarnCheckedDefaultChecked = false;
    var didWarnControlledToUncontrolled = false;
    var didWarnUncontrolledToControlled = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMInput.updateWrapper(this);
      }
    }
    function isControlled(props) {
      var usesChecked = props.type === "checkbox" || props.type === "radio";
      return usesChecked ? props.checked != null : props.value != null;
    }
    var ReactDOMInput = {
      getHostProps: function(inst, props) {
        var value = LinkedValueUtils.getValue(props);
        var checked = LinkedValueUtils.getChecked(props);
        var hostProps = _assign(
          { type: undefined, step: undefined, min: undefined, max: undefined },
          props,
          {
            defaultChecked: undefined,
            defaultValue: undefined,
            value: value != null ? value : inst._wrapperState.initialValue,
            checked:
              checked != null ? checked : inst._wrapperState.initialChecked,
            onChange: inst._wrapperState.onChange
          }
        );
        return hostProps;
      },
      mountWrapper: function(inst, props) {
        if (false) {
          LinkedValueUtils.checkPropTypes(
            "input",
            props,
            inst._currentElement._owner
          );
          var owner = inst._currentElement._owner;
          if (props.valueLink !== undefined && !didWarnValueLink) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead."
                )
              : void 0;
            didWarnValueLink = true;
          }
          if (props.checkedLink !== undefined && !didWarnCheckedLink) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead."
                )
              : void 0;
            didWarnCheckedLink = true;
          }
          if (
            props.checked !== undefined &&
            props.defaultChecked !== undefined &&
            !didWarnCheckedDefaultChecked
          ) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "%s contains an input of type %s with both checked and defaultChecked props. " +
                    "Input elements must be either controlled or uncontrolled " +
                    "(specify either the checked prop, or the defaultChecked prop, but not " +
                    "both). Decide between using a controlled or uncontrolled input " +
                    "element and remove one of these props. More info: " +
                    "https://fb.me/react-controlled-components",
                  (owner && owner.getName()) || "A component",
                  props.type
                )
              : void 0;
            didWarnCheckedDefaultChecked = true;
          }
          if (
            props.value !== undefined &&
            props.defaultValue !== undefined &&
            !didWarnValueDefaultValue
          ) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "%s contains an input of type %s with both value and defaultValue props. " +
                    "Input elements must be either controlled or uncontrolled " +
                    "(specify either the value prop, or the defaultValue prop, but not " +
                    "both). Decide between using a controlled or uncontrolled input " +
                    "element and remove one of these props. More info: " +
                    "https://fb.me/react-controlled-components",
                  (owner && owner.getName()) || "A component",
                  props.type
                )
              : void 0;
            didWarnValueDefaultValue = true;
          }
        }
        var defaultValue = props.defaultValue;
        inst._wrapperState = {
          initialChecked:
            props.checked != null ? props.checked : props.defaultChecked,
          initialValue: props.value != null ? props.value : defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst),
          controlled: isControlled(props)
        };
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        if (false) {
          var controlled = isControlled(props);
          var owner = inst._currentElement._owner;
          if (
            !inst._wrapperState.controlled &&
            controlled &&
            !didWarnUncontrolledToControlled
          ) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "%s is changing an uncontrolled input of type %s to be controlled. " +
                    "Input elements should not switch from uncontrolled to controlled (or vice versa). " +
                    "Decide between using a controlled or uncontrolled input " +
                    "element for the lifetime of the component. More info: https://fb.me/react-controlled-components",
                  (owner && owner.getName()) || "A component",
                  props.type
                )
              : void 0;
            didWarnUncontrolledToControlled = true;
          }
          if (
            inst._wrapperState.controlled &&
            !controlled &&
            !didWarnControlledToUncontrolled
          ) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "%s is changing a controlled input of type %s to be uncontrolled. " +
                    "Input elements should not switch from controlled to uncontrolled (or vice versa). " +
                    "Decide between using a controlled or uncontrolled input " +
                    "element for the lifetime of the component. More info: https://fb.me/react-controlled-components",
                  (owner && owner.getName()) || "A component",
                  props.type
                )
              : void 0;
            didWarnControlledToUncontrolled = true;
          }
        }
        var checked = props.checked;
        if (checked != null) {
          DOMPropertyOperations.setValueForProperty(
            ReactDOMComponentTree.getNodeFromInstance(inst),
            "checked",
            checked || false
          );
        }
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          if (value === 0 && node.value === "") {
            node.value = "0";
          } else if (props.type === "number") {
            var valueAsNumber = parseFloat(node.value, 10) || 0;
            if (
              value != valueAsNumber ||
              (value == valueAsNumber && node.value != value)
            ) {
              node.value = "" + value;
            }
          } else if (node.value !== "" + value) {
            node.value = "" + value;
          }
        } else {
          if (props.value == null && props.defaultValue != null) {
            if (node.defaultValue !== "" + props.defaultValue) {
              node.defaultValue = "" + props.defaultValue;
            }
          }
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      },
      postMountWrapper: function(inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        switch (props.type) {
          case "submit":
          case "reset":
            break;
          case "color":
          case "date":
          case "datetime":
          case "datetime-local":
          case "month":
          case "time":
          case "week":
            node.value = "";
            node.value = node.defaultValue;
            break;
          default:
            node.value = node.value;
            break;
        }
        var name = node.name;
        if (name !== "") {
          node.name = "";
        }
        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !node.defaultChecked;
        if (name !== "") {
          node.name = name;
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      var name = props.name;
      if (props.type === "radio" && name != null) {
        var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
        var queryRoot = rootNode;
        while (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        }
        var group = queryRoot.querySelectorAll(
          "input[name=" + JSON.stringify("" + name) + '][type="radio"]'
        );
        for (var i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (otherNode === rootNode || otherNode.form !== rootNode.form) {
            continue;
          }
          var otherInstance = ReactDOMComponentTree.getInstanceFromNode(
            otherNode
          );
          !otherInstance
            ? false
              ? invariant(
                  false,
                  "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                )
              : _prodInvariant("90")
            : void 0;
          ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
        }
      }
      return returnValue;
    }
    module.exports = ReactDOMInput;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var React = __webpack_require__(21);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMSelect = __webpack_require__(79);
    var warning = __webpack_require__(4);
    var didWarnInvalidOptionChildren = false;
    function flattenChildren(children) {
      var content = "";
      React.Children.forEach(children, function(child) {
        if (child == null) {
          return;
        }
        if (typeof child === "string" || typeof child === "number") {
          content += child;
        } else if (!didWarnInvalidOptionChildren) {
          didWarnInvalidOptionChildren = true;
          false
            ? warning(
                false,
                "Only strings and numbers are supported as <option> children."
              )
            : void 0;
        }
      });
      return content;
    }
    var ReactDOMOption = {
      mountWrapper: function(inst, props, hostParent) {
        if (false) {
          process.env.NODE_ENV !== "production"
            ? warning(
                props.selected == null,
                "Use the `defaultValue` or `value` props on <select> instead of " +
                  "setting `selected` on <option>."
              )
            : void 0;
        }
        var selectValue = null;
        if (hostParent != null) {
          var selectParent = hostParent;
          if (selectParent._tag === "optgroup") {
            selectParent = selectParent._hostParent;
          }
          if (selectParent != null && selectParent._tag === "select") {
            selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
          }
        }
        var selected = null;
        if (selectValue != null) {
          var value;
          if (props.value != null) {
            value = props.value + "";
          } else {
            value = flattenChildren(props.children);
          }
          selected = false;
          if (Array.isArray(selectValue)) {
            for (var i = 0; i < selectValue.length; i++) {
              if ("" + selectValue[i] === value) {
                selected = true;
                break;
              }
            }
          } else {
            selected = "" + selectValue === value;
          }
        }
        inst._wrapperState = { selected: selected };
      },
      postMountWrapper: function(inst) {
        var props = inst._currentElement.props;
        if (props.value != null) {
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          node.setAttribute("value", props.value);
        }
      },
      getHostProps: function(inst, props) {
        var hostProps = _assign(
          { selected: undefined, children: undefined },
          props
        );
        if (inst._wrapperState.selected != null) {
          hostProps.selected = inst._wrapperState.selected;
        }
        var content = flattenChildren(props.children);
        if (content) {
          hostProps.children = content;
        }
        return hostProps;
      }
    };
    module.exports = ReactDOMOption;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    var getNodeForCharacterOffset = __webpack_require__(229);
    var getTextContentAccessor = __webpack_require__(90);
    function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
      return anchorNode === focusNode && anchorOffset === focusOffset;
    }
    function getIEOffsets(node) {
      var selection = document.selection;
      var selectedRange = selection.createRange();
      var selectedLength = selectedRange.text.length;
      var fromStart = selectedRange.duplicate();
      fromStart.moveToElementText(node);
      fromStart.setEndPoint("EndToStart", selectedRange);
      var startOffset = fromStart.text.length;
      var endOffset = startOffset + selectedLength;
      return { start: startOffset, end: endOffset };
    }
    function getModernOffsets(node) {
      var selection = window.getSelection && window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return null;
      }
      var anchorNode = selection.anchorNode;
      var anchorOffset = selection.anchorOffset;
      var focusNode = selection.focusNode;
      var focusOffset = selection.focusOffset;
      var currentRange = selection.getRangeAt(0);
      try {
        currentRange.startContainer.nodeType;
        currentRange.endContainer.nodeType;
      } catch (e) {
        return null;
      }
      var isSelectionCollapsed = isCollapsed(
        selection.anchorNode,
        selection.anchorOffset,
        selection.focusNode,
        selection.focusOffset
      );
      var rangeLength = isSelectionCollapsed
        ? 0
        : currentRange.toString().length;
      var tempRange = currentRange.cloneRange();
      tempRange.selectNodeContents(node);
      tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
      var isTempRangeCollapsed = isCollapsed(
        tempRange.startContainer,
        tempRange.startOffset,
        tempRange.endContainer,
        tempRange.endOffset
      );
      var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
      var end = start + rangeLength;
      var detectionRange = document.createRange();
      detectionRange.setStart(anchorNode, anchorOffset);
      detectionRange.setEnd(focusNode, focusOffset);
      var isBackward = detectionRange.collapsed;
      return { start: isBackward ? end : start, end: isBackward ? start : end };
    }
    function setIEOffsets(node, offsets) {
      var range = document.selection.createRange().duplicate();
      var start, end;
      if (offsets.end === undefined) {
        start = offsets.start;
        end = start;
      } else if (offsets.start > offsets.end) {
        start = offsets.end;
        end = offsets.start;
      } else {
        start = offsets.start;
        end = offsets.end;
      }
      range.moveToElementText(node);
      range.moveStart("character", start);
      range.setEndPoint("EndToStart", range);
      range.moveEnd("character", end - start);
      range.select();
    }
    function setModernOffsets(node, offsets) {
      if (!window.getSelection) {
        return;
      }
      var selection = window.getSelection();
      var length = node[getTextContentAccessor()].length;
      var start = Math.min(offsets.start, length);
      var end =
        offsets.end === undefined ? start : Math.min(offsets.end, length);
      if (!selection.extend && start > end) {
        var temp = end;
        end = start;
        start = temp;
      }
      var startMarker = getNodeForCharacterOffset(node, start);
      var endMarker = getNodeForCharacterOffset(node, end);
      if (startMarker && endMarker) {
        var range = document.createRange();
        range.setStart(startMarker.node, startMarker.offset);
        selection.removeAllRanges();
        if (start > end) {
          selection.addRange(range);
          selection.extend(endMarker.node, endMarker.offset);
        } else {
          range.setEnd(endMarker.node, endMarker.offset);
          selection.addRange(range);
        }
      }
    }
    var useIEOffsets =
      ExecutionEnvironment.canUseDOM &&
      "selection" in document &&
      !("getSelection" in window);
    var ReactDOMSelection = {
      getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
      setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
    };
    module.exports = ReactDOMSelection;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var DOMChildrenOperations = __webpack_require__(40);
    var DOMLazyTree = __webpack_require__(18);
    var ReactDOMComponentTree = __webpack_require__(7);
    var escapeTextContentForBrowser = __webpack_require__(35);
    var invariant = __webpack_require__(0);
    var validateDOMNesting = __webpack_require__(55);
    var ReactDOMTextComponent = function(text) {
      this._currentElement = text;
      this._stringText = "" + text;
      this._hostNode = null;
      this._hostParent = null;
      this._domID = 0;
      this._mountIndex = 0;
      this._closingComment = null;
      this._commentNodes = null;
    };
    _assign(ReactDOMTextComponent.prototype, {
      mountComponent: function(
        transaction,
        hostParent,
        hostContainerInfo,
        context
      ) {
        if (false) {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo != null) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(null, this._stringText, this, parentInfo);
          }
        }
        var domID = hostContainerInfo._idCounter++;
        var openingValue = " react-text: " + domID + " ";
        var closingValue = " /react-text ";
        this._domID = domID;
        this._hostParent = hostParent;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var openingComment = ownerDocument.createComment(openingValue);
          var closingComment = ownerDocument.createComment(closingValue);
          var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
          if (this._stringText) {
            DOMLazyTree.queueChild(
              lazyTree,
              DOMLazyTree(ownerDocument.createTextNode(this._stringText))
            );
          }
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
          ReactDOMComponentTree.precacheNode(this, openingComment);
          this._closingComment = closingComment;
          return lazyTree;
        } else {
          var escapedText = escapeTextContentForBrowser(this._stringText);
          if (transaction.renderToStaticMarkup) {
            return escapedText;
          }
          return (
            "<!--" +
            openingValue +
            "-->" +
            escapedText +
            "<!--" +
            closingValue +
            "-->"
          );
        }
      },
      receiveComponent: function(nextText, transaction) {
        if (nextText !== this._currentElement) {
          this._currentElement = nextText;
          var nextStringText = "" + nextText;
          if (nextStringText !== this._stringText) {
            this._stringText = nextStringText;
            var commentNodes = this.getHostNode();
            DOMChildrenOperations.replaceDelimitedText(
              commentNodes[0],
              commentNodes[1],
              nextStringText
            );
          }
        }
      },
      getHostNode: function() {
        var hostNode = this._commentNodes;
        if (hostNode) {
          return hostNode;
        }
        if (!this._closingComment) {
          var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
          var node = openingComment.nextSibling;
          while (true) {
            !(node != null)
              ? false
                ? invariant(
                    false,
                    "Missing closing comment for text component %s",
                    this._domID
                  )
                : _prodInvariant("67", this._domID)
              : void 0;
            if (node.nodeType === 8 && node.nodeValue === " /react-text ") {
              this._closingComment = node;
              break;
            }
            node = node.nextSibling;
          }
        }
        hostNode = [this._hostNode, this._closingComment];
        this._commentNodes = hostNode;
        return hostNode;
      },
      unmountComponent: function() {
        this._closingComment = null;
        this._commentNodes = null;
        ReactDOMComponentTree.uncacheNode(this);
      }
    });
    module.exports = ReactDOMTextComponent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3),
      _assign = __webpack_require__(6);
    var LinkedValueUtils = __webpack_require__(45);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactUpdates = __webpack_require__(11);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    var didWarnValueLink = false;
    var didWarnValDefaultVal = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMTextarea.updateWrapper(this);
      }
    }
    var ReactDOMTextarea = {
      getHostProps: function(inst, props) {
        !(props.dangerouslySetInnerHTML == null)
          ? false
            ? invariant(
                false,
                "`dangerouslySetInnerHTML` does not make sense on <textarea>."
              )
            : _prodInvariant("91")
          : void 0;
        var hostProps = _assign({}, props, {
          value: undefined,
          defaultValue: undefined,
          children: "" + inst._wrapperState.initialValue,
          onChange: inst._wrapperState.onChange
        });
        return hostProps;
      },
      mountWrapper: function(inst, props) {
        if (false) {
          LinkedValueUtils.checkPropTypes(
            "textarea",
            props,
            inst._currentElement._owner
          );
          if (props.valueLink !== undefined && !didWarnValueLink) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead."
                )
              : void 0;
            didWarnValueLink = true;
          }
          if (
            props.value !== undefined &&
            props.defaultValue !== undefined &&
            !didWarnValDefaultVal
          ) {
            process.env.NODE_ENV !== "production"
              ? warning(
                  false,
                  "Textarea elements must be either controlled or uncontrolled " +
                    "(specify either the value prop, or the defaultValue prop, but not " +
                    "both). Decide between using a controlled or uncontrolled textarea " +
                    "and remove one of these props. More info: " +
                    "https://fb.me/react-controlled-components"
                )
              : void 0;
            didWarnValDefaultVal = true;
          }
        }
        var value = LinkedValueUtils.getValue(props);
        var initialValue = value;
        if (value == null) {
          var defaultValue = props.defaultValue;
          var children = props.children;
          if (children != null) {
            if (false) {
              process.env.NODE_ENV !== "production"
                ? warning(
                    false,
                    "Use the `defaultValue` or `value` props instead of setting " +
                      "children on <textarea>."
                  )
                : void 0;
            }
            !(defaultValue == null)
              ? false
                ? invariant(
                    false,
                    "If you supply `defaultValue` on a <textarea>, do not pass children."
                  )
                : _prodInvariant("92")
              : void 0;
            if (Array.isArray(children)) {
              !(children.length <= 1)
                ? false
                  ? invariant(
                      false,
                      "<textarea> can only have at most one child."
                    )
                  : _prodInvariant("93")
                : void 0;
              children = children[0];
            }
            defaultValue = "" + children;
          }
          if (defaultValue == null) {
            defaultValue = "";
          }
          initialValue = defaultValue;
        }
        inst._wrapperState = {
          initialValue: "" + initialValue,
          listeners: null,
          onChange: _handleChange.bind(inst)
        };
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          var newValue = "" + value;
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null) {
            node.defaultValue = newValue;
          }
        }
        if (props.defaultValue != null) {
          node.defaultValue = props.defaultValue;
        }
      },
      postMountWrapper: function(inst) {
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var textContent = node.textContent;
        if (textContent === inst._wrapperState.initialValue) {
          node.value = textContent;
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMTextarea;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    function getLowestCommonAncestor(instA, instB) {
      !("_hostNode" in instA)
        ? false
          ? invariant(false, "getNodeFromInstance: Invalid argument.")
          : _prodInvariant("33")
        : void 0;
      !("_hostNode" in instB)
        ? false
          ? invariant(false, "getNodeFromInstance: Invalid argument.")
          : _prodInvariant("33")
        : void 0;
      var depthA = 0;
      for (var tempA = instA; tempA; tempA = tempA._hostParent) {
        depthA++;
      }
      var depthB = 0;
      for (var tempB = instB; tempB; tempB = tempB._hostParent) {
        depthB++;
      }
      while (depthA - depthB > 0) {
        instA = instA._hostParent;
        depthA--;
      }
      while (depthB - depthA > 0) {
        instB = instB._hostParent;
        depthB--;
      }
      var depth = depthA;
      while (depth--) {
        if (instA === instB) {
          return instA;
        }
        instA = instA._hostParent;
        instB = instB._hostParent;
      }
      return null;
    }
    function isAncestor(instA, instB) {
      !("_hostNode" in instA)
        ? false
          ? invariant(false, "isAncestor: Invalid argument.")
          : _prodInvariant("35")
        : void 0;
      !("_hostNode" in instB)
        ? false
          ? invariant(false, "isAncestor: Invalid argument.")
          : _prodInvariant("35")
        : void 0;
      while (instB) {
        if (instB === instA) {
          return true;
        }
        instB = instB._hostParent;
      }
      return false;
    }
    function getParentInstance(inst) {
      !("_hostNode" in inst)
        ? false
          ? invariant(false, "getParentInstance: Invalid argument.")
          : _prodInvariant("36")
        : void 0;
      return inst._hostParent;
    }
    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = inst._hostParent;
      }
      var i;
      for (i = path.length; i-- > 0; ) {
        fn(path[i], "captured", arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], "bubbled", arg);
      }
    }
    function traverseEnterLeave(from, to, fn, argFrom, argTo) {
      var common = from && to ? getLowestCommonAncestor(from, to) : null;
      var pathFrom = [];
      while (from && from !== common) {
        pathFrom.push(from);
        from = from._hostParent;
      }
      var pathTo = [];
      while (to && to !== common) {
        pathTo.push(to);
        to = to._hostParent;
      }
      var i;
      for (i = 0; i < pathFrom.length; i++) {
        fn(pathFrom[i], "bubbled", argFrom);
      }
      for (i = pathTo.length; i-- > 0; ) {
        fn(pathTo[i], "captured", argTo);
      }
    }
    module.exports = {
      isAncestor: isAncestor,
      getLowestCommonAncestor: getLowestCommonAncestor,
      getParentInstance: getParentInstance,
      traverseTwoPhase: traverseTwoPhase,
      traverseEnterLeave: traverseEnterLeave
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var ReactUpdates = __webpack_require__(11);
    var Transaction = __webpack_require__(34);
    var emptyFunction = __webpack_require__(10);
    var RESET_BATCHED_UPDATES = {
      initialize: emptyFunction,
      close: function() {
        ReactDefaultBatchingStrategy.isBatchingUpdates = false;
      }
    };
    var FLUSH_BATCHED_UPDATES = {
      initialize: emptyFunction,
      close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
    };
    var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
    function ReactDefaultBatchingStrategyTransaction() {
      this.reinitializeTransaction();
    }
    _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      }
    });
    var transaction = new ReactDefaultBatchingStrategyTransaction();
    var ReactDefaultBatchingStrategy = {
      isBatchingUpdates: false,
      batchedUpdates: function(callback, a, b, c, d, e) {
        var alreadyBatchingUpdates =
          ReactDefaultBatchingStrategy.isBatchingUpdates;
        ReactDefaultBatchingStrategy.isBatchingUpdates = true;
        if (alreadyBatchingUpdates) {
          return callback(a, b, c, d, e);
        } else {
          return transaction.perform(callback, null, a, b, c, d, e);
        }
      }
    };
    module.exports = ReactDefaultBatchingStrategy;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ARIADOMPropertyConfig = __webpack_require__(170);
    var BeforeInputEventPlugin = __webpack_require__(172);
    var ChangeEventPlugin = __webpack_require__(174);
    var DefaultEventPluginOrder = __webpack_require__(176);
    var EnterLeaveEventPlugin = __webpack_require__(177);
    var HTMLDOMPropertyConfig = __webpack_require__(179);
    var ReactComponentBrowserEnvironment = __webpack_require__(181);
    var ReactDOMComponent = __webpack_require__(184);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactDOMEmptyComponent = __webpack_require__(186);
    var ReactDOMTreeTraversal = __webpack_require__(194);
    var ReactDOMTextComponent = __webpack_require__(192);
    var ReactDefaultBatchingStrategy = __webpack_require__(195);
    var ReactEventListener = __webpack_require__(199);
    var ReactInjection = __webpack_require__(200);
    var ReactReconcileTransaction = __webpack_require__(205);
    var SVGDOMPropertyConfig = __webpack_require__(210);
    var SelectEventPlugin = __webpack_require__(211);
    var SimpleEventPlugin = __webpack_require__(212);
    var alreadyInjected = false;
    function inject() {
      if (alreadyInjected) {
        return;
      }
      alreadyInjected = true;
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(
        DefaultEventPluginOrder
      );
      ReactInjection.EventPluginUtils.injectComponentTree(
        ReactDOMComponentTree
      );
      ReactInjection.EventPluginUtils.injectTreeTraversal(
        ReactDOMTreeTraversal
      );
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.HostComponent.injectGenericComponentClass(
        ReactDOMComponent
      );
      ReactInjection.HostComponent.injectTextComponentClass(
        ReactDOMTextComponent
      );
      ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponentFactory(function(
        instantiate
      ) {
        return new ReactDOMEmptyComponent(instantiate);
      });
      ReactInjection.Updates.injectReconcileTransaction(
        ReactReconcileTransaction
      );
      ReactInjection.Updates.injectBatchingStrategy(
        ReactDefaultBatchingStrategy
      );
      ReactInjection.Component.injectEnvironment(
        ReactComponentBrowserEnvironment
      );
    }
    module.exports = { inject: inject };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var REACT_ELEMENT_TYPE =
      (typeof Symbol === "function" &&
        Symbol["for"] &&
        Symbol["for"]("react.element")) ||
      0xeac7;
    module.exports = REACT_ELEMENT_TYPE;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPluginHub = __webpack_require__(25);
    function runEventQueueInBatch(events) {
      EventPluginHub.enqueueEvents(events);
      EventPluginHub.processEventQueue(false);
    }
    var ReactEventEmitterMixin = {
      handleTopLevel: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var events = EventPluginHub.extractEvents(
          topLevelType,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
        runEventQueueInBatch(events);
      }
    };
    module.exports = ReactEventEmitterMixin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var EventListener = __webpack_require__(70);
    var ExecutionEnvironment = __webpack_require__(8);
    var PooledClass = __webpack_require__(17);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactUpdates = __webpack_require__(11);
    var getEventTarget = __webpack_require__(52);
    var getUnboundedScrollPosition = __webpack_require__(156);
    function findParent(inst) {
      while (inst._hostParent) {
        inst = inst._hostParent;
      }
      var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
      var container = rootNode.parentNode;
      return ReactDOMComponentTree.getClosestInstanceFromNode(container);
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    _assign(TopLevelCallbackBookKeeping.prototype, {
      destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }
    });
    PooledClass.addPoolingTo(
      TopLevelCallbackBookKeeping,
      PooledClass.twoArgumentPooler
    );
    function handleTopLevelImpl(bookKeeping) {
      var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
      var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(
        nativeEventTarget
      );
      var ancestor = targetInst;
      do {
        bookKeeping.ancestors.push(ancestor);
        ancestor = ancestor && findParent(ancestor);
      } while (ancestor);
      for (var i = 0; i < bookKeeping.ancestors.length; i++) {
        targetInst = bookKeeping.ancestors[i];
        ReactEventListener._handleTopLevel(
          bookKeeping.topLevelType,
          targetInst,
          bookKeeping.nativeEvent,
          getEventTarget(bookKeeping.nativeEvent)
        );
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.listen(
          element,
          handlerBaseName,
          ReactEventListener.dispatchEvent.bind(null, topLevelType)
        );
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.capture(
          element,
          handlerBaseName,
          ReactEventListener.dispatchEvent.bind(null, topLevelType)
        );
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, "scroll", callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
          topLevelType,
          nativeEvent
        );
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var DOMProperty = __webpack_require__(19);
    var EventPluginHub = __webpack_require__(25);
    var EventPluginUtils = __webpack_require__(43);
    var ReactComponentEnvironment = __webpack_require__(46);
    var ReactEmptyComponent = __webpack_require__(80);
    var ReactBrowserEventEmitter = __webpack_require__(32);
    var ReactHostComponent = __webpack_require__(82);
    var ReactUpdates = __webpack_require__(11);
    var ReactInjection = {
      Component: ReactComponentEnvironment.injection,
      DOMProperty: DOMProperty.injection,
      EmptyComponent: ReactEmptyComponent.injection,
      EventPluginHub: EventPluginHub.injection,
      EventPluginUtils: EventPluginUtils.injection,
      EventEmitter: ReactBrowserEventEmitter.injection,
      HostComponent: ReactHostComponent.injection,
      Updates: ReactUpdates.injection
    };
    module.exports = ReactInjection;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var adler32 = __webpack_require__(223);
    var TAG_END = /\/?>/;
    var COMMENT_START = /^<\!\-\-/;
    var ReactMarkupChecksum = {
      CHECKSUM_ATTR_NAME: "data-react-checksum",
      addChecksumToMarkup: function(markup) {
        var checksum = adler32(markup);
        if (COMMENT_START.test(markup)) {
          return markup;
        } else {
          return markup.replace(
            TAG_END,
            " " +
              ReactMarkupChecksum.CHECKSUM_ATTR_NAME +
              '="' +
              checksum +
              '"$&'
          );
        }
      },
      canReuseMarkup: function(markup, element) {
        var existingChecksum = element.getAttribute(
          ReactMarkupChecksum.CHECKSUM_ATTR_NAME
        );
        existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
        var markupChecksum = adler32(markup);
        return markupChecksum === existingChecksum;
      }
    };
    module.exports = ReactMarkupChecksum;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactComponentEnvironment = __webpack_require__(46);
    var ReactInstanceMap = __webpack_require__(27);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactCurrentOwner = __webpack_require__(13);
    var ReactReconciler = __webpack_require__(20);
    var ReactChildReconciler = __webpack_require__(180);
    var emptyFunction = __webpack_require__(10);
    var flattenChildren = __webpack_require__(226);
    var invariant = __webpack_require__(0);
    function makeInsertMarkup(markup, afterNode, toIndex) {
      return {
        type: "INSERT_MARKUP",
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeMove(child, afterNode, toIndex) {
      return {
        type: "MOVE_EXISTING",
        content: null,
        fromIndex: child._mountIndex,
        fromNode: ReactReconciler.getHostNode(child),
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeRemove(child, node) {
      return {
        type: "REMOVE_NODE",
        content: null,
        fromIndex: child._mountIndex,
        fromNode: node,
        toIndex: null,
        afterNode: null
      };
    }
    function makeSetMarkup(markup) {
      return {
        type: "SET_MARKUP",
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function makeTextContent(textContent) {
      return {
        type: "TEXT_CONTENT",
        content: textContent,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function enqueue(queue, update) {
      if (update) {
        queue = queue || [];
        queue.push(update);
      }
      return queue;
    }
    function processQueue(inst, updateQueue) {
      ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
    }
    var setChildrenForInstrumentation = emptyFunction;
    if (false) {
      var getDebugID = function(inst) {
        if (!inst._debugID) {
          var internal;
          if ((internal = ReactInstanceMap.get(inst))) {
            inst = internal;
          }
        }
        return inst._debugID;
      };
      setChildrenForInstrumentation = function(children) {
        var debugID = getDebugID(this);
        if (debugID !== 0) {
          ReactInstrumentation.debugTool.onSetChildren(
            debugID,
            children
              ? Object.keys(children).map(function(key) {
                  return children[key]._debugID;
                })
              : []
          );
        }
      };
    }
    var ReactMultiChild = {
      Mixin: {
        _reconcilerInstantiateChildren: function(
          nestedChildren,
          transaction,
          context
        ) {
          if (false) {
            var selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                return ReactChildReconciler.instantiateChildren(
                  nestedChildren,
                  transaction,
                  context,
                  selfDebugID
                );
              } finally {
                ReactCurrentOwner.current = null;
              }
            }
          }
          return ReactChildReconciler.instantiateChildren(
            nestedChildren,
            transaction,
            context
          );
        },
        _reconcilerUpdateChildren: function(
          prevChildren,
          nextNestedChildrenElements,
          mountImages,
          removedNodes,
          transaction,
          context
        ) {
          var nextChildren;
          var selfDebugID = 0;
          if (false) {
            selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                nextChildren = flattenChildren(
                  nextNestedChildrenElements,
                  selfDebugID
                );
              } finally {
                ReactCurrentOwner.current = null;
              }
              ReactChildReconciler.updateChildren(
                prevChildren,
                nextChildren,
                mountImages,
                removedNodes,
                transaction,
                this,
                this._hostContainerInfo,
                context,
                selfDebugID
              );
              return nextChildren;
            }
          }
          nextChildren = flattenChildren(
            nextNestedChildrenElements,
            selfDebugID
          );
          ReactChildReconciler.updateChildren(
            prevChildren,
            nextChildren,
            mountImages,
            removedNodes,
            transaction,
            this,
            this._hostContainerInfo,
            context,
            selfDebugID
          );
          return nextChildren;
        },
        mountChildren: function(nestedChildren, transaction, context) {
          var children = this._reconcilerInstantiateChildren(
            nestedChildren,
            transaction,
            context
          );
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var selfDebugID = 0;
              if (false) {
                selfDebugID = getDebugID(this);
              }
              var mountImage = ReactReconciler.mountComponent(
                child,
                transaction,
                this,
                this._hostContainerInfo,
                context,
                selfDebugID
              );
              child._mountIndex = index++;
              mountImages.push(mountImage);
            }
          }
          if (false) {
            setChildrenForInstrumentation.call(this, children);
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              true
                ? false
                  ? invariant(
                      false,
                      "updateTextContent called on non-empty component."
                    )
                  : _prodInvariant("118")
                : void 0;
            }
          }
          var updates = [makeTextContent(nextContent)];
          processQueue(this, updates);
        },
        updateMarkup: function(nextMarkup) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              true
                ? false
                  ? invariant(
                      false,
                      "updateTextContent called on non-empty component."
                    )
                  : _prodInvariant("118")
                : void 0;
            }
          }
          var updates = [makeSetMarkup(nextMarkup)];
          processQueue(this, updates);
        },
        updateChildren: function(
          nextNestedChildrenElements,
          transaction,
          context
        ) {
          this._updateChildren(
            nextNestedChildrenElements,
            transaction,
            context
          );
        },
        _updateChildren: function(
          nextNestedChildrenElements,
          transaction,
          context
        ) {
          var prevChildren = this._renderedChildren;
          var removedNodes = {};
          var mountImages = [];
          var nextChildren = this._reconcilerUpdateChildren(
            prevChildren,
            nextNestedChildrenElements,
            mountImages,
            removedNodes,
            transaction,
            context
          );
          if (!nextChildren && !prevChildren) {
            return;
          }
          var updates = null;
          var name;
          var nextIndex = 0;
          var lastIndex = 0;
          var nextMountIndex = 0;
          var lastPlacedNode = null;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              updates = enqueue(
                updates,
                this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex)
              );
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              }
              updates = enqueue(
                updates,
                this._mountChildAtIndex(
                  nextChild,
                  mountImages[nextMountIndex],
                  lastPlacedNode,
                  nextIndex,
                  transaction,
                  context
                )
              );
              nextMountIndex++;
            }
            nextIndex++;
            lastPlacedNode = ReactReconciler.getHostNode(nextChild);
          }
          for (name in removedNodes) {
            if (removedNodes.hasOwnProperty(name)) {
              updates = enqueue(
                updates,
                this._unmountChild(prevChildren[name], removedNodes[name])
              );
            }
          }
          if (updates) {
            processQueue(this, updates);
          }
          this._renderedChildren = nextChildren;
          if (false) {
            setChildrenForInstrumentation.call(this, nextChildren);
          }
        },
        unmountChildren: function(safely) {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren, safely);
          this._renderedChildren = null;
        },
        moveChild: function(child, afterNode, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            return makeMove(child, afterNode, toIndex);
          }
        },
        createChild: function(child, afterNode, mountImage) {
          return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
        },
        removeChild: function(child, node) {
          return makeRemove(child, node);
        },
        _mountChildAtIndex: function(
          child,
          mountImage,
          afterNode,
          index,
          transaction,
          context
        ) {
          child._mountIndex = index;
          return this.createChild(child, afterNode, mountImage);
        },
        _unmountChild: function(child, node) {
          var update = this.removeChild(child, node);
          child._mountIndex = null;
          return update;
        }
      }
    };
    module.exports = ReactMultiChild;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var invariant = __webpack_require__(0);
    function isValidOwner(object) {
      return !!(
        object &&
        typeof object.attachRef === "function" &&
        typeof object.detachRef === "function"
      );
    }
    var ReactOwner = {
      addComponentAsRefTo: function(component, ref, owner) {
        !isValidOwner(owner)
          ? false
            ? invariant(
                false,
                "addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner)."
              )
            : _prodInvariant("119")
          : void 0;
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        !isValidOwner(owner)
          ? false
            ? invariant(
                false,
                "removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner)."
              )
            : _prodInvariant("120")
          : void 0;
        var ownerPublicInstance = owner.getPublicInstance();
        if (
          ownerPublicInstance &&
          ownerPublicInstance.refs[ref] === component.getPublicInstance()
        ) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var CallbackQueue = __webpack_require__(76);
    var PooledClass = __webpack_require__(17);
    var ReactBrowserEventEmitter = __webpack_require__(32);
    var ReactInputSelection = __webpack_require__(83);
    var ReactInstrumentation = __webpack_require__(9);
    var Transaction = __webpack_require__(34);
    var ReactUpdateQueue = __webpack_require__(48);
    var SELECTION_RESTORATION = {
      initialize: ReactInputSelection.getSelectionInformation,
      close: ReactInputSelection.restoreSelection
    };
    var EVENT_SUPPRESSION = {
      initialize: function() {
        var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
        ReactBrowserEventEmitter.setEnabled(false);
        return currentlyEnabled;
      },
      close: function(previouslyEnabled) {
        ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
      }
    };
    var ON_DOM_READY_QUEUEING = {
      initialize: function() {
        this.reactMountReady.reset();
      },
      close: function() {
        this.reactMountReady.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [
      SELECTION_RESTORATION,
      EVENT_SUPPRESSION,
      ON_DOM_READY_QUEUEING
    ];
    if (false) {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    function ReactReconcileTransaction(useCreateElement) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = false;
      this.reactMountReady = CallbackQueue.getPooled(null);
      this.useCreateElement = useCreateElement;
    }
    var Mixin = {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function() {
        return this.reactMountReady;
      },
      getUpdateQueue: function() {
        return ReactUpdateQueue;
      },
      checkpoint: function() {
        return this.reactMountReady.checkpoint();
      },
      rollback: function(checkpoint) {
        this.reactMountReady.rollback(checkpoint);
      },
      destructor: function() {
        CallbackQueue.release(this.reactMountReady);
        this.reactMountReady = null;
      }
    };
    _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactOwner = __webpack_require__(203);
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === "function") {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === "function") {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function(instance, element) {
      if (element === null || typeof element !== "object") {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
      var prevRef = null;
      var prevOwner = null;
      if (prevElement !== null && typeof prevElement === "object") {
        prevRef = prevElement.ref;
        prevOwner = prevElement._owner;
      }
      var nextRef = null;
      var nextOwner = null;
      if (nextElement !== null && typeof nextElement === "object") {
        nextRef = nextElement.ref;
        nextOwner = nextElement._owner;
      }
      return (
        prevRef !== nextRef ||
        (typeof nextRef === "string" && nextOwner !== prevOwner)
      );
    };
    ReactRef.detachRefs = function(instance, element) {
      if (element === null || typeof element !== "object") {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _assign = __webpack_require__(6);
    var PooledClass = __webpack_require__(17);
    var Transaction = __webpack_require__(34);
    var ReactInstrumentation = __webpack_require__(9);
    var ReactServerUpdateQueue = __webpack_require__(208);
    var TRANSACTION_WRAPPERS = [];
    if (false) {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    var noopCallbackQueue = { enqueue: function() {} };
    function ReactServerRenderingTransaction(renderToStaticMarkup) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = renderToStaticMarkup;
      this.useCreateElement = false;
      this.updateQueue = new ReactServerUpdateQueue(this);
    }
    var Mixin = {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function() {
        return noopCallbackQueue;
      },
      getUpdateQueue: function() {
        return this.updateQueue;
      },
      destructor: function() {},
      checkpoint: function() {},
      rollback: function() {}
    };
    _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ReactUpdateQueue = __webpack_require__(48);
    var warning = __webpack_require__(4);
    function warnNoop(publicInstance, callerName) {
      if (false) {
        var constructor = publicInstance.constructor;
        process.env.NODE_ENV !== "production"
          ? warning(
              false,
              "%s(...): Can only update a mounting component. " +
                "This usually means you called %s() outside componentWillMount() on the server. " +
                "This is a no-op. Please check the code for the %s component.",
              callerName,
              callerName,
              (constructor && (constructor.displayName || constructor.name)) ||
                "ReactClass"
            )
          : void 0;
      }
    }
    var ReactServerUpdateQueue = (function() {
      function ReactServerUpdateQueue(transaction) {
        _classCallCheck(this, ReactServerUpdateQueue);
        this.transaction = transaction;
      }
      ReactServerUpdateQueue.prototype.isMounted = function isMounted(
        publicInstance
      ) {
        return false;
      };
      ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(
        publicInstance,
        callback,
        callerName
      ) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueCallback(
            publicInstance,
            callback,
            callerName
          );
        }
      };
      ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(
        publicInstance
      ) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueForceUpdate(publicInstance);
        } else {
          warnNoop(publicInstance, "forceUpdate");
        }
      };
      ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(
        publicInstance,
        completeState
      ) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
        } else {
          warnNoop(publicInstance, "replaceState");
        }
      };
      ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(
        publicInstance,
        partialState
      ) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
        } else {
          warnNoop(publicInstance, "setState");
        }
      };
      return ReactServerUpdateQueue;
    })();
    module.exports = ReactServerUpdateQueue;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = "15.6.2";
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var NS = {
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace"
    };
    var ATTRS = {
      accentHeight: "accent-height",
      accumulate: 0,
      additive: 0,
      alignmentBaseline: "alignment-baseline",
      allowReorder: "allowReorder",
      alphabetic: 0,
      amplitude: 0,
      arabicForm: "arabic-form",
      ascent: 0,
      attributeName: "attributeName",
      attributeType: "attributeType",
      autoReverse: "autoReverse",
      azimuth: 0,
      baseFrequency: "baseFrequency",
      baseProfile: "baseProfile",
      baselineShift: "baseline-shift",
      bbox: 0,
      begin: 0,
      bias: 0,
      by: 0,
      calcMode: "calcMode",
      capHeight: "cap-height",
      clip: 0,
      clipPath: "clip-path",
      clipRule: "clip-rule",
      clipPathUnits: "clipPathUnits",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      contentScriptType: "contentScriptType",
      contentStyleType: "contentStyleType",
      cursor: 0,
      cx: 0,
      cy: 0,
      d: 0,
      decelerate: 0,
      descent: 0,
      diffuseConstant: "diffuseConstant",
      direction: 0,
      display: 0,
      divisor: 0,
      dominantBaseline: "dominant-baseline",
      dur: 0,
      dx: 0,
      dy: 0,
      edgeMode: "edgeMode",
      elevation: 0,
      enableBackground: "enable-background",
      end: 0,
      exponent: 0,
      externalResourcesRequired: "externalResourcesRequired",
      fill: 0,
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      filter: 0,
      filterRes: "filterRes",
      filterUnits: "filterUnits",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      focusable: 0,
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      format: 0,
      from: 0,
      fx: 0,
      fy: 0,
      g1: 0,
      g2: 0,
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      glyphRef: "glyphRef",
      gradientTransform: "gradientTransform",
      gradientUnits: "gradientUnits",
      hanging: 0,
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      ideographic: 0,
      imageRendering: "image-rendering",
      in: 0,
      in2: 0,
      intercept: 0,
      k: 0,
      k1: 0,
      k2: 0,
      k3: 0,
      k4: 0,
      kernelMatrix: "kernelMatrix",
      kernelUnitLength: "kernelUnitLength",
      kerning: 0,
      keyPoints: "keyPoints",
      keySplines: "keySplines",
      keyTimes: "keyTimes",
      lengthAdjust: "lengthAdjust",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      limitingConeAngle: "limitingConeAngle",
      local: 0,
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      markerHeight: "markerHeight",
      markerUnits: "markerUnits",
      markerWidth: "markerWidth",
      mask: 0,
      maskContentUnits: "maskContentUnits",
      maskUnits: "maskUnits",
      mathematical: 0,
      mode: 0,
      numOctaves: "numOctaves",
      offset: 0,
      opacity: 0,
      operator: 0,
      order: 0,
      orient: 0,
      orientation: 0,
      origin: 0,
      overflow: 0,
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pathLength: "pathLength",
      patternContentUnits: "patternContentUnits",
      patternTransform: "patternTransform",
      patternUnits: "patternUnits",
      pointerEvents: "pointer-events",
      points: 0,
      pointsAtX: "pointsAtX",
      pointsAtY: "pointsAtY",
      pointsAtZ: "pointsAtZ",
      preserveAlpha: "preserveAlpha",
      preserveAspectRatio: "preserveAspectRatio",
      primitiveUnits: "primitiveUnits",
      r: 0,
      radius: 0,
      refX: "refX",
      refY: "refY",
      renderingIntent: "rendering-intent",
      repeatCount: "repeatCount",
      repeatDur: "repeatDur",
      requiredExtensions: "requiredExtensions",
      requiredFeatures: "requiredFeatures",
      restart: 0,
      result: 0,
      rotate: 0,
      rx: 0,
      ry: 0,
      scale: 0,
      seed: 0,
      shapeRendering: "shape-rendering",
      slope: 0,
      spacing: 0,
      specularConstant: "specularConstant",
      specularExponent: "specularExponent",
      speed: 0,
      spreadMethod: "spreadMethod",
      startOffset: "startOffset",
      stdDeviation: "stdDeviation",
      stemh: 0,
      stemv: 0,
      stitchTiles: "stitchTiles",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      string: 0,
      stroke: 0,
      strokeDasharray: "stroke-dasharray",
      strokeDashoffset: "stroke-dashoffset",
      strokeLinecap: "stroke-linecap",
      strokeLinejoin: "stroke-linejoin",
      strokeMiterlimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      surfaceScale: "surfaceScale",
      systemLanguage: "systemLanguage",
      tableValues: "tableValues",
      targetX: "targetX",
      targetY: "targetY",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      textLength: "textLength",
      to: 0,
      transform: 0,
      u1: 0,
      u2: 0,
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicode: 0,
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      values: 0,
      vectorEffect: "vector-effect",
      version: 0,
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      viewBox: "viewBox",
      viewTarget: "viewTarget",
      visibility: 0,
      widths: 0,
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      x: 0,
      xHeight: "x-height",
      x1: 0,
      x2: 0,
      xChannelSelector: "xChannelSelector",
      xlinkActuate: "xlink:actuate",
      xlinkArcrole: "xlink:arcrole",
      xlinkHref: "xlink:href",
      xlinkRole: "xlink:role",
      xlinkShow: "xlink:show",
      xlinkTitle: "xlink:title",
      xlinkType: "xlink:type",
      xmlBase: "xml:base",
      xmlns: 0,
      xmlnsXlink: "xmlns:xlink",
      xmlLang: "xml:lang",
      xmlSpace: "xml:space",
      y: 0,
      y1: 0,
      y2: 0,
      yChannelSelector: "yChannelSelector",
      z: 0,
      zoomAndPan: "zoomAndPan"
    };
    var SVGDOMPropertyConfig = {
      Properties: {},
      DOMAttributeNamespaces: {
        xlinkActuate: NS.xlink,
        xlinkArcrole: NS.xlink,
        xlinkHref: NS.xlink,
        xlinkRole: NS.xlink,
        xlinkShow: NS.xlink,
        xlinkTitle: NS.xlink,
        xlinkType: NS.xlink,
        xmlBase: NS.xml,
        xmlLang: NS.xml,
        xmlSpace: NS.xml
      },
      DOMAttributeNames: {}
    };
    Object.keys(ATTRS).forEach(function(key) {
      SVGDOMPropertyConfig.Properties[key] = 0;
      if (ATTRS[key]) {
        SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
      }
    });
    module.exports = SVGDOMPropertyConfig;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var EventPropagators = __webpack_require__(26);
    var ExecutionEnvironment = __webpack_require__(8);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactInputSelection = __webpack_require__(83);
    var SyntheticEvent = __webpack_require__(12);
    var getActiveElement = __webpack_require__(72);
    var isTextInputElement = __webpack_require__(93);
    var shallowEqual = __webpack_require__(38);
    var skipSelectionChangeEvent =
      ExecutionEnvironment.canUseDOM &&
      "documentMode" in document &&
      document.documentMode <= 11;
    var eventTypes = {
      select: {
        phasedRegistrationNames: {
          bubbled: "onSelect",
          captured: "onSelectCapture"
        },
        dependencies: [
          "topBlur",
          "topContextMenu",
          "topFocus",
          "topKeyDown",
          "topKeyUp",
          "topMouseDown",
          "topMouseUp",
          "topSelectionChange"
        ]
      }
    };
    var activeElement = null;
    var activeElementInst = null;
    var lastSelection = null;
    var mouseDown = false;
    var hasListener = false;
    function getSelection(node) {
      if (
        "selectionStart" in node &&
        ReactInputSelection.hasSelectionCapabilities(node)
      ) {
        return { start: node.selectionStart, end: node.selectionEnd };
      } else if (window.getSelection) {
        var selection = window.getSelection();
        return {
          anchorNode: selection.anchorNode,
          anchorOffset: selection.anchorOffset,
          focusNode: selection.focusNode,
          focusOffset: selection.focusOffset
        };
      } else if (document.selection) {
        var range = document.selection.createRange();
        return {
          parentElement: range.parentElement(),
          text: range.text,
          top: range.boundingTop,
          left: range.boundingLeft
        };
      }
    }
    function constructSelectEvent(nativeEvent, nativeEventTarget) {
      if (
        mouseDown ||
        activeElement == null ||
        activeElement !== getActiveElement()
      ) {
        return null;
      }
      var currentSelection = getSelection(activeElement);
      if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
        lastSelection = currentSelection;
        var syntheticEvent = SyntheticEvent.getPooled(
          eventTypes.select,
          activeElementInst,
          nativeEvent,
          nativeEventTarget
        );
        syntheticEvent.type = "select";
        syntheticEvent.target = activeElement;
        EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
        return syntheticEvent;
      }
      return null;
    }
    var SelectEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        if (!hasListener) {
          return null;
        }
        var targetNode = targetInst
          ? ReactDOMComponentTree.getNodeFromInstance(targetInst)
          : window;
        switch (topLevelType) {
          case "topFocus":
            if (
              isTextInputElement(targetNode) ||
              targetNode.contentEditable === "true"
            ) {
              activeElement = targetNode;
              activeElementInst = targetInst;
              lastSelection = null;
            }
            break;
          case "topBlur":
            activeElement = null;
            activeElementInst = null;
            lastSelection = null;
            break;
          case "topMouseDown":
            mouseDown = true;
            break;
          case "topContextMenu":
          case "topMouseUp":
            mouseDown = false;
            return constructSelectEvent(nativeEvent, nativeEventTarget);
          case "topSelectionChange":
            if (skipSelectionChangeEvent) {
              break;
            }
          case "topKeyDown":
          case "topKeyUp":
            return constructSelectEvent(nativeEvent, nativeEventTarget);
        }
        return null;
      },
      didPutListener: function(inst, registrationName, listener) {
        if (registrationName === "onSelect") {
          hasListener = true;
        }
      }
    };
    module.exports = SelectEventPlugin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var EventListener = __webpack_require__(70);
    var EventPropagators = __webpack_require__(26);
    var ReactDOMComponentTree = __webpack_require__(7);
    var SyntheticAnimationEvent = __webpack_require__(213);
    var SyntheticClipboardEvent = __webpack_require__(214);
    var SyntheticEvent = __webpack_require__(12);
    var SyntheticFocusEvent = __webpack_require__(217);
    var SyntheticKeyboardEvent = __webpack_require__(219);
    var SyntheticMouseEvent = __webpack_require__(33);
    var SyntheticDragEvent = __webpack_require__(216);
    var SyntheticTouchEvent = __webpack_require__(220);
    var SyntheticTransitionEvent = __webpack_require__(221);
    var SyntheticUIEvent = __webpack_require__(28);
    var SyntheticWheelEvent = __webpack_require__(222);
    var emptyFunction = __webpack_require__(10);
    var getEventCharCode = __webpack_require__(50);
    var invariant = __webpack_require__(0);
    var eventTypes = {};
    var topLevelEventsToDispatchConfig = {};
    [
      "abort",
      "animationEnd",
      "animationIteration",
      "animationStart",
      "blur",
      "canPlay",
      "canPlayThrough",
      "click",
      "contextMenu",
      "copy",
      "cut",
      "doubleClick",
      "drag",
      "dragEnd",
      "dragEnter",
      "dragExit",
      "dragLeave",
      "dragOver",
      "dragStart",
      "drop",
      "durationChange",
      "emptied",
      "encrypted",
      "ended",
      "error",
      "focus",
      "input",
      "invalid",
      "keyDown",
      "keyPress",
      "keyUp",
      "load",
      "loadedData",
      "loadedMetadata",
      "loadStart",
      "mouseDown",
      "mouseMove",
      "mouseOut",
      "mouseOver",
      "mouseUp",
      "paste",
      "pause",
      "play",
      "playing",
      "progress",
      "rateChange",
      "reset",
      "scroll",
      "seeked",
      "seeking",
      "stalled",
      "submit",
      "suspend",
      "timeUpdate",
      "touchCancel",
      "touchEnd",
      "touchMove",
      "touchStart",
      "transitionEnd",
      "volumeChange",
      "waiting",
      "wheel"
    ].forEach(function(event) {
      var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
      var onEvent = "on" + capitalizedEvent;
      var topEvent = "top" + capitalizedEvent;
      var type = {
        phasedRegistrationNames: {
          bubbled: onEvent,
          captured: onEvent + "Capture"
        },
        dependencies: [topEvent]
      };
      eventTypes[event] = type;
      topLevelEventsToDispatchConfig[topEvent] = type;
    });
    var onClickListeners = {};
    function getDictionaryKey(inst) {
      return "." + inst._rootNodeID;
    }
    function isInteractive(tag) {
      return (
        tag === "button" ||
        tag === "input" ||
        tag === "select" ||
        tag === "textarea"
      );
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case "topAbort":
          case "topCanPlay":
          case "topCanPlayThrough":
          case "topDurationChange":
          case "topEmptied":
          case "topEncrypted":
          case "topEnded":
          case "topError":
          case "topInput":
          case "topInvalid":
          case "topLoad":
          case "topLoadedData":
          case "topLoadedMetadata":
          case "topLoadStart":
          case "topPause":
          case "topPlay":
          case "topPlaying":
          case "topProgress":
          case "topRateChange":
          case "topReset":
          case "topSeeked":
          case "topSeeking":
          case "topStalled":
          case "topSubmit":
          case "topSuspend":
          case "topTimeUpdate":
          case "topVolumeChange":
          case "topWaiting":
            EventConstructor = SyntheticEvent;
            break;
          case "topKeyPress":
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case "topKeyDown":
          case "topKeyUp":
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case "topBlur":
          case "topFocus":
            EventConstructor = SyntheticFocusEvent;
            break;
          case "topClick":
            if (nativeEvent.button === 2) {
              return null;
            }
          case "topDoubleClick":
          case "topMouseDown":
          case "topMouseMove":
          case "topMouseUp":
          case "topMouseOut":
          case "topMouseOver":
          case "topContextMenu":
            EventConstructor = SyntheticMouseEvent;
            break;
          case "topDrag":
          case "topDragEnd":
          case "topDragEnter":
          case "topDragExit":
          case "topDragLeave":
          case "topDragOver":
          case "topDragStart":
          case "topDrop":
            EventConstructor = SyntheticDragEvent;
            break;
          case "topTouchCancel":
          case "topTouchEnd":
          case "topTouchMove":
          case "topTouchStart":
            EventConstructor = SyntheticTouchEvent;
            break;
          case "topAnimationEnd":
          case "topAnimationIteration":
          case "topAnimationStart":
            EventConstructor = SyntheticAnimationEvent;
            break;
          case "topTransitionEnd":
            EventConstructor = SyntheticTransitionEvent;
            break;
          case "topScroll":
            EventConstructor = SyntheticUIEvent;
            break;
          case "topWheel":
            EventConstructor = SyntheticWheelEvent;
            break;
          case "topCopy":
          case "topCut":
          case "topPaste":
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        !EventConstructor
          ? false
            ? invariant(
                false,
                "SimpleEventPlugin: Unhandled event type, `%s`.",
                topLevelType
              )
            : _prodInvariant("86", topLevelType)
          : void 0;
        var event = EventConstructor.getPooled(
          dispatchConfig,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      },
      didPutListener: function(inst, registrationName, listener) {
        if (registrationName === "onClick" && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          if (!onClickListeners[key]) {
            onClickListeners[key] = EventListener.listen(
              node,
              "click",
              emptyFunction
            );
          }
        }
      },
      willDeleteListener: function(inst, registrationName) {
        if (registrationName === "onClick" && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          onClickListeners[key].remove();
          delete onClickListeners[key];
        }
      }
    };
    module.exports = SimpleEventPlugin;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var AnimationEventInterface = {
      animationName: null,
      elapsedTime: null,
      pseudoElement: null
    };
    function SyntheticAnimationEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(
      SyntheticAnimationEvent,
      AnimationEventInterface
    );
    module.exports = SyntheticAnimationEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var ClipboardEventInterface = {
      clipboardData: function(event) {
        return "clipboardData" in event
          ? event.clipboardData
          : window.clipboardData;
      }
    };
    function SyntheticClipboardEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(
      SyntheticClipboardEvent,
      ClipboardEventInterface
    );
    module.exports = SyntheticClipboardEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var CompositionEventInterface = { data: null };
    function SyntheticCompositionEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(
      SyntheticCompositionEvent,
      CompositionEventInterface
    );
    module.exports = SyntheticCompositionEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticMouseEvent = __webpack_require__(33);
    var DragEventInterface = { dataTransfer: null };
    function SyntheticDragEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticMouseEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
    module.exports = SyntheticDragEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticUIEvent = __webpack_require__(28);
    var FocusEventInterface = { relatedTarget: null };
    function SyntheticFocusEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticUIEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
    module.exports = SyntheticFocusEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var InputEventInterface = { data: null };
    function SyntheticInputEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
    module.exports = SyntheticInputEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticUIEvent = __webpack_require__(28);
    var getEventCharCode = __webpack_require__(50);
    var getEventKey = __webpack_require__(227);
    var getEventModifierState = __webpack_require__(51);
    var KeyboardEventInterface = {
      key: getEventKey,
      location: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      repeat: null,
      locale: null,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        if (event.type === "keypress") {
          return getEventCharCode(event);
        }
        return 0;
      },
      keyCode: function(event) {
        if (event.type === "keydown" || event.type === "keyup") {
          return event.keyCode;
        }
        return 0;
      },
      which: function(event) {
        if (event.type === "keypress") {
          return getEventCharCode(event);
        }
        if (event.type === "keydown" || event.type === "keyup") {
          return event.keyCode;
        }
        return 0;
      }
    };
    function SyntheticKeyboardEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticUIEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticUIEvent.augmentClass(
      SyntheticKeyboardEvent,
      KeyboardEventInterface
    );
    module.exports = SyntheticKeyboardEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticUIEvent = __webpack_require__(28);
    var getEventModifierState = __webpack_require__(51);
    var TouchEventInterface = {
      touches: null,
      targetTouches: null,
      changedTouches: null,
      altKey: null,
      metaKey: null,
      ctrlKey: null,
      shiftKey: null,
      getModifierState: getEventModifierState
    };
    function SyntheticTouchEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticUIEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
    module.exports = SyntheticTouchEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticEvent = __webpack_require__(12);
    var TransitionEventInterface = {
      propertyName: null,
      elapsedTime: null,
      pseudoElement: null
    };
    function SyntheticTransitionEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticEvent.augmentClass(
      SyntheticTransitionEvent,
      TransitionEventInterface
    );
    module.exports = SyntheticTransitionEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var SyntheticMouseEvent = __webpack_require__(33);
    var WheelEventInterface = {
      deltaX: function(event) {
        return "deltaX" in event
          ? event.deltaX
          : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event
          ? event.deltaY
          : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
          ? -event.wheelDelta
          : 0;
      },
      deltaZ: null,
      deltaMode: null
    };
    function SyntheticWheelEvent(
      dispatchConfig,
      dispatchMarker,
      nativeEvent,
      nativeEventTarget
    ) {
      return SyntheticMouseEvent.call(
        this,
        dispatchConfig,
        dispatchMarker,
        nativeEvent,
        nativeEventTarget
      );
    }
    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
    module.exports = SyntheticWheelEvent;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var MOD = 65521;
    function adler32(data) {
      var a = 1;
      var b = 0;
      var i = 0;
      var l = data.length;
      var m = l & ~0x3;
      while (i < m) {
        var n = Math.min(i + 4096, m);
        for (; i < n; i += 4) {
          b +=
            (a += data.charCodeAt(i)) +
            (a += data.charCodeAt(i + 1)) +
            (a += data.charCodeAt(i + 2)) +
            (a += data.charCodeAt(i + 3));
        }
        a %= MOD;
        b %= MOD;
      }
      for (; i < l; i++) {
        b += a += data.charCodeAt(i);
      }
      a %= MOD;
      b %= MOD;
      return a | (b << 16);
    }
    module.exports = adler32;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var CSSProperty = __webpack_require__(75);
    var warning = __webpack_require__(4);
    var isUnitlessNumber = CSSProperty.isUnitlessNumber;
    var styleWarnings = {};
    function dangerousStyleValue(name, value, component, isCustomProperty) {
      var isEmpty = value == null || typeof value === "boolean" || value === "";
      if (isEmpty) {
        return "";
      }
      var isNonNumeric = isNaN(value);
      if (
        isCustomProperty ||
        isNonNumeric ||
        value === 0 ||
        (isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])
      ) {
        return "" + value;
      }
      if (typeof value === "string") {
        if (false) {
          if (component && value !== "0") {
            var owner = component._currentElement._owner;
            var ownerName = owner ? owner.getName() : null;
            if (ownerName && !styleWarnings[ownerName]) {
              styleWarnings[ownerName] = {};
            }
            var warned = false;
            if (ownerName) {
              var warnings = styleWarnings[ownerName];
              warned = warnings[name];
              if (!warned) {
                warnings[name] = true;
              }
            }
            if (!warned) {
              process.env.NODE_ENV !== "production"
                ? warning(
                    false,
                    "a `%s` tag (owner: `%s`) was passed a numeric string value " +
                      "for CSS property `%s` (value: `%s`) which will be treated " +
                      "as a unitless number in a future version of React.",
                    component._currentElement.type,
                    ownerName || "unknown",
                    name,
                    value
                  )
                : void 0;
            }
          }
        }
        value = value.trim();
      }
      return value + "px";
    }
    module.exports = dangerousStyleValue;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(3);
    var ReactCurrentOwner = __webpack_require__(13);
    var ReactDOMComponentTree = __webpack_require__(7);
    var ReactInstanceMap = __webpack_require__(27);
    var getHostComponentFromComposite = __webpack_require__(89);
    var invariant = __webpack_require__(0);
    var warning = __webpack_require__(4);
    function findDOMNode(componentOrElement) {
      if (false) {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          process.env.NODE_ENV !== "production"
            ? warning(
                owner._warnedAboutRefsInRender,
                "%s is accessing findDOMNode inside its render(). " +
                  "render() should be a pure function of props and state. It should " +
                  "never access something that requires stale data from the previous " +
                  "render, such as refs. Move this logic to componentDidMount and " +
                  "componentDidUpdate instead.",
                owner.getName() || "A component"
              )
            : void 0;
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === 1) {
        return componentOrElement;
      }
      var inst = ReactInstanceMap.get(componentOrElement);
      if (inst) {
        inst = getHostComponentFromComposite(inst);
        return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
      }
      if (typeof componentOrElement.render === "function") {
        true
          ? false
            ? invariant(
                false,
                "findDOMNode was called on an unmounted component."
              )
            : _prodInvariant("44")
          : void 0;
      } else {
        true
          ? false
            ? invariant(
                false,
                "Element appears to be neither ReactComponent nor DOMNode (keys: %s)",
                Object.keys(componentOrElement)
              )
            : _prodInvariant("45", Object.keys(componentOrElement))
          : void 0;
      }
    }
    module.exports = findDOMNode;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    (function(process) {
      var KeyEscapeUtils = __webpack_require__(44);
      var traverseAllChildren = __webpack_require__(95);
      var warning = __webpack_require__(4);
      var ReactComponentTreeHook;
      if (
        typeof process !== "undefined" &&
        __webpack_require__.i({ NODE_ENV: "production" }) &&
        "production" === "test"
      ) {
        ReactComponentTreeHook = __webpack_require__(101);
      }
      function flattenSingleChildIntoContext(
        traverseContext,
        child,
        name,
        selfDebugID
      ) {
        if (traverseContext && typeof traverseContext === "object") {
          var result = traverseContext;
          var keyUnique = result[name] === undefined;
          if (false) {
            if (!ReactComponentTreeHook) {
              ReactComponentTreeHook = require("react/lib/ReactComponentTreeHook");
            }
            if (!keyUnique) {
              process.env.NODE_ENV !== "production"
                ? warning(
                    false,
                    "flattenChildren(...): Encountered two children with the same key, " +
                      "`%s`. Child keys must be unique; when two children share a key, only " +
                      "the first child will be used.%s",
                    KeyEscapeUtils.unescape(name),
                    ReactComponentTreeHook.getStackAddendumByID(selfDebugID)
                  )
                : void 0;
            }
          }
          if (keyUnique && child != null) {
            result[name] = child;
          }
        }
      }
      function flattenChildren(children, selfDebugID) {
        if (children == null) {
          return children;
        }
        var result = {};
        if (false) {
          traverseAllChildren(
            children,
            function(traverseContext, child, name) {
              return flattenSingleChildIntoContext(
                traverseContext,
                child,
                name,
                selfDebugID
              );
            },
            result
          );
        } else {
          traverseAllChildren(children, flattenSingleChildIntoContext, result);
        }
        return result;
      }
      module.exports = flattenChildren;
    }.call(exports, __webpack_require__(39)));
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var getEventCharCode = __webpack_require__(50);
    var normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function getEventKey(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if (key !== "Unidentified") {
          return key;
        }
      }
      if (nativeEvent.type === "keypress") {
        var charCode = getEventCharCode(nativeEvent);
        return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
      }
      if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
        return translateToKey[nativeEvent.keyCode] || "Unidentified";
      }
      return "";
    }
    module.exports = getEventKey;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn =
        maybeIterable &&
        ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    module.exports = getIteratorFn;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function getLeafNode(node) {
      while (node && node.firstChild) {
        node = node.firstChild;
      }
      return node;
    }
    function getSiblingNode(node) {
      while (node) {
        if (node.nextSibling) {
          return node.nextSibling;
        }
        node = node.parentNode;
      }
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      var nodeStart = 0;
      var nodeEnd = 0;
      while (node) {
        if (node.nodeType === 3) {
          nodeEnd = nodeStart + node.textContent.length;
          if (nodeStart <= offset && nodeEnd >= offset) {
            return { node: node, offset: offset - nodeStart };
          }
          nodeStart = nodeEnd;
        }
        node = getLeafNode(getSiblingNode(node));
      }
    }
    module.exports = getNodeForCharacterOffset;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ExecutionEnvironment = __webpack_require__(8);
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      prefixes["ms" + styleProp] = "MS" + eventName;
      prefixes["O" + styleProp] = "o" + eventName.toLowerCase();
      return prefixes;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    var prefixedEventNames = {};
    var style = {};
    if (ExecutionEnvironment.canUseDOM) {
      style = document.createElement("div").style;
      if (!("AnimationEvent" in window)) {
        delete vendorPrefixes.animationend.animation;
        delete vendorPrefixes.animationiteration.animation;
        delete vendorPrefixes.animationstart.animation;
      }
      if (!("TransitionEvent" in window)) {
        delete vendorPrefixes.transitionend.transition;
      }
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      } else if (!vendorPrefixes[eventName]) {
        return eventName;
      }
      var prefixMap = vendorPrefixes[eventName];
      for (var styleProp in prefixMap) {
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
        }
      }
      return "";
    }
    module.exports = getVendorPrefixedEventName;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var escapeTextContentForBrowser = __webpack_require__(35);
    function quoteAttributeValueForBrowser(value) {
      return '"' + escapeTextContentForBrowser(value) + '"';
    }
    module.exports = quoteAttributeValueForBrowser;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactMount = __webpack_require__(84);
    module.exports = ReactMount.renderSubtreeIntoContainer;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _react = __webpack_require__(1);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = __webpack_require__(2);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return call && (typeof call === "object" || typeof call === "function")
        ? call
        : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass);
    }
    var sizerStyle = {
      position: "absolute",
      top: 0,
      left: 0,
      visibility: "hidden",
      height: 0,
      overflow: "scroll",
      whiteSpace: "pre"
    };
    var INPUT_PROPS_BLACKLIST = [
      "extraWidth",
      "injectStyles",
      "inputClassName",
      "inputRef",
      "inputStyle",
      "minWidth",
      "onAutosize",
      "placeholderIsMinWidth"
    ];
    var cleanInputProps = function cleanInputProps(inputProps) {
      INPUT_PROPS_BLACKLIST.forEach(function(field) {
        return delete inputProps[field];
      });
      return inputProps;
    };
    var copyStyles = function copyStyles(styles, node) {
      node.style.fontSize = styles.fontSize;
      node.style.fontFamily = styles.fontFamily;
      node.style.fontWeight = styles.fontWeight;
      node.style.fontStyle = styles.fontStyle;
      node.style.letterSpacing = styles.letterSpacing;
      node.style.textTransform = styles.textTransform;
    };
    var isIE =
      typeof window !== "undefined" && window.navigator
        ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent)
        : false;
    var generateId = function generateId() {
      return isIE
        ? "_" +
            Math.random()
              .toString(36)
              .substr(2, 12)
        : undefined;
    };
    var AutosizeInput = (function(_Component) {
      _inherits(AutosizeInput, _Component);
      function AutosizeInput(props) {
        _classCallCheck(this, AutosizeInput);
        var _this = _possibleConstructorReturn(
          this,
          (
            AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)
          ).call(this, props)
        );
        _this.inputRef = function(el) {
          _this.input = el;
          if (typeof _this.props.inputRef === "function") {
            _this.props.inputRef(el);
          }
        };
        _this.placeHolderSizerRef = function(el) {
          _this.placeHolderSizer = el;
        };
        _this.sizerRef = function(el) {
          _this.sizer = el;
        };
        _this.state = {
          inputWidth: props.minWidth,
          inputId: props.id || generateId()
        };
        return _this;
      }
      _createClass(AutosizeInput, [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.mounted = true;
            this.copyInputStyles();
            this.updateInputWidth();
          }
        },
        {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            var id = nextProps.id;
            if (id !== this.props.id) {
              this.setState({ inputId: id || generateId() });
            }
          }
        },
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps, prevState) {
            if (prevState.inputWidth !== this.state.inputWidth) {
              if (typeof this.props.onAutosize === "function") {
                this.props.onAutosize(this.state.inputWidth);
              }
            }
            this.updateInputWidth();
          }
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.mounted = false;
          }
        },
        {
          key: "copyInputStyles",
          value: function copyInputStyles() {
            if (!this.mounted || !window.getComputedStyle) {
              return;
            }
            var inputStyles = this.input && window.getComputedStyle(this.input);
            if (!inputStyles) {
              return;
            }
            copyStyles(inputStyles, this.sizer);
            if (this.placeHolderSizer) {
              copyStyles(inputStyles, this.placeHolderSizer);
            }
          }
        },
        {
          key: "updateInputWidth",
          value: function updateInputWidth() {
            if (
              !this.mounted ||
              !this.sizer ||
              typeof this.sizer.scrollWidth === "undefined"
            ) {
              return;
            }
            var newInputWidth = void 0;
            if (
              this.props.placeholder &&
              (!this.props.value ||
                (this.props.value && this.props.placeholderIsMinWidth))
            ) {
              newInputWidth =
                Math.max(
                  this.sizer.scrollWidth,
                  this.placeHolderSizer.scrollWidth
                ) + 2;
            } else {
              newInputWidth = this.sizer.scrollWidth + 2;
            }
            var extraWidth =
              this.props.type === "number" &&
              this.props.extraWidth === undefined
                ? 16
                : parseInt(this.props.extraWidth) || 0;
            newInputWidth += extraWidth;
            if (newInputWidth < this.props.minWidth) {
              newInputWidth = this.props.minWidth;
            }
            if (newInputWidth !== this.state.inputWidth) {
              this.setState({ inputWidth: newInputWidth });
            }
          }
        },
        {
          key: "getInput",
          value: function getInput() {
            return this.input;
          }
        },
        {
          key: "focus",
          value: function focus() {
            this.input.focus();
          }
        },
        {
          key: "blur",
          value: function blur() {
            this.input.blur();
          }
        },
        {
          key: "select",
          value: function select() {
            this.input.select();
          }
        },
        {
          key: "renderStyles",
          value: function renderStyles() {
            var injectStyles = this.props.injectStyles;
            return isIE && injectStyles
              ? _react2.default.createElement("style", {
                  dangerouslySetInnerHTML: {
                    __html:
                      "input#" +
                      this.state.inputId +
                      "::-ms-clear {display: none;}"
                  }
                })
              : null;
          }
        },
        {
          key: "render",
          value: function render() {
            var sizerValue = [
              this.props.defaultValue,
              this.props.value,
              ""
            ].reduce(function(previousValue, currentValue) {
              if (previousValue !== null && previousValue !== undefined) {
                return previousValue;
              }
              return currentValue;
            });
            var wrapperStyle = _extends({}, this.props.style);
            if (!wrapperStyle.display) wrapperStyle.display = "inline-block";
            var inputStyle = _extends(
              { boxSizing: "content-box", width: this.state.inputWidth + "px" },
              this.props.inputStyle
            );
            var inputProps = _objectWithoutProperties(this.props, []);
            cleanInputProps(inputProps);
            inputProps.className = this.props.inputClassName;
            inputProps.id = this.state.inputId;
            inputProps.style = inputStyle;
            return _react2.default.createElement(
              "div",
              { className: this.props.className, style: wrapperStyle },
              this.renderStyles(),
              _react2.default.createElement(
                "input",
                _extends({}, inputProps, { ref: this.inputRef })
              ),
              _react2.default.createElement(
                "div",
                { ref: this.sizerRef, style: sizerStyle },
                sizerValue
              ),
              this.props.placeholder
                ? _react2.default.createElement(
                    "div",
                    { ref: this.placeHolderSizerRef, style: sizerStyle },
                    this.props.placeholder
                  )
                : null
            );
          }
        }
      ]);
      return AutosizeInput;
    })(_react.Component);
    AutosizeInput.propTypes = {
      className: _propTypes2.default.string,
      defaultValue: _propTypes2.default.any,
      extraWidth: _propTypes2.default.oneOfType([
        _propTypes2.default.number,
        _propTypes2.default.string
      ]),
      id: _propTypes2.default.string,
      injectStyles: _propTypes2.default.bool,
      inputClassName: _propTypes2.default.string,
      inputRef: _propTypes2.default.func,
      inputStyle: _propTypes2.default.object,
      minWidth: _propTypes2.default.oneOfType([
        _propTypes2.default.number,
        _propTypes2.default.string
      ]),
      onAutosize: _propTypes2.default.func,
      onChange: _propTypes2.default.func,
      placeholder: _propTypes2.default.string,
      placeholderIsMinWidth: _propTypes2.default.bool,
      style: _propTypes2.default.object,
      value: _propTypes2.default.any
    };
    AutosizeInput.defaultProps = { minWidth: 1, injectStyles: true };
    exports.default = AutosizeInput;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var PropTypes = _interopRequireWildcard(__webpack_require__(2));
    var _addClass = _interopRequireDefault(__webpack_require__(145));
    var _removeClass = _interopRequireDefault(__webpack_require__(147));
    var _react = _interopRequireDefault(__webpack_require__(1));
    var _Transition = _interopRequireDefault(__webpack_require__(97));
    var _PropTypes = __webpack_require__(99);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function _extends() {
      _extends =
        Object.assign ||
        function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
      return _extends.apply(this, arguments);
    }
    var addClass = function addClass(node, classes) {
      return (
        node &&
        classes &&
        classes.split(" ").forEach(function(c) {
          return (0, _addClass.default)(node, c);
        })
      );
    };
    var removeClass = function removeClass(node, classes) {
      return (
        node &&
        classes &&
        classes.split(" ").forEach(function(c) {
          return (0, _removeClass.default)(node, c);
        })
      );
    };
    var propTypes = false
      ? _extends({}, _Transition.default.propTypes, {
          classNames: _PropTypes.classNamesShape,
          onEnter: PropTypes.func,
          onEntering: PropTypes.func,
          onEntered: PropTypes.func,
          onExit: PropTypes.func,
          onExiting: PropTypes.func,
          onExited: PropTypes.func
        })
      : {};
    var CSSTransition = (function(_React$Component) {
      _inheritsLoose(CSSTransition, _React$Component);
      function CSSTransition() {
        var _this;
        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        _this =
          _React$Component.call.apply(_React$Component, [this].concat(args)) ||
          this;
        _this.onEnter = function(node, appearing) {
          var _this$getClassNames = _this.getClassNames(
              appearing ? "appear" : "enter"
            ),
            className = _this$getClassNames.className;
          _this.removeClasses(node, "exit");
          addClass(node, className);
          if (_this.props.onEnter) {
            _this.props.onEnter(node);
          }
        };
        _this.onEntering = function(node, appearing) {
          var _this$getClassNames2 = _this.getClassNames(
              appearing ? "appear" : "enter"
            ),
            activeClassName = _this$getClassNames2.activeClassName;
          _this.reflowAndAddClass(node, activeClassName);
          if (_this.props.onEntering) {
            _this.props.onEntering(node);
          }
        };
        _this.onEntered = function(node, appearing) {
          var _this$getClassNames3 = _this.getClassNames("enter"),
            doneClassName = _this$getClassNames3.doneClassName;
          _this.removeClasses(node, appearing ? "appear" : "enter");
          addClass(node, doneClassName);
          if (_this.props.onEntered) {
            _this.props.onEntered(node);
          }
        };
        _this.onExit = function(node) {
          var _this$getClassNames4 = _this.getClassNames("exit"),
            className = _this$getClassNames4.className;
          _this.removeClasses(node, "appear");
          _this.removeClasses(node, "enter");
          addClass(node, className);
          if (_this.props.onExit) {
            _this.props.onExit(node);
          }
        };
        _this.onExiting = function(node) {
          var _this$getClassNames5 = _this.getClassNames("exit"),
            activeClassName = _this$getClassNames5.activeClassName;
          _this.reflowAndAddClass(node, activeClassName);
          if (_this.props.onExiting) {
            _this.props.onExiting(node);
          }
        };
        _this.onExited = function(node) {
          var _this$getClassNames6 = _this.getClassNames("exit"),
            doneClassName = _this$getClassNames6.doneClassName;
          _this.removeClasses(node, "exit");
          addClass(node, doneClassName);
          if (_this.props.onExited) {
            _this.props.onExited(node);
          }
        };
        _this.getClassNames = function(type) {
          var classNames = _this.props.classNames;
          var className =
            typeof classNames !== "string"
              ? classNames[type]
              : classNames + "-" + type;
          var activeClassName =
            typeof classNames !== "string"
              ? classNames[type + "Active"]
              : className + "-active";
          var doneClassName =
            typeof classNames !== "string"
              ? classNames[type + "Done"]
              : className + "-done";
          return {
            className: className,
            activeClassName: activeClassName,
            doneClassName: doneClassName
          };
        };
        return _this;
      }
      var _proto = CSSTransition.prototype;
      _proto.removeClasses = function removeClasses(node, type) {
        var _this$getClassNames7 = this.getClassNames(type),
          className = _this$getClassNames7.className,
          activeClassName = _this$getClassNames7.activeClassName,
          doneClassName = _this$getClassNames7.doneClassName;
        className && removeClass(node, className);
        activeClassName && removeClass(node, activeClassName);
        doneClassName && removeClass(node, doneClassName);
      };
      _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
        if (className) {
          node && node.scrollTop;
          addClass(node, className);
        }
      };
      _proto.render = function render() {
        var props = _extends({}, this.props);
        delete props.classNames;
        return _react.default.createElement(
          _Transition.default,
          _extends({}, props, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited
          })
        );
      };
      return CSSTransition;
    })(_react.default.Component);
    CSSTransition.propTypes = false ? propTypes : {};
    var _default = CSSTransition;
    exports.default = _default;
    module.exports = exports["default"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _propTypes = _interopRequireDefault(__webpack_require__(2));
    var _react = _interopRequireDefault(__webpack_require__(1));
    var _reactDom = __webpack_require__(31);
    var _TransitionGroup = _interopRequireDefault(__webpack_require__(98));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var propTypes = false
      ? {
          in: _propTypes.default.bool.isRequired,
          children: function children(props, propName) {
            if (_react.default.Children.count(props[propName]) !== 2)
              return new Error(
                '"' + propName + '" must be exactly two transition components.'
              );
            return null;
          }
        }
      : {};
    var ReplaceTransition = (function(_React$Component) {
      _inheritsLoose(ReplaceTransition, _React$Component);
      function ReplaceTransition() {
        var _this;
        for (
          var _len = arguments.length, _args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          _args[_key] = arguments[_key];
        }
        _this =
          _React$Component.call.apply(_React$Component, [this].concat(_args)) ||
          this;
        _this.handleEnter = function() {
          for (
            var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
            _key2 < _len2;
            _key2++
          ) {
            args[_key2] = arguments[_key2];
          }
          return _this.handleLifecycle("onEnter", 0, args);
        };
        _this.handleEntering = function() {
          for (
            var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
            _key3 < _len3;
            _key3++
          ) {
            args[_key3] = arguments[_key3];
          }
          return _this.handleLifecycle("onEntering", 0, args);
        };
        _this.handleEntered = function() {
          for (
            var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;
            _key4 < _len4;
            _key4++
          ) {
            args[_key4] = arguments[_key4];
          }
          return _this.handleLifecycle("onEntered", 0, args);
        };
        _this.handleExit = function() {
          for (
            var _len5 = arguments.length, args = new Array(_len5), _key5 = 0;
            _key5 < _len5;
            _key5++
          ) {
            args[_key5] = arguments[_key5];
          }
          return _this.handleLifecycle("onExit", 1, args);
        };
        _this.handleExiting = function() {
          for (
            var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
            _key6 < _len6;
            _key6++
          ) {
            args[_key6] = arguments[_key6];
          }
          return _this.handleLifecycle("onExiting", 1, args);
        };
        _this.handleExited = function() {
          for (
            var _len7 = arguments.length, args = new Array(_len7), _key7 = 0;
            _key7 < _len7;
            _key7++
          ) {
            args[_key7] = arguments[_key7];
          }
          return _this.handleLifecycle("onExited", 1, args);
        };
        return _this;
      }
      var _proto = ReplaceTransition.prototype;
      _proto.handleLifecycle = function handleLifecycle(
        handler,
        idx,
        originalArgs
      ) {
        var _child$props;
        var children = this.props.children;
        var child = _react.default.Children.toArray(children)[idx];
        if (child.props[handler])
          (_child$props = child.props)[handler].apply(
            _child$props,
            originalArgs
          );
        if (this.props[handler])
          this.props[handler]((0, _reactDom.findDOMNode)(this));
      };
      _proto.render = function render() {
        var _this$props = this.props,
          children = _this$props.children,
          inProp = _this$props.in,
          props = _objectWithoutPropertiesLoose(_this$props, [
            "children",
            "in"
          ]);
        var _React$Children$toArr = _react.default.Children.toArray(children),
          first = _React$Children$toArr[0],
          second = _React$Children$toArr[1];
        delete props.onEnter;
        delete props.onEntering;
        delete props.onEntered;
        delete props.onExit;
        delete props.onExiting;
        delete props.onExited;
        return _react.default.createElement(
          _TransitionGroup.default,
          props,
          inProp
            ? _react.default.cloneElement(first, {
                key: "first",
                onEnter: this.handleEnter,
                onEntering: this.handleEntering,
                onEntered: this.handleEntered
              })
            : _react.default.cloneElement(second, {
                key: "second",
                onEnter: this.handleExit,
                onEntering: this.handleExiting,
                onEntered: this.handleExited
              })
        );
      };
      return ReplaceTransition;
    })(_react.default.Component);
    ReplaceTransition.propTypes = false ? propTypes : {};
    var _default = ReplaceTransition;
    exports.default = _default;
    module.exports = exports["default"];
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _CSSTransition = _interopRequireDefault(__webpack_require__(234));
    var _ReplaceTransition = _interopRequireDefault(__webpack_require__(235));
    var _TransitionGroup = _interopRequireDefault(__webpack_require__(98));
    var _Transition = _interopRequireDefault(__webpack_require__(97));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = {
      Transition: _Transition.default,
      TransitionGroup: _TransitionGroup.default,
      ReplaceTransition: _ReplaceTransition.default,
      CSSTransition: _CSSTransition.default
    };
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.getChildMapping = getChildMapping;
    exports.mergeChildMappings = mergeChildMappings;
    exports.getInitialChildMapping = getInitialChildMapping;
    exports.getNextChildMapping = getNextChildMapping;
    var _react = __webpack_require__(1);
    function getChildMapping(children, mapFn) {
      var mapper = function mapper(child) {
        return mapFn && (0, _react.isValidElement)(child)
          ? mapFn(child)
          : child;
      };
      var result = Object.create(null);
      if (children)
        _react.Children.map(children, function(c) {
          return c;
        }).forEach(function(child) {
          result[child.key] = mapper(child);
        });
      return result;
    }
    function mergeChildMappings(prev, next) {
      prev = prev || {};
      next = next || {};
      function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
      }
      var nextKeysPending = Object.create(null);
      var pendingKeys = [];
      for (var prevKey in prev) {
        if (prevKey in next) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      var i;
      var childMapping = {};
      for (var nextKey in next) {
        if (nextKeysPending[nextKey]) {
          for (i = 0; i < nextKeysPending[nextKey].length; i++) {
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(
              pendingNextKey
            );
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
      }
      return childMapping;
    }
    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }
    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function(child) {
        return (0,
        _react.cloneElement)(child, { onExited: onExited.bind(null, child), in: true, appear: getProp(child, "appear", props), enter: getProp(child, "enter", props), exit: getProp(child, "exit", props) });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!(0, _react.isValidElement)(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving =
          (0, _react.isValidElement)(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
          children[key] = (0, _react.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          children[key] = (0, _react.cloneElement)(child, { in: false });
        } else if (
          hasNext &&
          hasPrev &&
          (0, _react.isValidElement)(prevChild)
        ) {
          children[key] = (0, _react.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        }
      });
      return children;
    }
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = { "=": "=0", ":": "=2" };
      var escapedString = ("" + key).replace(escapeRegex, function(match) {
        return escaperLookup[match];
      });
      return "$" + escapedString;
    }
    function unescape(key) {
      var unescapeRegex = /(=0|=2)/g;
      var unescaperLookup = { "=0": "=", "=2": ":" };
      var keySubstring =
        key[0] === "." && key[1] === "$" ? key.substring(2) : key.substring(1);
      return ("" + keySubstring).replace(unescapeRegex, function(match) {
        return unescaperLookup[match];
      });
    }
    var KeyEscapeUtils = { escape: escape, unescape: unescape };
    module.exports = KeyEscapeUtils;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(29);
    var invariant = __webpack_require__(0);
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function(a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      !(instance instanceof Klass)
        ? false
          ? invariant(
              false,
              "Trying to release an instance into a pool of a different type."
            )
          : _prodInvariant("25")
        : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var PooledClass = __webpack_require__(239);
    var ReactElement = __webpack_require__(22);
    var emptyFunction = __webpack_require__(10);
    var traverseAllChildren = __webpack_require__(249);
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var fourArgumentPooler = PooledClass.fourArgumentPooler;
    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
    }
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.func = forEachFunction;
      this.context = forEachContext;
      this.count = 0;
    }
    ForEachBookKeeping.prototype.destructor = function() {
      this.func = null;
      this.context = null;
      this.count = 0;
    };
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
        context = bookKeeping.context;
      func.call(context, child, bookKeeping.count++);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(
        forEachFunc,
        forEachContext
      );
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
      this.result = mapResult;
      this.keyPrefix = keyPrefix;
      this.func = mapFunction;
      this.context = mapContext;
      this.count = 0;
    }
    MapBookKeeping.prototype.destructor = function() {
      this.result = null;
      this.keyPrefix = null;
      this.func = null;
      this.context = null;
      this.count = 0;
    };
    PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
        keyPrefix = bookKeeping.keyPrefix,
        func = bookKeeping.func,
        context = bookKeeping.context;
      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(
          mappedChild,
          result,
          childKey,
          emptyFunction.thatReturnsArgument
        );
      } else if (mappedChild != null) {
        if (ReactElement.isValidElement(mappedChild)) {
          mappedChild = ReactElement.cloneAndReplaceKey(
            mappedChild,
            keyPrefix +
              (mappedChild.key && (!child || child.key !== mappedChild.key)
                ? escapeUserProvidedKey(mappedChild.key) + "/"
                : "") +
              childKey
          );
        }
        result.push(mappedChild);
      }
    }
    function mapIntoWithKeyPrefixInternal(
      children,
      array,
      prefix,
      func,
      context
    ) {
      var escapedPrefix = "";
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + "/";
      }
      var traverseContext = MapBookKeeping.getPooled(
        array,
        escapedPrefix,
        func,
        context
      );
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }
    function forEachSingleChildDummy(traverseContext, child, name) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(
        children,
        result,
        null,
        emptyFunction.thatReturnsArgument
      );
      return result;
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
      count: countChildren,
      toArray: toArray
    };
    module.exports = ReactChildren;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ReactElement = __webpack_require__(22);
    var createDOMFactory = ReactElement.createFactory;
    if (false) {
      var ReactElementValidator = require("./ReactElementValidator");
      createDOMFactory = ReactElementValidator.createFactory;
    }
    var ReactDOMFactories = {
      a: createDOMFactory("a"),
      abbr: createDOMFactory("abbr"),
      address: createDOMFactory("address"),
      area: createDOMFactory("area"),
      article: createDOMFactory("article"),
      aside: createDOMFactory("aside"),
      audio: createDOMFactory("audio"),
      b: createDOMFactory("b"),
      base: createDOMFactory("base"),
      bdi: createDOMFactory("bdi"),
      bdo: createDOMFactory("bdo"),
      big: createDOMFactory("big"),
      blockquote: createDOMFactory("blockquote"),
      body: createDOMFactory("body"),
      br: createDOMFactory("br"),
      button: createDOMFactory("button"),
      canvas: createDOMFactory("canvas"),
      caption: createDOMFactory("caption"),
      cite: createDOMFactory("cite"),
      code: createDOMFactory("code"),
      col: createDOMFactory("col"),
      colgroup: createDOMFactory("colgroup"),
      data: createDOMFactory("data"),
      datalist: createDOMFactory("datalist"),
      dd: createDOMFactory("dd"),
      del: createDOMFactory("del"),
      details: createDOMFactory("details"),
      dfn: createDOMFactory("dfn"),
      dialog: createDOMFactory("dialog"),
      div: createDOMFactory("div"),
      dl: createDOMFactory("dl"),
      dt: createDOMFactory("dt"),
      em: createDOMFactory("em"),
      embed: createDOMFactory("embed"),
      fieldset: createDOMFactory("fieldset"),
      figcaption: createDOMFactory("figcaption"),
      figure: createDOMFactory("figure"),
      footer: createDOMFactory("footer"),
      form: createDOMFactory("form"),
      h1: createDOMFactory("h1"),
      h2: createDOMFactory("h2"),
      h3: createDOMFactory("h3"),
      h4: createDOMFactory("h4"),
      h5: createDOMFactory("h5"),
      h6: createDOMFactory("h6"),
      head: createDOMFactory("head"),
      header: createDOMFactory("header"),
      hgroup: createDOMFactory("hgroup"),
      hr: createDOMFactory("hr"),
      html: createDOMFactory("html"),
      i: createDOMFactory("i"),
      iframe: createDOMFactory("iframe"),
      img: createDOMFactory("img"),
      input: createDOMFactory("input"),
      ins: createDOMFactory("ins"),
      kbd: createDOMFactory("kbd"),
      keygen: createDOMFactory("keygen"),
      label: createDOMFactory("label"),
      legend: createDOMFactory("legend"),
      li: createDOMFactory("li"),
      link: createDOMFactory("link"),
      main: createDOMFactory("main"),
      map: createDOMFactory("map"),
      mark: createDOMFactory("mark"),
      menu: createDOMFactory("menu"),
      menuitem: createDOMFactory("menuitem"),
      meta: createDOMFactory("meta"),
      meter: createDOMFactory("meter"),
      nav: createDOMFactory("nav"),
      noscript: createDOMFactory("noscript"),
      object: createDOMFactory("object"),
      ol: createDOMFactory("ol"),
      optgroup: createDOMFactory("optgroup"),
      option: createDOMFactory("option"),
      output: createDOMFactory("output"),
      p: createDOMFactory("p"),
      param: createDOMFactory("param"),
      picture: createDOMFactory("picture"),
      pre: createDOMFactory("pre"),
      progress: createDOMFactory("progress"),
      q: createDOMFactory("q"),
      rp: createDOMFactory("rp"),
      rt: createDOMFactory("rt"),
      ruby: createDOMFactory("ruby"),
      s: createDOMFactory("s"),
      samp: createDOMFactory("samp"),
      script: createDOMFactory("script"),
      section: createDOMFactory("section"),
      select: createDOMFactory("select"),
      small: createDOMFactory("small"),
      source: createDOMFactory("source"),
      span: createDOMFactory("span"),
      strong: createDOMFactory("strong"),
      style: createDOMFactory("style"),
      sub: createDOMFactory("sub"),
      summary: createDOMFactory("summary"),
      sup: createDOMFactory("sup"),
      table: createDOMFactory("table"),
      tbody: createDOMFactory("tbody"),
      td: createDOMFactory("td"),
      textarea: createDOMFactory("textarea"),
      tfoot: createDOMFactory("tfoot"),
      th: createDOMFactory("th"),
      thead: createDOMFactory("thead"),
      time: createDOMFactory("time"),
      title: createDOMFactory("title"),
      tr: createDOMFactory("tr"),
      track: createDOMFactory("track"),
      u: createDOMFactory("u"),
      ul: createDOMFactory("ul"),
      var: createDOMFactory("var"),
      video: createDOMFactory("video"),
      wbr: createDOMFactory("wbr"),
      circle: createDOMFactory("circle"),
      clipPath: createDOMFactory("clipPath"),
      defs: createDOMFactory("defs"),
      ellipse: createDOMFactory("ellipse"),
      g: createDOMFactory("g"),
      image: createDOMFactory("image"),
      line: createDOMFactory("line"),
      linearGradient: createDOMFactory("linearGradient"),
      mask: createDOMFactory("mask"),
      path: createDOMFactory("path"),
      pattern: createDOMFactory("pattern"),
      polygon: createDOMFactory("polygon"),
      polyline: createDOMFactory("polyline"),
      radialGradient: createDOMFactory("radialGradient"),
      rect: createDOMFactory("rect"),
      stop: createDOMFactory("stop"),
      svg: createDOMFactory("svg"),
      text: createDOMFactory("text"),
      tspan: createDOMFactory("tspan")
    };
    module.exports = ReactDOMFactories;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _require = __webpack_require__(22),
      isValidElement = _require.isValidElement;
    var factory = __webpack_require__(73);
    module.exports = factory(isValidElement);
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = "15.6.2";
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _require = __webpack_require__(100),
      Component = _require.Component;
    var _require2 = __webpack_require__(22),
      isValidElement = _require2.isValidElement;
    var ReactNoopUpdateQueue = __webpack_require__(103);
    var factory = __webpack_require__(140);
    module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn =
        maybeIterable &&
        ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    module.exports = getIteratorFn;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var nextDebugID = 1;
    function getNextDebugID() {
      return nextDebugID++;
    }
    module.exports = getNextDebugID;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var lowPriorityWarning = function() {};
    if (false) {
      var printWarning = function(format) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }
        var argIndex = 0;
        var message =
          "Warning: " +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== "undefined") {
          console.warn(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };
      lowPriorityWarning = function(condition, format) {
        if (format === undefined) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning " +
              "message argument"
          );
        }
        if (!condition) {
          for (
            var _len2 = arguments.length,
              args = Array(_len2 > 2 ? _len2 - 2 : 0),
              _key2 = 2;
            _key2 < _len2;
            _key2++
          ) {
            args[_key2 - 2] = arguments[_key2];
          }
          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    module.exports = lowPriorityWarning;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(29);
    var ReactElement = __webpack_require__(22);
    var invariant = __webpack_require__(0);
    function onlyChild(children) {
      !ReactElement.isValidElement(children)
        ? false
          ? invariant(
              false,
              "React.Children.only expected to receive a single React element child."
            )
          : _prodInvariant("143")
        : void 0;
      return children;
    }
    module.exports = onlyChild;
  },
  function(module, exports, __webpack_require__) {
    "use strict";
    var _prodInvariant = __webpack_require__(29);
    var ReactCurrentOwner = __webpack_require__(13);
    var REACT_ELEMENT_TYPE = __webpack_require__(102);
    var getIteratorFn = __webpack_require__(245);
    var invariant = __webpack_require__(0);
    var KeyEscapeUtils = __webpack_require__(238);
    var warning = __webpack_require__(4);
    var SEPARATOR = ".";
    var SUBSEPARATOR = ":";
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === "object" && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(
      children,
      nameSoFar,
      callback,
      traverseContext
    ) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean") {
        children = null;
      }
      if (
        children === null ||
        type === "string" ||
        type === "number" ||
        (type === "object" && children.$$typeof === REACT_ELEMENT_TYPE)
      ) {
        callback(
          traverseContext,
          children,
          nameSoFar === ""
            ? SEPARATOR + getComponentKey(children, 0)
            : nameSoFar
        );
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix =
        nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(
            child,
            nextName,
            callback,
            traverseContext
          );
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(
                child,
                nextName,
                callback,
                traverseContext
              );
            }
          } else {
            if (false) {
              var mapsAsChildrenAddendum = "";
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum =
                    " Check the render method of `" +
                    mapsAsChildrenOwnerName +
                    "`.";
                }
              }
              process.env.NODE_ENV !== "production"
                ? warning(
                    didWarnAboutMaps,
                    "Using Maps as children is not yet fully supported. It is an " +
                      "experimental feature that might be removed. Convert it to a " +
                      "sequence / iterable of keyed ReactElements instead.%s",
                    mapsAsChildrenAddendum
                  )
                : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName =
                  nextNamePrefix +
                  KeyEscapeUtils.escape(entry[0]) +
                  SUBSEPARATOR +
                  getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(
                  child,
                  nextName,
                  callback,
                  traverseContext
                );
              }
            }
          }
        } else if (type === "object") {
          var addendum = "";
          if (false) {
            addendum =
              " If you meant to render a collection of children, use an array " +
              "instead or wrap the object using createFragment(object) from the " +
              "React add-ons.";
            if (children._isReactElement) {
              addendum =
                " It looks like you're using an element created by a different " +
                "version of React. Make sure to use only one copy of React.";
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += " Check the render method of `" + name + "`.";
              }
            }
          }
          var childrenString = String(children);
          true
            ? false
              ? invariant(
                  false,
                  "Objects are not valid as a React child (found: %s).%s",
                  childrenString === "[object Object]"
                    ? "object with keys {" +
                        Object.keys(children).join(", ") +
                        "}"
                    : childrenString,
                  addendum
                )
              : _prodInvariant(
                  "31",
                  childrenString === "[object Object]"
                    ? "object with keys {" +
                        Object.keys(children).join(", ") +
                        "}"
                    : childrenString,
                  addendum
                )
            : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, "", callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  },
  function(module, exports) {
    function select(element) {
      var selectedText;
      if (element.nodeName === "SELECT") {
        element.focus();
        selectedText = element.value;
      } else if (
        element.nodeName === "INPUT" ||
        element.nodeName === "TEXTAREA"
      ) {
        var isReadOnly = element.hasAttribute("readonly");
        if (!isReadOnly) {
          element.setAttribute("readonly", "");
        }
        element.select();
        element.setSelectionRange(0, element.value.length);
        if (!isReadOnly) {
          element.removeAttribute("readonly");
        }
        selectedText = element.value;
      } else {
        if (element.hasAttribute("contenteditable")) {
          element.focus();
        }
        var selection = window.getSelection();
        var range = document.createRange();
        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);
        selectedText = selection.toString();
      }
      return selectedText;
    }
    module.exports = select;
  },
  function(module, exports) {
    var stylesInDom = {},
      memoize = function(fn) {
        var memo;
        return function() {
          if (typeof memo === "undefined") memo = fn.apply(this, arguments);
          return memo;
        };
      },
      isOldIE = memoize(function() {
        return 'sad browser';
      }),
      getHeadElement = memoize(function() {
        return document.head || document.getElementsByTagName("head")[0];
      }),
      singletonElement = null,
      singletonCounter = 0,
      styleElementsInsertedAtTop = [];
    module.exports = function(list, options) {
      if (typeof DEBUG !== "undefined" && DEBUG) {
        if (typeof document !== "object")
          throw new Error(
            "The style-loader cannot be used in a non-browser environment"
          );
      }
      options = options || {};
      if (typeof options.singleton === "undefined")
        options.singleton = isOldIE();
      if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
      var styles = listToStyles(list);
      addStylesToDom(styles, options);
      return function update(newList) {
        var mayRemove = [];
        for (var i = 0; i < styles.length; i++) {
          var item = styles[i];
          var domStyle = stylesInDom[item.id];
          domStyle.refs--;
          mayRemove.push(domStyle);
        }
        if (newList) {
          var newStyles = listToStyles(newList);
          addStylesToDom(newStyles, options);
        }
        for (var i = 0; i < mayRemove.length; i++) {
          var domStyle = mayRemove[i];
          if (domStyle.refs === 0) {
            for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
            delete stylesInDom[domStyle.id];
          }
        }
      };
    };
    function addStylesToDom(styles, options) {
      for (var i = 0; i < styles.length; i++) {
        var item = styles[i];
        var domStyle = stylesInDom[item.id];
        if (domStyle) {
          domStyle.refs++;
          for (var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j]);
          }
          for (; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j], options));
          }
        } else {
          var parts = [];
          for (var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j], options));
          }
          stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts };
        }
      }
    }
    function listToStyles(list) {
      var styles = [];
      var newStyles = {};
      for (var i = 0; i < list.length; i++) {
        var item = list[i];
        var id = item[0];
        var css = item[1];
        var media = item[2];
        var sourceMap = item[3];
        var part = { css: css, media: media, sourceMap: sourceMap };
        if (!newStyles[id])
          styles.push((newStyles[id] = { id: id, parts: [part] }));
        else newStyles[id].parts.push(part);
      }
      return styles;
    }
    function insertStyleElement(options, styleElement) {
      var head = getHeadElement();
      var lastStyleElementInsertedAtTop =
        styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
      if (options.insertAt === "top") {
        if (!lastStyleElementInsertedAtTop) {
          head.insertBefore(styleElement, head.firstChild);
        } else if (lastStyleElementInsertedAtTop.nextSibling) {
          head.insertBefore(
            styleElement,
            lastStyleElementInsertedAtTop.nextSibling
          );
        } else {
          head.appendChild(styleElement);
        }
        styleElementsInsertedAtTop.push(styleElement);
      } else if (options.insertAt === "bottom") {
        head.appendChild(styleElement);
      } else {
        throw new Error(
          "Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'."
        );
      }
    }
    function removeStyleElement(styleElement) {
      styleElement.parentNode.removeChild(styleElement);
      var idx = styleElementsInsertedAtTop.indexOf(styleElement);
      if (idx >= 0) {
        styleElementsInsertedAtTop.splice(idx, 1);
      }
    }
    function createStyleElement(options) {
      var styleElement = document.createElement("style");
      styleElement.type = "text/css";
      insertStyleElement(options, styleElement);
      return styleElement;
    }
    function createLinkElement(options) {
      var linkElement = document.createElement("link");
      linkElement.rel = "stylesheet";
      insertStyleElement(options, linkElement);
      return linkElement;
    }
    function addStyle(obj, options) {
      var styleElement, update, remove;
      if (options.singleton) {
        var styleIndex = singletonCounter++;
        styleElement =
          singletonElement || (singletonElement = createStyleElement(options));
        update = applyToSingletonTag.bind(
          null,
          styleElement,
          styleIndex,
          false
        );
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
      } else if (
        obj.sourceMap &&
        typeof URL === "function" &&
        typeof URL.createObjectURL === "function" &&
        typeof URL.revokeObjectURL === "function" &&
        typeof Blob === "function" &&
        typeof btoa === "function"
      ) {
        styleElement = createLinkElement(options);
        update = updateLink.bind(null, styleElement);
        remove = function() {
          removeStyleElement(styleElement);
          if (styleElement.href) URL.revokeObjectURL(styleElement.href);
        };
      } else {
        styleElement = createStyleElement(options);
        update = applyToTag.bind(null, styleElement);
        remove = function() {
          removeStyleElement(styleElement);
        };
      }
      update(obj);
      return function updateStyle(newObj) {
        if (newObj) {
          if (
            newObj.css === obj.css &&
            newObj.media === obj.media &&
            newObj.sourceMap === obj.sourceMap
          )
            return;
          update((obj = newObj));
        } else {
          remove();
        }
      };
    }
    var replaceText = (function() {
      var textStore = [];
      return function(index, replacement) {
        textStore[index] = replacement;
        return textStore.filter(Boolean).join("\n");
      };
    })();
    function applyToSingletonTag(styleElement, index, remove, obj) {
      var css = remove ? "" : obj.css;
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = replaceText(index, css);
      } else {
        var cssNode = document.createTextNode(css);
        var childNodes = styleElement.childNodes;
        if (childNodes[index]) styleElement.removeChild(childNodes[index]);
        if (childNodes.length) {
          styleElement.insertBefore(cssNode, childNodes[index]);
        } else {
          styleElement.appendChild(cssNode);
        }
      }
    }
    function applyToTag(styleElement, obj) {
      var css = obj.css;
      var media = obj.media;
      if (media) {
        styleElement.setAttribute("media", media);
      }
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = css;
      } else {
        while (styleElement.firstChild) {
          styleElement.removeChild(styleElement.firstChild);
        }
        styleElement.appendChild(document.createTextNode(css));
      }
    }
    function updateLink(linkElement, obj) {
      var css = obj.css;
      var sourceMap = obj.sourceMap;
      if (sourceMap) {
        css +=
          "\n/*# sourceMappingURL=data:application/json;base64," +
          btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) +
          " */";
      }
      var blob = new Blob([css], { type: "text/css" });
      var oldSrc = linkElement.href;
      linkElement.href = URL.createObjectURL(blob);
      if (oldSrc) URL.revokeObjectURL(oldSrc);
    }
  },
  function(module, exports, __webpack_require__) {
    var content = __webpack_require__(141);
    if (typeof content === "string") content = [[module.i, content, ""]];
    var update = __webpack_require__(251)(content, {});
    if (content.locals) module.exports = content.locals;
    if (false) {
      if (!content.locals) {
        module.hot.accept(
          "!!../../node_modules/css-loader/index.js??ref--2-1!../../node_modules/postcss-loader/index.js??postcss!../../node_modules/stylus-loader/index.js!./index.styl",
          function() {
            var newContent = require("!!../../node_modules/css-loader/index.js??ref--2-1!../../node_modules/postcss-loader/index.js??postcss!../../node_modules/stylus-loader/index.js!./index.styl");
            if (typeof newContent === "string")
              newContent = [[module.id, newContent, ""]];
            update(newContent);
          }
        );
      }
      module.hot.dispose(function() {
        update();
      });
    }
  },
  function(module, exports, __webpack_require__) {
    (function(factory) {
      true
        ? (module["exports"] = factory())
        : typeof define === "function" && define["amd"]
        ? define(factory())
        : (window["stylisRuleSheet"] = factory());
    })(function() {
      "use strict";
      return function(insertRule) {
        var delimiter = "/*|*/";
        var needle = delimiter + "}";
        function toSheet(block) {
          if (block)
            try {
              insertRule(block + "}");
            } catch (e) {}
        }
        return function ruleSheet(
          context,
          content,
          selectors,
          parents,
          line,
          column,
          length,
          ns,
          depth,
          at
        ) {
          switch (context) {
            case 1:
              if (depth === 0 && content.charCodeAt(0) === 64)
                return insertRule(content + ";"), "";
              break;
            case 2:
              if (ns === 0) return content + delimiter;
              break;
            case 3:
              switch (ns) {
                case 102:
                case 112:
                  return insertRule(selectors[0] + content), "";
                default:
                  return content + (at === 0 ? delimiter : "");
              }
            case -2:
              content.split(needle).forEach(toSheet);
          }
        };
      };
    });
  },
  function(module, exports) {
    function E() {}
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({ fn: callback, ctx: ctx });
        return this;
      },
      once: function(name, callback, ctx) {
        var self = this;
        function listener() {
          self.off(name, listener);
          callback.apply(ctx, arguments);
        }
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? (e[name] = liveEvents) : delete e[name];
        return this;
      }
    };
    module.exports = E;
  },
  function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(105);
  }
]);
